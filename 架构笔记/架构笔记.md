# 架构笔记

## OAuth

####OAuth介绍

- 定义 开放式授权协议
- 应用场景：微信应用获取用户微信昵称和头像如何授权？
- 设计思路：OAuth在微信和应用间设置一个授权层，应用不能直接登录微信只能获取授权。用户在授权层登录后给用户发放令牌，指定授权时间及范围。应用获取授权后根据令牌权限规范获取昵称和头像。
- 工作流程：
  1. 用户启动应用后会跳转到授权层要求用户登录
  2. 用户同意授权
  3. 应用使用授权向微信申请令牌
  4. 微信对应用认证后发送令牌
  5. 应用使用令牌向微信请求昵称头像
  6. 微信确认令牌无误发送昵称和头像

#### 授权码模式

客户端必须得到用户授权才能获得令牌 OAuth2.0定义四种授权模式（授权码模式、简化模式、密码模式、客户的模式）

授权码模式是功能最完整流程最严密的授权码模式，通过客户端的后台服务器与“服务提供商”认证服务器进行互动。

**工作流程**

- 用户访问app，app将页面跳转到认证服务器
- 用户选择是否授权
- 用户同意授权，认证服务器将用户导向app指定的“重定向URL”中，并且提供授权码
- app收到授权码并追加“重定向URL”，向认证服务器申请令牌
- 认证服务器核对授权码和”重定向URL“，确认无误后向客户端发送访问令牌和更新令牌

#### QQ授权登录

1. 开发者注册，注册公司账户

2. 网站接入申请 获取appid和appkey，进入管理中心添加网站和对应信息

3. 开发网站，设置qq登录入口，登录授权完成后跳转回原网站。登录成功后即可发送请求获取access token和openid，在调用openAPI访问和修改用户信息时必须传入。（access token用来判断用户在本地上的登录状态具有3个月有效期，openid是此网站上唯一对应用户身份的标识，授权码code有效期5s左右直接传入重定向url中）

   用户确认授权返回一个code 

#### node实现OAuth

```js
//server.js
var express = require('experss')
var path = require('path')
var uuid = require('uuid') //生成一个随机字符串不重复作为授权码
var app = express()
//设置模板存放目录
app.set('views',path.resolve('views'))
app.set('view engine','ejs')
//模拟用户登录的中间件
app.user(function(req,res,next){
    req.loginUserId = 'test'
    next()
})
var USERS = {
    'id':{
        name:'测试1',
        avatar:'img/test.jpg'
    }
}
var appInfo = {
    appId:'id', //服务器生成的id和密钥
    serect:'123456'
    name:'测试',
    desc:'描述'
}
var CODES={},TOKENS={}
//用户访问授权接口 渲染授权页面
app.get('/authorize',fucntion(req.res){
        req.render('auth',{
        	loginUserId:loginUserId,
        	appInfo:appInfo
        })
 })
 //确认授权时接受请求的数据 生成授权码调用回调地址追加授权码
 app.post('/authorize',function(req,res){
     //生成授权码
     var code = uuid.v4()
     CODES[code] = {
         clientId:req.query.clientId,//从参数中获取客户端id
         userId:req.loginUserId //从请求中获取用户id
     }
     //回调url http:localhost:3000/authorize?clientId=id&redirectUrl=http://localhost:8080/callback?code=1
     			res.redirect(req.query.redirectUrl+'&code='+code)
     //在服务器端保存code和对应的应用id
 })
app.get('/token',function(req,res){
    var code = req.query.code
    var token = uuid.v4()
    //记录token对应的id
    TOKENS[token]={
        clientId:CODES[code].clientId,
        userId:CODES[code].userId
    }
    res.send({token:token})
})
//根据token获取用户信息
app.get('/userInfo',function(req,res){
    var token = req.query.token
    var userId = TOKENS[token].userId
    res.send(USERS[userId])
})
app.listen(3000)
```

```html
//auth.ejs
<html>
<body>
    <form method="post" action = "">
        <h2>
            <%=loginUserId%>，请问是否确定授权<%=appInfo.name%>网站
        </h2>
        <p>
           应用简介<%=appInfo.desc/%>
        </p>
        <input type="submit" value="确定">        
    </form>
</body>
</html>        
```

```js
//client.js 回调地址服务器
var express = require('express')
var request = require('request')
var app = express()
//如果qq服务器认证通过后回调本地址回调时传授权code码
app.get('/callback',functtion(req,res){
        //在客户端回调接口中后去客户端发的code
        var code = req.query.code
        //获取令牌
    request('http://localhost:3000/token?code='+token,function(err,response,body){
    	var tokenInfo =JSON.parse(body)
        var token = tokenInfo.token
        request('http:localhost:3000/userInfo?token='+token,function(err,reponse,body){
            res.send(body)
        })
	})
})
app.listen(8080)
```

##DIFF算法

#### 虚拟DOM

虚拟节点（virtual dom）通过JS的Object对象模拟DOM中的节点在通过特点的render方法将其渲染为真实的DOM节点

<img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\vnode.png" alt="vnode" />

```js
class Element{//虚拟dom的类
    constuctor(type,props,children){
        this.type = type
        this.props = props
        this.children = children
    }
}
function createElement(type,props,children){//返回虚拟节点object对象
    return new Element(type,props,children)
}
function setAttr(node,key,vaule){//设置属性值
    switch(key){
        case 'value':
        if(node.tagname.toUpperCase()==='INPUT'||node.tagName.toUpperCase()==='TEXTAREA'){
                node.value = value
            }else{
                node.setAttribute(key,value)
            }
            break
        case 'style':
            node.style.cssText = value
            break
        default:
            node.setAttribute(key,value)
            break
    }
}
//render方法
function render(eleObj){//将虚拟vnode转为真实的dom
    let el = document.createElement(eleObj.type)
    for(let key in eleObj.props){
        //设置属性的方法
        setAttr(el,key,eleObj.props[key])
    }
    eleObj,childern.forEach(child=>{//遍历child 判断child是否为Element实例
        child = (child instanceof Element)?render(child):document.createTextNode(child)
        el.appendChild(child)   		
    })
    return el
}
function renderDom(el,target){//将元素渲染到页面
    target.appendChild(el)
}
export {createElement, render, Element,renderDom}

//使用
let vertualDom = createElement('ul',{class:'list'},[
    createElement('li',{class:'item'},['1']),
    createElement('li',{class:'item'},['2']),
	createElement('li',{class:'item'},['3'])
])
let el = render(vertualDom)
renderDom(el,window.root)
```

#### DIFF算法

DIFF算法用于比较两个虚拟dom的区别，通过js层计算返回一个patch对象补丁描述改变内容，将这个补丁用来描述改变内容完成页面渲染。

**DOM diff优化策略**

1. 更新时只比较同级，不会跨级比较
2. 两个不同类型的组件会生成两个不同的树
3. 通过key来表示哪些子元素在不同的渲染下保持稳定

⽐对两个虚拟**dom**时会有三种操作：删除、替换和更新。

vnode是现在的虚拟dom，newVnode是新虚拟dom。

-  删除：newVnode不存在时

- 替换：vnode和newVnode类型不同或key不同时

- 更新：有相同类型和key但vnode和newVnode不同时

**差异计算**

​	先序深度优先遍历

<img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\diff.png" alt="diff" style="zoom:60%;" />

1. 用js模拟虚拟dom
2. 将虚拟dom转为真实dom插入页面中
3. 如果有事件发生修改了虚拟dom，比较两颗虚拟dom树的差异，得到差异对象
4. 把差异对象应用到真正的dom树上

```js
//diff.js  平级元素交换无法实现
//规则 
//节点类型相同时检查属性 产生属性补丁包{type:'ATTRS',attrs:{class:'list-group'}}节点类型不同直接采用替换模式{type:'REPLACE',newNode:newNode}
//节点不存在时检测属性是否相同产生一个属性补丁包{type:'REMOVE',index:xxx}
//文本的变化{type:'TEXT',text:1}
function diff(oldTree,newTree){
    let patches = {}
    let index = 0
    //递归树 比较后结构放入补丁包
    walk(oldTree,newTree,index,patches)
    return patches
}
function diffAttr(oldAttrs,newAttrs){
    let patch={}
    //判断老的属性和新属性的关系
    for(let key in oldAttrs){
        if(oldAttrs[key]!==newAttrs[key]){
            patch[key]=newAttrs[key] //有可能undefined
        }
    }
    for(let key in newAttrs){
        //老节点没有新节点的属性
        if(!oldAttrs.hasOwnProperty(key)){
            patch[key]=newAttrs[key]
        }
    }
    return patch
}
let Index =0
function diffChildren(oldChildren,newChildren,index,patches){
    //比较老的第一个和新的第一个
    oldChildren.forEach((child,index)=>{
        //索引不是index而是固定的计数器
        walk(child,newChildren[index],++Index,patches)
    })
}
const ATTRS='ATTRS'
const TEXT = 'TEXT'
const REMOVE = 'REMOVE'
const REPLACE = 'REPLACE'
function isString(node){
    return Object.prototype.toString.call(node)==='[object string]'
}
function walk(oldNode,newNode,index,patches){
    let currentPatch = []
    if(!newNode){
        currentPatch.push(type:REMOVE,index:index)
    }else if(isString(oldNode)&&isString(newNode)){
        if(oldNode !== newNode){//判断文本是否一致
            currentPatch.push({type:TEXT,text:newNode})
        }
    }else if(oldNode.type === newNode.type){
        //比较属性是否更改
        let attrs = diffAttr(oldNode.props,newNode.props)
        if(Object.keys(attrs).length>0){
            currentPatch.push({type:ATTRS,attrs})
        }
        //如果有儿子节点遍历儿子节点
        diffChildren(oldNode.children,newNode.children)
    }else{
        //说明节点被替换了
        currentPatch.push({type:REPLACE,newNode})
    }
    if(currentPatch.length>0){
        //将元素和补丁包对应起来
        patches[index]=currentPatch
    }
    
}
//patch.js
let allPatches
let index = 0 //默认打补丁元素
function patch(node,patches){
    allpatches = patches
    walk(node)
}
function walk(node){
    let currentPatch = allpatches[index++]
    let childNodes=node.childNodes
    childNodes.forEach(child=>walk(child))
    if(currentPatch){
        doPatch(node,currentPatch)
    }
}
function doPatch(node,patches){
    patches.forEach(patch=>{
        switch(patch.type){
                case'ATTRS':
                 for(let key in patvh.attrs){
                     let value = patch.attrs[key]
                     if(value){
                         setAttr(node,key,value)
                     }else{
                         node.removeAtribute(key)
                     }
                 }
                 break;
                case'TEXT':
                 node.textContent = patch.text
                 break;
                case'REPLACE':
                 let newNode = (patch.newNode instanceof Element)?render(patch.newNode):document.createTextNode(patch.newNode)
                 node.parentNode.replaceChild(newNode,oldNode)
                 break;
                case'REMOVE':
                node.parentNode.removeChild(node)
                 break;
            	default:
                 break;
                
        }
    })
}
//使用
let el = render(vertualDom1)
renderDom(el,window.root)
let patches = diff(vertualDom1,vertualDom2)
//给元素打补丁重新更新视图
patch(el,patches)
```

## MVVM

#### MVVM原理

vue中实现双向数据绑定 

1. 模板的编译 
2. 数据劫持--Object.defineProperty 
3. watcher 通过发布订阅模式

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\mvvm.png)

```js

```

#### Object.defineProperty

Object.defineProperty()直接在一个对象上定义一个新属性或者修改一个对象的现有属性并返回此对象。

参数: obj定义属性的对象 prop定义或者修改的属性名称 descriptor定义或修改的属性描述符

属性描述符包含

1. 数据描述符 具有值属性

   **configurable** 默认false 为true时描述符才能被改变

   **enumerable** 默认false 为true时该属性才出现在对象的枚举属性

   **value** 默认undefined 

   **writable** 默认false 为true时value的值才能被赋值运算符改变

2. 存取描述符 getter、setter描述的属性

   **get** 属性的getter函数 访问时调用 执行时不传入任何参数 会传入this 返回值为属性的值

   **set**属性的setter函数 属性值被修改时调用 结束被赋予的新值为参数 会传入赋值的this对象

描述符同时拥有value/writable和get/set会产生一个异常

```js
let obj = {}
Object.defineProperty(obj,'key',{
    enumerable:false,
    configurable:false,
    writable:false,
    value:'static'
})
```

vue不能新增不存在的属性 不存在的属性没有get和set

#### 数据劫持

```js
function mvvm(options={}){
    this.$options = options
    //将options挂载到this._data上
    var data = this._data = this.options
    observe(data)
    for(let key in data){//this代理this._data
        Object.defineProperty(this,key,{
            enumerable:true,
            get(){
                return this._data[key]
            },
            set(newVal){
                this._data[key] = newVal
            }
        })
    }
}
function Observe(data){
    for(let key in data){
        let val = data[key]
        observe(val)
        Object.defineProperty(data,key,{
            enumerable:true,
            get(){
                return val
            },
            set(newVal){
                if(newVal=== val){
                    return
                }
                val = newVal
                observe(newval)
            }
        })
    }
    //执行编译
    new Compile(options.el,this)
}
function observe(data){
    if(typeof data!=='object') return
    return new Observe(data)
    let dep = new Dep()
    for(let key in data){
        let val = data[key]
        observe(val)
        Object.defineProperty(data,key,{
            enumerable:true,
            get(){
                Dep.target && dep.addSub(Dep.target)
                return val
            },
            set(newVal){
                if(newVal === val){
                    return
                }
                val = newVal
                observe(newVal)
                dep.notify()
            }
        })
    }
}
```

#### 编译模板

```js
function Compile(el,vm){
    //el替换的范围
    vm.$el = document.querySelector(el)
    let fragment = document.createDocumentFragment()
    while(child = vm.$el.firstChild){
        fragment.appenChild(child)
    }
    replace(fragment)
    function replace(fragment){      				 	  
        Array.from(fragment.childNodes).forEach(function(node){
        //循环每一层节点
        let text = node.textContent
        let reg = /\{\{(.*)\}\}/
        if(node.nodeType === 3 && reg.test(text)){
            //RegExp.$1为reg的第一个分组
            let arr = RegExp.$1.split('.')
            let val = vm
            arr.forEach(function(k){
                val = vm[k]
            })
            node.textContent = text.replace(/\{\{(.*)\}\}/,val)
        }
        if(node.childNodes){
            replace(node)
        }
    })
    }
    //vm.$el.appendChild(fragment)
}
```

#### 发布订阅模式

```js
function Dep(){
    this.subs = []
}
Dep.prototype.addSub = function(sub){
    this.subs.push(sub)
}
Dep.prototype.notify = function(){
    this.subs.forEach(sub=>sub.update())
}
function Watcher(fn){
    this.fn = fn
}
Watcher.prototype.update = function(){
    this.fn()
}
//使用
let watcher = new Watcher(function(){
    alert(1)
})
let dep = new Dep()
//订阅watcher监听
dep.addSub(watcher)
//执行绑定好的update
dep.notify()
```

## git使用

#### git介绍

git版本控制

1.  备份文件
2. 记录历史
3. 回到过去
4. 多段共享
5. 团队协作

svn和git的区别？

- svn是集中式需要一台中央服务器git为分布式速度比svn快
- svn中每个文件夹中都有一个.svn文件，git有一个单独的.git文件夹

git组成：工作区-暂存区-历史区

pwd（print working directory） 打印当前工作的根目录

#### git安装使用

1. 安装 官网链接

2. 配置用户

   ```js
   git config --list //查看git配置文件
   git config --global user.name='用户名' //配置全局的账户密码
   git config --global user.email='邮箱'
   ```

3. git初始化和Linux命令

   ```js
   git init  //初始化文件夹 被git接管 不能在文件夹初始化后再初始化子文件夹 删除.git文件夹后初始化失效
   rm -rf .git //慎用 递归删除.git文件夹
   mkdir 文件夹名 //创建文件夹
   clear //清除屏幕
   ls -al //显示目录下所有文件
   touch 文件名 //创建文件
   cat 文件名 //查看文件
   vi 文件名 //编辑文件 i:插入模式 esc退出编辑模式
   :q！ //不保存退出
   :wq //保存退出
   echo '内容' >> 文件名 //输入文件内容
   ```

####提交到历史区

1. 工作区提交到暂存区 红色为工作区 绿色为暂存区 无色为历史区

   ```js
   git status //查看git状态
   git add . / -A //所有文件添加到暂存区
   git rm --cache 文件名 //删除暂存区的指定文件
   ```

2. 暂存区提交到历史区

   ```js
   git commit -m '备注' //提交暂存区文件到历史区
   git log //git提交日志
   ```

#### 撤销文件

1. 比较各区文件

   ```js
   git diff //工作区比暂存区
   git diff --cache //暂存区比历史区
   git diff master（分支名） //工作区比历史区
   ```

2. 撤销文件

   - 撤销工作区文件修改

     ```js
     git checkout 文件名 //使用暂存区文件覆盖掉工作区文件
     ```

   - 撤销暂存区文件修改

     ```js
     git reset HEAD 文件名 //使暂存区回退上一个版本
     ```


   - **错误操作** 撤销历史区文件修改

     ```js
     git commit -a -m '编辑备注' //文件需要提交过一次 直接提交到工作区
     git reset --hard 版本号 //回滚到指定历史版本
     git reset --hard^ //回滚到上一版本
     git reflog //恢复回滚操作
     ```

#### 分支

1. 查看分支

   ```js
   git branch //查看当前分支 *后为当前分支
   ```

2. 新建分支

   ```js
   git branch 分支名 //创建指定的分支
   ```

3. 切换分支

   ```js
   git checkout 分支名 //切换到指定分支
   git checkout -b 分支名 //创建并切换分支
   ```

4. 删除分支

   ```js
   git branch -D 分支名 //删除分支 不能删除当前分支
   ```

5. 文件修改时切换分支

   ```js
   git stash //暂存文件
   git stash pop //删除暂存文件
   ```

6. 合并分支

   ```js
   git merge 分支名 //合并分支
   ```

#### 远程仓库

本地->github

```git
1. 创建git账号
2. 本地提交
   - README.md（必有文件）
   - 创建.gitignore git提交时忽略立马写的文件名 （.idea node_modules .ds_Store）
   - git不会上传空文件夹 添加.gitkeep在空文件夹内
3. 进入github创建一个空仓库
   - echo "# 项目名"
4. 关联远程仓库
   - git remote add origin http://仓库地址
   - git remove rm origin 删除关联仓库
   - git remove -v 查看关联仓库
5. 推送代码
   git push -u origin master
```

拉取线上仓库

```git
git pull origin master
```

git发布静态页

```git
gh-pages分支发布
- 在项目中创建gh-pages分支
    git checkout -b ah-pages
    touch inde.html
- 将分支提供到仓库
    git addd .
    git commit -m '备注'
    git push orgin gh-pages
- 找到提供的网址 setting--> gitpages
```

fork

fork是在当前项目下克隆一份 代码有更新不会随之更新

拉取fork项目到本地 `git clone 项目地址 项目别名`

## node基础

#### node安装相关

1. 配置环境变量 `add to path` 将C:\Program Files\nodejs填入系统环境变量

2. 运行一个js文件

   -  控制台 `node 文件名 `
   - 编辑器  webstorm setting->node.js and npm 

3. node特点

   主线程为单线程（异步）callback，将后续的逻辑写成函数传入当前执行的函数中，执行的函数得到结果后执行传入的函数

   1. 节约内存
   2. 节约切换上下文（context）的时间
   3. 锁的问题并发资源的处理

   - 同步与异步
     - **同步**：发起调用后主线程只能挂起，被动的等待，这个调用的结果
     - **异步**：发起调用之后主线程可以做别的事情，被调用者通过通知来告知调用者结果
     
   - 阻塞/非阻塞
     
     阻塞和非阻塞关注的是程序在等待调用结果（消息返回值）时的状态
     
     - 阻塞针对内核来说，向内核发起请求的时候不会阻塞主线程的执行，调用结果返回之前当前进程会被挂起，调用线程只有在得到结果之后才会返回
     - 非阻塞是实现异步的前置条件，不能立即得到结果之前该调用不会阻塞当前进程
     
   - IO
     - input（输入）从文件系统中读取文件
     - output（输出）向文件系统写入文件
     
   - 单线程/多线程
     - 单线程指程序按顺序执行，前面流程执行完毕时才可以执行到下一个
     - 多线程是指程序同时可以执行多个任务通过系统线程上下文切换来弥补同步时IO调用的时间开销
     - node单线程指主线程是单线程的，所有阻塞的部分交给一个线程池处理，主线程通过一个队列跟线程池协作
     
   - 事件循环 eventloop

     ![eventloop](C:\Users\ASUS\Desktop\笔记\架构笔记\img\eventloop.png)

     v8引擎解析js脚本 解析后的代码调用node api

     libuv负责node api的执行 将不同的任务分配给不同的线程形成一个event loop，以异步的方式将任务的执行结果返回给v8引擎，v8引擎再将结果返回给用户

     - 管理异步动作定时器和回调函数的机制叫事件环
     - 异步时会压入这个队列不停的读取事件，事件发生后把对应的回调加入队列
     - 队列按加入的顺序依次执行由普通函数和回调函数组成
     
     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\eventloop原理.png)

> https://juejin.cn/post/6844903621444763662#heading-5
>
> https://blog.csdn.net/weixin_33720956/article/details/88015216
>
> https://www.jianshu.com/p/49b6009650ef

####node全局对象

1. global对象

   - node全局对象 Global 它及其所有属性都可以在程序的任何地方访问即全局变量
   
   - js中window为全局对象

   - node自带模块化功能 一个js文件就是一个模块，模块this不是global，每个文件都有局部作用域，不会将属性挂载在global上

2. 全局作用域

   - 全局作用域（global）可以定义一些不需要通过任何模块加载即可使用的变量函数或类
   - 定义全局变量时变量会成为global的属性
   - 永远不要使用var关键字定义变量以免污染全局作用域
   - unre和ref
   
3. global全局变量的属性

   全局变量在所有模块中均可以不声明直接使用 但以下变量的作用域只在模块内。

   - __dirname
   - __filename
   - exports
   - require
   - module

global中挂载的属性有

- console 

  - .log()
  - .dir()
  - .warn()
  - .error()
  - .info()
  - .time() 与timeEnd()配对使用 括号内标志必须一致来计算两个console之间代码执行时间
  - .timeEnd()
  - .assert() 断言
  - .trace() 跟踪当前代码的调用栈
  
 - process 进程对象 设置环境变量（在命令行里配置NODE_ENV）

   ```js
   let url = ''
   if (process.env.NODEX_ENV == 'dev'){
       url = 'http://localhost:3000'
   }else {
       url = 'http://www.网址.com'
   }
   ```

   - .chdir() change direcotry改变当前的工作目录
   - .cwd() current working directory 当前工作目录
   - .memoryUsage 检测当前内存的使用量 v8内存最大1.7G
     - rss 常驻内存
     - heapTotal堆内存使用量
     - heapUsed已经使用量
     - external外部内存的使用量
   - .nextTick()把回调函数放在当前执行栈底部
   - .stdin.on()标准输入
   - .stdout.write()标准输出 等于console.log
   - .stdrr.write() 等于cosole.error

 - Buffer 缓存区

 - clearImmediate/setImmediate 把回调函数放入事件队列尾部

 - clearTimeout/setTimeout node中定时器中this指向自己

 - clearInterval/setInterval

#### repl

   node中测试js代码的交互式环境 （read eval print loop）

   1. 进入REPL环境

      - 命令行输入node命令回车进入

      - 通过代码进入repl

        ```js
        let repl = require('repl')
        let context = repl.start().context
        ```

   2. REPL操作

      - 变量的操作声明普通变量和对象

      - eval

      - 下划线访问最近使用表达式

      - 多行书写

      - REPL上下文对象

        ```js
        let repl = require('repl')
        let con = repl.start().content
        con.msg = 'hello'
        con.hello = function(){
            console.log(con.msg)
        }
        ```

   3. REPL基础命令

      - break退出当前命令

#### 断点调试

在代码中加入debugger标签，node执行到debugger自动暂停

`node inspect 文件名`

```js
var a = 'a'
var b = 'b'
debugger
var all = a + ' ' + b
```

命令

1. c  继续执行到下一个断点处
2. next/n 单步执行
3. step/s 单步进入函数
4. out/o 退出当前函数
5. setBreakPoint(10),sb(10) 在第10行设置断点
6. repl 打开repl环境
7. watch(exp) 监视表达式
8. watchers 显示所有表达式的值

#### 单元测试

使用jest库进行单元调试

1. 安装`npm i jest -g`

2. 使用 在当前目录创建\_test\_文件夹 创建index/spec.ts文件

   ```js
   test('HELLOWORLD',()=>{
       require('../index')
   })
   ```

3. 运行 `jest helloworld`

#### node函数

1. require()
   - require属性
     - resolve 获取模块绝对路径又不想真正加载时使用
     - main 入口模块 main: module{}
       - id
       - exports
       - parent
       - filename
       - loaded
       - children
     - extensions 扩展
     - cache 缓存
   - 
2. module
   - id
   - exports
   - parent
   - filename
   - loaded
   - children
3. 


#### node模块化

node基于common.js规范 node天生自带模块化。模块化低耦合高内聚方便维护防止代码冲突

1. 定义模块

   一个js文件就是一个模块

2. 使用模块

   require 使用一个文件就require文件名 具有缓存功能 多次引用只执行一次

3. 导出模块

   exports  /  module.exports

```js
export.Dialog = Dialog
let Dialog = require('./dialog')
/*原理*/
(function(exports,module,require){
    module.exports = exports = this = {}
    return module.exports
})()
```

模块分类

- 原生模块/核心模块

  不需要安装直接使用 编译成二进制加载速度快 通过名称加载

  -  utils 工具模块 提供常用函数的集合
  -  events模块
  -  error模块
  -  http模块 搭建http服务处理用户请求信息
  -  path模块 用于处理文件路径和目录路径
  -  url模块 处理解析url
  -  Buffer模块

- 文件模块 fs模块 文件系统 提供文件的读取写入更名删除遍历等

  在硬盘的中加载非常慢，文件模块通过名称或路径来加载

  - 后缀为js的js脚本文件需要先读入内存再运行
  - 后缀为json的json文件fs先读入内存再运行
  - 后缀为node 经过编译后的二进制c/c++扩展模块文件直接使用

- 第三方模块

  - 若require函数只指定名称视为从node_modules下加载文件
  - 第三方模块查询路径包括module paths和全局目录

> 全局目录 windows环境变量中有NODE_PATH变量，并将变量设置为一个有效的磁盘目录 require在本地找不到此模块时将在此目录下找这个模块

#### 第三方包与npm

1. 第三方模块要通过npm来进行安装(node package mannager)

   - 全局安装 -g 只能在命令行 默认安装路径是npm root -g ，不会自动加入环境变量中，通过npm映射nrm :nvm node registry manager 源管理

     nvm 版本管理

     ```js
     /*http-server模块安装 启动本地服务 只能在命令行中使用*/
     npm i -g http-server
     /*使用*/
     http-server [path] [options]
     ```

   - 本地安装 没有-g 安装之前需要初始化来记录安装依赖

     `npm init -y` 初始化后会生成package.json 来记录安装依赖模块 scripts配置快捷方式

     - 项目依赖 (dependencies)开发时使用上线时也需要
     
       `npm install jquery `
     
     - 开发依赖(devDependencies) 开发时使用上线时不需要
     
       `npm install less --save-dev`
     
     **安装全部依赖** `npm install`

   第三方包引用 `requrie('第三方包名')` 

   yarn安装 `npm i -g yarn`

   ```js
   yarn init
   yarn add 包
   yarn remove 包
   yarn add less --dev
   yarn install
   ```

2. 发布包

   - 发布包只能使用npm源
   - 包名不能和已有的包一致
   - 入口文件必须有 整合文件
   - 注册账号 有账号表示登录 新用户需要校验邮箱 `npm addUser`
   - 发布 `npm publish`


#### encoding

字符发展历史

1. 字节

   - 计算机所有信息都是一个二进制值
   - 每一个二进制(bit)都有0和1两种状态 8个二进制位可以组合256种状态即一个字节(byte)

2. 单位

   - 8bit = 1byte
   - 1024byte = 1k
   - 1014K = 1M
   - 1024M = 1G
   - 1024G = 1T

3. js进制

   - 进制表示

     ```js
     let a = 0b10110 //二进制
     let b = 0o24 //八进制
     let c = 20 //十进制
     let d = 0x14 //十六进制
     ```

   - 进制转换

     - 十进制转任意进制  `c.toString(2)` toString传入进制数字
     - 任意进制转十进制 `paseInt('10100',2)` parseInt(字符串,原始进制)

4. ASCII 

   8位的字节可以组合成256中状态，0-32种状态规定了特殊用途（eg: 0x10换行）空格标题符合数字大小写字母分别用连续的字节状态表示编到127号。

   128个符号只占用一个字节后的7位开头统一为0

   > 美国信息互换标准代码

5. GB2312

   西欧使用127-255保存新字母 不同国家符号不同

   > 128-255的字符集被称为扩展字符串

   中国为表示汉字取消了127后所有字符，扩展ACII码

   - 小于127字符意义与原来相同（半角字符） 大于127的字符相连为一个汉字
   - 第一个字节（高字节）从0xA1到0xF7 第二个字节（低字节）从0xA1到0xFE
   - 组合出7998个简体汉字
   - 数学符号、日文假名。原有数字标点符号都编为两个字节长编码为全角字符

6. GBK

   不要求低字节一定是127后内码 只要第一个字节大于127表示一个汉字开始 增加20000个新汉字符号

7. GB18030/DBCS

   增加几千个新少数民族字 统称双字节字符串（double byte character）

8. Unicode

   ISO（全球标准化组织）写的全球字符编码 规定必须是两个字节 半角字符编码不变由8位扩展为16位

9. UTF-8

   - utf-8是互联网上使用最广的unicode实现方式
   - 每次以8个位为单位传输数据
   - utf-16每次16位
   - utf-8是一种变长的编码方式 一个中文字符占3个字节

10. utf-8编码规则

    - 对于单字节的符号，第一位设为0后7位为符号unicode码

    - 对于n字节的符号第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位位10，剩下二进制位全部为对于unicode码

      ```js
      unicode符号范围（16进制） |  utf-8编码（二进制）
      0000 0000-0000 007F    |   0xxxxxxxx
      0000 0080-0000 07FF    |   110xxxxx 10xxxxxx
      0000 0800-0000 FFFF    |   1110xxxx 10xxxxxx 10xxxxxx
      0001 0000-0010 FFFF    |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      ```

    - utf-8编码实现

      ```js
      function transfer(num){
          //把unicode码转为utf-8
          let ary = ['1110','10','0']
          let binary = num.toString(2)
          ary[2] = ary[2] + binary.slice(binary.length-6)
          ary[1] = ary[1] + binary.slice(binary.length-12,binary.length-6)
          ary[0] = ary[0] + binary.slice(0,binary.length-12).padStart(4,'0')
          let result = ary.join('')
          return paseInt(result,2).toString(16)
      }
      let result = transfer(0x4E07)
      ```

11. **node字符转码**

    node默认支持的几种编码格式为 utf8,base64,binary,不支持GBK

    `require('iconv-lite')`实现编码转换

    iconv-lite：是 iconv  的纯 js 实现，支持的编码包括 node.js 原生编码：utf8, ucs2, ascii, binary,  base64；同时支持广泛使用的单字节编码：Windows 125x family, ISO-8859 family, IBM/DOS  codepages, Macintosh family, KOI8 family, latin1, us-ascii；多字节编码：gbk,  gb2313, Big5, cp950。官方宣称比 node-iconv 更快。

    `iconv.decode('data','gbk')`

    encoding：是对 node-iconv 和 iconv-lite 的再次封装，encoding 首先调用 node-iconv，如果 node-iconv 无法解析，则调用 iconv-lite 作为替代方案。

#### event

event模块用于实现各种事件处理，定义了EventEmitter类，所以可能触发事件的对象都是一个继承自EventEmitter类的子类实例对象

- addListener(event,listener) 绑定事件
- on(event,listener) 绑定事件
- once(event,listener) 绑定只执行一次的事件
- removeListener(event,listener) 解除指定绑定事件
- removeAllListener([event]) 解除所有绑定事件
- setMaxListener(n) 指定事件的最大数量
- listeners(event) 获取指定事件的所有事件处理函数
- emit(event,[arg1],[arg2],...)手动触发指定事件

```js
function EventEmitter(){
    this.events = {} //存储事件监听函数
    this._MaxListeners = 10 //指定给一个事件类型增加的监听函数数量最大值
}
EventEmitter.prototype.setMaxListeners = function(maxListeners){
    this._MaxListeners = maxlisteners
}
EventEmitter.prototype.listeners = function(event){
    return this.events[event]
}
EventEmitter.prototype.on = EventEmitter.prototype.addListener = function(type,listener){
    //参数1事件类型 2事件监听函数
    if(this.events[type]){
        this.events[type].push(listener)
        if(this._MaxListeners != 0 && this.events[type].length >= this._MaxListeners){
            console.error('MaxListenersExceededWarning:')
        }
    }else{
        //事件第一次被添加
        this.event[type] = [listener]
    }
}
EventEmitter.prototype.emit = function(type,...rest){
    //参数1事件类型 2传递给监听函数
    this.events[type] && this.events[type].foreEach(listener => listener().apply(this,rest))
}
EventEmitter.prototype.removeListener = funnction(type,listener){
    if(this.events[type]){
        this.event[type] = this.events[type].filter(l => l!=Listener)
    }
}
EventEmitter.prototype.removeAllListener = funnction(type){
    delete this.events[type]
}
EventEmitter.prototype.once = function(type,listener){
    let wrapper = (...rest) => {
        listener.apply(this,rest)
        this.removeListener(type,wrapper)
    }
    this.on(type,wrapper)
}
```

#### util

node内置工具

- inspect 美化obj
- isArray
- isRegExp
- isDate
- isError
- .inherits(child,parent) 继承

#### buffer

1. buffer概念

   - 缓冲区Buffer是暂时存放输入输出数据的一段内存
   - js没有二进制数据类型，而处理TCP和文件流时必须要处理二进制数据流
   - node使用Buffer对象来操作二进制数据，Buffer为16进制
   - Buffer对象是一个表示内存分配的全局对象（放入buffer的字节数要提前确定）
   - Buffer像多位字节元素组成的数组，可以有效在js中表示二进制数据

2. buffer定义

   - 长度定义 `let buffer = Buffer.alloc('6')`比较耗性能 `let buffer = Buffer.allocUnsafe(6)`
   - 数组定义 自动把10进制转化为16进制 `let buffer = Buffer.from([1,2,3,4])`
   - 字符串创建 `let buffer = Buffer.from('字符串')`
   - buffer.length = buffer长度 不等于字符串长度

3. buffer常用方法

   - buffer.fill() 填充buffer中的内容

   - buffer.slice() 截取buffer

   - buffer.toString() buffer转为字符串

     buffer.toString('base64') buffer数据转为base64

   - buffer.copy() 拷贝buffer 

   - buffer.concat() 拼接buffer

     ```js
     //concat原理
     Buffer.concat = function(list,total=list.reduce((len,item)=>len+item.length,0)){
         if(list.length == 1){
             return list[0]
         }
         let result = Buffer.alloc(total)
         let index = 0
         for(let buf of list){
             for(let b of buf){
                 if(index>=total){
                     return result
                 }else{
                     result[index++] = b
                 }
             }
         }
     }
     ```
   
   - buffer.isBuffer() 判断是否为buffer类型
   
   - buffer.write(string,offset,length,encoding) buffer写入内容
   
   - buffer.writeInt8() 写入8位整数
   
   - buffer.writeInt16BE() 写入16位整数 大头在前
   
   - buffer.writeInt16LE()写入16位整数小头在前
   
   > buffer乱码问题通过string_decoder解决
   >
   > ```js
   > let buf9 = Buffer.from('车市场上')
   > let buf10 = buf9.slice(0,5)
   > let buf11 = buf9.slice(5)
   > let {string_decoder} = require('string_decoder')
   > let sd = new StringDecoder()
   > console.log(sd.write(buf10))
   > console.log(sd.write(buf11))
   > ```

4. base64

   - base64是常见传输8bit字节的编码方式，基于64个可打印字符表示二进制的方法

   - base63要求吧三个8bit字节转换为4个6bit字节然后把6bit添两位高位0组成4个8bit字节。

     ```js
     const CHARTS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
     function transfer(str){
         let buf = Buffer.from(str)
         let result == ''
         for(let b of buf){
             result += b.toString(2)
         }
         return  result.match(/(\d{6})/g).map(val=>CHARTS[val].join(''))
     }
     let r = transfer('测')
     ```

#### fs(fileSystem)

1. fs同步读写

   - 同步读取 `fs.readFileSync('./文件名')`
     - 文件必须存在
     - 不能通过/读取内容 /表示根目录 
     - 读取的默认类型是buffer
     - 第一次的输出是下一次的输入
     
   - 同步写入 

     `fs.writeFileSync(file, data[, options])`

     - 写入默认类型是utf8
     - 文件不存在时会自动创建 ，里面有内容会自动覆盖
     - 写入data默认会调用toString方法

2. fs异步读写

   - 异步读取 `fs.readFile('./1.txt','options',function (err,data) { if(err) return })` 

     options包括

     1. encoding

     2. flags
        - r 读取文件 文件不存在报错
        - r+ 读取并写入 不报错
        - rs 同步读取文件并忽略缓存
        - w 写入文件不存在则创建 存在清空
        - wx排他写入文件
        - w+读取并写入文件 存在创建 不存在清空
        - wx+ 和w+类似 排他方式打开
        - a 追加写入
        - ax 与a类似排他写入
        - a+ 读取并追加写入不存在则创建
        - ax+ 与a+类似 排他方式打开
             > r读取 w写入 s同步 +增加相反操作 x排他 
             >
             > r+w+区别
             >
             > - 文件不存在时r+不会创建 w+相反
             > - 文件存在r+不会清空 w+相反
     3. mode 权限位默认0o666

     - 异步方案会导致回调地狱 不方便维护
   
     - 使用promise读取
   
       ```js
       let read = util.promisify(fs.reaFile)
       read('./1.txt','utf8').then(function(data){cosole.log(data)},function(err){console.log(err)})
       ```
   
     - 链式读取
   
       ```js
       async function result(){
       	let content1 = await read('./1.txt','utf8');
           let content2 = await read(data,'utf8')
       }
       同步读取多个文件
       Promise.all([read('x.txt','utf8'),read('y.txt','utf8')]).then(function(data){}).catch(err=>{})
       ```

   - 异步写入 `fs.writeFile(file, data[, options], callback)`

3. fs的方法

   - `fs.stat(path[, options], callback)` 时间值

     - atime(access time) 访问时间
     - mtime(modify time) 修改时间
     - ctime(change time) 变化时间
     - birthtime 创建时间
  - stat.isFile()
     - stat.isDirectory()
     
     ```js
     fs.stat('./文件'，function(err,stats){
         if(err) {}
         console.log(stats.isFile())
         console.log(stats.isDirectory())
    })
    ```

   - `fs.mkdir(path[, options], callback) `创建文件夹 

     要求父目录必须存在
   
     > 判断一个文件是否有权限访问
     >
     > fs.access(path,[mode],callback)
     >
     > ```js
     > fs.access('./1.txt',fs.constants.R_OK|fs.constants.W_OK,(err) => {
     >     console.log(err?'no access' : 'can read/write')
     > })
     > ```
   
     递归创建目录
   
     ```js
     function makep(url,cb){
         let urlArr = url.split('/')
         let index = 0
         function make(p){
             if(urlArr.length<index) return
             fs.stat(p,function(err){
              if(err){
                     fs.mkdir(p,function(err){
                         make(urlArr.slice(0, ++index+1).join('/'))
                     })
                 }else{
                     make(urlArr.slice(0,++index+1).join('/'))
                 }
             })
         }
         make(urlArr[index])
     }
     let fs = require('fs')
     let path = require('path')
     function mkdirp(dir){
         let paths = dir.split('/')
         !function next(index){
             if(index > path.length) return
             let curret = path.slice(0,index).join('/')
             fs.access(current,fs.constants.R_OK,(err) => {
         		if(err){
                     fs.mkdir(current,0o666,next.bind(null,index+1))
                 }else{
                     next(index+1)
                 }
     		})
         }(1)
     }
     ```
   
   - appendFile()追加文件
   
   - open(filename,flag,mode,callback) callback参数 err fd(file dispcriptor)文件操作符
   
     > 文件操作符 0 标准输入 1 标准输出 2 错误输出
     >
     > ![权限位](C:\Users\ASUS\Desktop\笔记\架构笔记\img\权限位.png)
   
   - read(fd, buffer, offset, length, position, callback) 从指定文件中读取
   
   - write(fd, buffer[, offset[, length[, position]]], callback)
   
   - close(fd,[callback]) 关闭文件
   
   - fsync(fd,[callback]) 同步磁盘缓存 强行把缓存区文件写入并关闭
   
   - unlink(path) 删除一个文件
   
   - rmdir(path)删除一个空目录
   
   - readdir(path,[options],callback) 读取目录下的所有文件
   
   - rename(oldpath,newpath,callback)移动文件或目录
   
   - truncate(filename,length,callback) 截断文件


```js
//节约内存的拷贝
let fs = require('fs')
const BUFFER_SIZE = 3  //缓存大小为三个字节
function copy(src,target){
    fs.open(src,'r',0o666,fucntion(err,readFd){
        fs.open(target,'w',0o666,function(err,writeFd){
        //0o666为可读可写不可执行
        	let buff = Buff.alloc(BUFFER_SIZE)
        	!function next(){
                fs.read(readFd,buff,0,BUFFER_SIZE,null,function(err,bytesRead,buffer){
                    //null为自动确认写入位置
                    if(bytesRead > 0){
                        //调用write方法写入文件时不会直接写入物理文件，先写入缓存区文件再批量写入物理文件
                         fs.write(writeFd,buff,0,bytesRead,null,next)
                    }
                })
            }()
   		})
    })
}
copy('1.txt','2.txt')
```

```js
//删除目录下的所有空目录
function rmdirp(dir){
    let files = fs.readdirSync(dir)
    files.forEach(function(file){
        let current = path.join(dir,item)
        let child = fs.statSync(current)
        if(child.isDirectory()){
            rmdirp(child)
        }else{
            fs.unlinkSync(current)
        }
    })
    //目录下所有文件删除后删除自己
    fs.rmdirSync(dir)
}
//异步递归删除非空文件夹
function rmdir(dir){
    return new Promise(function(resolve,reject){
        fs.stat(dir,(err,stat)=>{
            if(stat.isDirectory()){
                fs.readdir(dir,(err,files)=>{
                    if(err) rerurn reject(err)
            		//先删除当前目录的子文件夹或文件再删除自己
        			Promise.all(files.map(item => rmdir(item))).then(()=>{
                		fs.rmdir(dir,resolve)
            		})
       			 })
            }else{
                fs.unlink(dir,resolve)
            }
        })
    })
}
```

4. **遍历算法**

   目录为树状结构(二叉树)，遍历时一般使用深度优先+先序遍历算法，到达一个节点后先遍历子节点而不是邻居节点，先序遍历意味着首次到达了节点就算遍历完成，而不是最后一次返回某节点才算数。

   ```
           A
          / \
         B   C
        / \   \
       D   E   F
       
   遍历顺序 a->b->d->e->c->f
   ABC为先序
   BAC为中序
   BCA为后序
   先遍历兄弟节点为广度优先
   先遍历子节点为深度优先
   ```

   同步深度优先+先序遍历

   ```js
   function deepSync(dir){
       cosole.log(dir)
       fs.readdirSync(dir).forEach(file=>{
           let child = path.join(dir.file)
           let stat = fs.statSync(child)
           if(stat.isDirectory()){
               deepStnc(child)
           }else{
               console.log(child)
           }
       })
   }
   ```

   异步深度优先+先序算法

   ```js
   fucntion preDeep(dir,callback){
       console.log(dir)
       fs.readdir(dir,(err,files)=>{
           !function next(i){
               if(i>=files.length) return callback()
               let child = path.join(dir,files[i])
               fs.stat(child,(err,stat)=>{
                   if(stat.isDirectory()){
                       preDeep(child,()=>next(i+1))
                   }else{
                       console.log(child)
                       next(i+1)
                   }
               })
           }(0)
       })
   }
   ```

   同步广度优先先序遍历

   ```js
   function widde(dir){
       let arr = [dir]
       while(arr.length > 0){
           let current = arr.shift() //取出队列最左边的元素
           console.log(current)
           let stat = fs.statSync(current)
           if(stat.isDirectory()){
               let files = fs.readdirSync(current) //获取所有子元素
               files.forEach(item => {
               	arr.push(path.join(current,item))
           	})
           }
       }
   }
   ```

5. 监视文件或目录

   `fs.watchFile(filename[,option],listener)`

   ```js
   let fs = require('fs')
   fs.watchFile('1.txt',(curr,prev)=>{
       if(Date.parse(prev.ctime)==0){
           console.log('创建')
       }else if(Date.parse(curr.ctime)==0){
           console.log('删除')
       }else if(Date.parse(prev.ctime) != Date.parse(curr.time)){
           console.log('修改')
       }
   })
   ```

#### path

处理文件和目录的路径

- `path.join([...paths])`  拼接路径 ，长度为零的 `path` 片段会被忽略。 如果连接后的路径字符串为长度为零的字符串，则返回 `'.'`，表示当前工作目录
- `path.resolve([...paths]) `  解析为绝对路径
- `path.delimiter` 提供平台特定的路径定界符：
- `path.sep` 提供平台特定的路径片段分隔符/
- `path.basename(filename)`获取文件名
- `path.extname(filename)`获取文件扩展名

#### stream

用于处理流式数据

流是一组有序的有起点终点字节数据传输手段，不关心文件内容只关注是否从文件中读取到了数据以及读到数据之后的处理

1. 流类型

- 可读流 `fs.createReadStream(path,[options])`

  options参数包括

  - flags打开文件要做的操作 默认为r
  - encoding默认为null
  - start开始读的索引
  - end结束读的索引(包括索引在内)
  - highWaterMark读取缓存区的默认大小64k

  1. 监听data `rs.on('data',callback)`
  2. 监听end `rs.on('end',callback)`
  3. 监听error `rs.on('err',callback)`
  4. 监听open`rs.on('open',calback)`
  5. 监听close`rs.on('close',callback)`
  6. 设置编码 `rs.setEncoding()`
  7. 暂停恢复触发data `pause()暂停` `resume()恢复`

- 可写流 `fs.createWriteStream`

  1. write() 返回值为布尔值 系统缓存区未满时为true满时为false
  2. end()
  3. drain() 当一个流不处在drain的状态 对write调用会缓存数据模块并返回false，一旦当前缓存数据块清空 drain就会被触发
  4. finish() 调用end后缓存区数据以及都传给底层系统时finish会被触发

- Duplex既可读又可写的流 `net.socket`

- Transform 读写时可修改转换的 `Duplex` 流  `zlib.createDeflate()`

```js
//可读流相关事件 异步
let rs = fs.createReadStream('文件名',{highWaterMark:1})
//highWaterMark每次能读多少默认64k一般不需要更改 读取时默认buffer类型
//需要监听事件数据到来的事件 rs.emit('data',数据)
//默认为非流动模式 监听后为流动模式
let arr = []
rs.on('data',function(chunk){
    //默认data事件不停地触发 直到数据被读取完毕
    arr.push(chunk)
    rs.pause() //暂停on(data)的触发
    console.log(chunk)
})
setTimeOut(function(){
    rs.resume() //恢复on(data)的触发
},1000)
rs.on('end',function(){
    console.log(Buffer.concat(arr).toString())
})
rs.on('err',function(err){
    //文件不存在 错误时
})
```

```js
//可写流 异步
var fs = require('fs')
var ws = fs.createWriteStream('文件名')
//默认写数据占用16384 = 16k内存
ws.write(1) //可写流写数据必须是字符串类型或者buffer类型
ws.end() //不能在end后再write end调用后会把所有write中内容以最快速度写入文件
ws.on('drain',function(){
    //当读入的文件全部写入后就恢复读取
})
```

```js
//可写流实现
//使用
let ws = fs.createWriteStream('1.txt'{flags:'w',mode:0x666,start:0,encoding:'utf8',autoClose:true})
let n = 9
function write(){
    let flag
    while(flag && n>0){
        flag = ws.write(n + '')
        n--
    }
    ws.once('drain',write)
}
write()

//原理
let fs = require('fs')
let EventEmitter = require('event')
class WriteStream extends EventEmitter{
    constructor(path,options){
        super(path,options)
        this.flags = options.flags || 'w'
        this.mode = options.mode || 0x666
        this.start = options.start || 0
        this.pos = this.start //文件写入索引
        this.encoding = options.encoding || 'utf8'
        this.autoClose = options.autoClose
        this.highWaterMark = options.highWaterMark || 16*1024
        
        this.buffers = [] //缓存区
        this.writing = false //表示内部正在写入数据
        this.length = 0 //缓存区字节的长度
        this.open()
    }
    open(){
        fs.open(this.path,this.flags,,this.mode,(err,fd) => {
            if(err){
                if(this.autoClose){
                    this.destory()
                }
                this.emit('error',err)
            }
            this.fd = fd
            this.emit('open')
        })
    }
    write(chunk,encoding,cb){
        //底层已经在写入数据时 必须将当前写入数据放入缓存区
        chunk = Buffer.isBuffer(chunk)?chunk:Buffer.from(chunk,this.encoding)
        let len = chunk.length
        this.length += len
        //判断当前缓存区是否小于最大阈值
        let ret = this.length < this.highWaterMark
        if(this.writing){
            this.buffers.push({chunk,encoding,cb})
        }else{
            //直接写入 底层写完当前数据后要清空缓存区
            this.writing = true
            this._write(chunk,encoding,()=>this.clearBuffer())
        }
        return ret
    }
    _write(chunk,encoding,cb){
        if(typeof this.fd != 'number'){
            return this.once('open',()=>this._write(chunk,encoding,cb))
        }
        fs.write(this.fs,chunk,0,chunk.length,this.pos,(err,bytesWritten)=>{
            if(err){
                if(this.autoClose){
                    this.destory()
                    this.emit('error',err)
                }
            }
            //写入多少字节缓存区减少对应字节
            this.length -= bytesWritten
            this.pos += bytesWritten
            cb && cb()
        })
    }
    clearBuffer(){
        //取出缓存区的第一个buffer
        let data = this.buffers.shift()
        if(data){
            this._write(data.chunk,data.encoding,()=>clearBuffer())
        }else{
            //缓存区清空
            this.emit('drain')
            this.writing = false
        }
    }
    destory(){
        fs.close(this.fd,()=>{
            this.emit('close')
        })
    }
}
```

```js
//可读流实现
//1.流动模式 不走缓存
let fs = require('fs')
let rs = fs.createReadStream('./1txt',{flags:'r',mode:0x666,start:3,end:8,autoClose:true,encoding:'utf8',highWaterMark:3})
rs.on('open',()=>{
      console.log('open')
})
rs.on('data',data=>{
    console.log(data)
})
rs.on('end',()=>{
    console.log('end')
})
rs.on('close',()=>{
    console.log('close')
})
rs.on('error',err=>{
    console.log(err)
})
//实现
let fs = require('fs')
let EventEmitter = require('event')
class ReadStream extends EventEmitter{
    constuctor(path,options){
        super(path,options)
        this.path = path
        this.flags = options.flags || 'r'
        this.mode = options.mode || 0o666
        this.highWaterMark = options.highWaterMark || 64*1024
        this.start = options.start || 0
        this.end = options.end
        this.pos = this.start
        this.encoding = options.encoding
        this.flowing = null
        this.buffer = Buffer.alloc(this.highWaterMark)
        this.open()
        //当给这个实例添加了任意的监听函数时会触发newListener
        this.on('newListener',(type,listener)=>{
            if(type == 'data'){
                this.flowing = true
                this.read()
            }
        })
    }
    read(){
        if(typeof this.fd != 'number'){
            return this.once('open',()=>this.read())
        }
        let howMuchToRead = this.end > Math.min(this.end-this.pos + 1,this.highWaterMark)
        //this.buffer不是缓存区
        fs.read(this.fd,this.buffer,0,howMuchToRead,this.pos,(err,bytes) => {//bytes是实际读到的字节数
            if(err){
                if(this.autoClose)
                    this.destory()
                return this.emit('error',err)
            }
            if(bytes){
                let data = this.buffer.slice(0,bytes)
                this.pos += bytes
                data = this.encoding ? data.toString(this.encoding) : data
                this.emit('data',data)
                if(this.end && this.pos > this.end){
                    return this.emit('end')
                }else{
                    if(this.flowing){
                       this.read()
                    }
                }
            }else{
                return this.emit('end')
            }
        })
    }
    open(){
        fs.open(this.path,this.flags,this.mode,(err,fs)=>{
            if(err){
                if(this.autoClose){
                    this.destory()
                    return this.emit('error',err)
                }
            }
            this.fs = fd
            this.emit('open')
        })
    }
    destory(){
        fs.close(this.fd,()=>{
            this.emit('close')
        })
    }
}



//暂停模式
rs.on('readable',function(){
    console.log(rs.length)
    //使用一个字节后缓存区变2字节
    let char = rs.read(1)
    console.log(char)
    console.log(rs._readableState.length)
    //一旦发现缓存区的字节数小于最高水平会再读取到最高水平线字节填充到缓存区中
    setTimeouut(()=>{
        console.log(rs._readableState.length)
    },500)
})
let fs = require('fs')
let EventEmitter = require('event')
class ReadStream extends EventEmitter{
    constuctor(path,options){
        super(path,options)
        this.path = path
        this.flags = options.flags || 'r'
        this.mode = options.mode || 0o666
        this.highWaterMark = options.highWaterMark || 64*1024
        this.start = options.start || 0
        this.end = options.end
        this.pos = this.start
        this.encoding = options.encoding
        this.flowing = null
        //临时数组
        this.buffer = Buffer.alloc(this.highWaterMark)
        //缓存区
        this.buffers = []
        let length = 0
        this.open()
        //当给这个实例添加了任意的监听函数时会触发newListener
        this.on('newListener',(type,listener)=>{})
        
    }
    open(){
        fs.open(this.path,this.flags,this.mode,(err,fs)=>{
            if(err){
                if(this.autoClose){
                    this.destory()
                    return this.emit('error',err)
                }
            }
            this.fs = fd
            this.emit('open')
            this.read()
        })
    }
    read(n){
        //缓存区数据够用且要读取数据字节大于0
        if(0<n<this.length){
            let ret = Buffer,alloc(n)
            let index = 0
            let b
            while(null != (b = this.buffers.shift())){
                for(let i = 0; i<b.length;i++){
                    ret[index++] = b[i]
                    if(index == n){
                        //填充完毕
                        b = b.slice(i)
                        this.buffers.unshift(b)
                        this.length -= n
                        break
                    }
                }
            }
        }
        if(this.length<this.highWaterMark){
            fs.read(this.fd,this.buffer,0,this.highWaterMark,null,(err,bytesRead)=>{
            if(bytesRead){
                let b = this.buffer.slice(0,bytesRead)
                this.buffers.push(b)
                //缓存区数量加读到的字节数
                this.length += bytesRead
                this.emit('readable')
            }else{
                this.emit('end')
            }
        })
        }
        return ret && this.encoding?ret.toString(this.encoding):ret
        
}
```

**rs.pipe(ws)**边读边写

```js
//pipe原理
let fs = require('fs')
let ws = fs.createWriteStream('1.txt')
let rs = fs.createReadStream('2.txt')
rs.on('data',function(data){
    let flag = ws.write(data)
    if(!flag)
        rs.pause()
})
rs.on('drain',function(){
   rs.resume()
})
rs.on('end',function(){
   ws.end()
})
pause(){
    //可读流进入暂停模式
    this.flowing = false
}
resume(){
    this.flowing = true
    this.read()
}
//pipe用法
readStream.pipe(writeStream)
let from = fs.createReadStream('1.txt')
let to = fs.createWriteStream('2..txt')
from.pipe(to)
```

unpipe

- readable.unpipe()将之前通过stream.pipe()方法绑定的流分离
- 如果destination没有传入则所有绑定的流都会被分离

2. 流数据模式

   - 二进制模式 每个分块都是buffer或者string对象
   - 对象模式 流内部处理的是一系列普通对象

   > 所有使用nodeAPI创建的流对象都只能操作string和buffer的对象

3. 可读流的两种模式

   - flowing 可读流自动从系统底层读取数据，并通过eventemitter接口的事件尽快将数据提供给应用
   - paused 必须显式调用stream.read方法来从流中读取数据片段

   流模式切换

   - pause模式的readable流切换为flowing
     - 监听data事件
     - 调用stream.resume()方法
     - 调用stream.pipe()方法将数据发送到writable
   - 可读流切换paused
     - 不存在管道目标（pipe destination）可以调用stream.pause()
     - 存在管道目标通过取消'data'事件监听并调用stream.unpipe()

流应用

- 行读取器

  换行回车

  unix系统每行结尾只有换行(\n)，windows系统里每行结尾是'<回车><换行>'(\r\n)，mac系统每行结尾都是回车(\r)

  ACII码中换行为\n 10 0A回车\r 13 0D

  ```js
  //传入文件路径得到类的实例 监听newLine事件行读取器每读到一行向外发射newLine事件读到结束时发射end事件
  let fs = require('fs')
  let util = require('util')
  let EventEmitter = require('event')
  const NEW_LINE = 0x0A //\n
  const RETURN = Ox0D //\r
  function LineReader(path,encoding){
      EventEmitter.call(this)
      this.encoding = encoding || 'utf-8'
      this._reader = fs.createReadStream(path)
      //给对象添加一个新的监听函数会触发newListener事件
      this.on('newListener',(type,listener)=>{
          //添加newline和监听后开始读取文件内容并按行发射数据
          if(type == 'newLine'){
              //监听一个可读流的readable事情流会调用底层的读取文件api填充缓存区填充完后向外发射readable事件
              let buff = []
              this._reader.on('readable',()=>{
                  let char //buffer 只有一个字节
                  while(null != (char = this._reader.read(1))){
                      switch(char[0]){
                          case NEW_LINE:
                              this.emit('newLine',Buffer.from(buff).toString(this.encoding))
                              buff.length = 0
                              break;
                          case RETURN:
                              //再读一个字节
                              this.emit('newLine',Buffer.from(buff).toString(this.encoding))
                              let nChar = this._reader.read(1)
                              if(nChar[0] != NEW_LINE){
                                  buff.push(nChar[0])
                              }
                              break;
                          default：
                          	buff.push(char[0])
                          	break;
                      }
              })
              this._reader.on('end',()=>{
                 //发射最后一行数据
                  this.emit('newLine',Buffer.from(buff).toString(this.encoding))
                  this.emit('end')
              })
          }
      })
  }
  util.inherits(LineReader,EventEmitter)
  //调用
  let reader = new LineReader('1.txt')
  reader.on('newLine',data => {
      console.log(data)
  })
  reader.on('end',data => {
      console.log(data)
  })
  ```

- 自定义可读流

  引用Readable接口并构造新对象

  - 直接把供使用的数据push出去
  - 当push一个null对象就意味着这个流没有更多数据了

  ```js
  let stream = require('stream')
  let util = require('util')
  util.inherits(Counter,stream.Readable)
  function Counter(options){
      stream.Readable.call(this,options)
      this._index = 0
  }
  Counter.prototype._read = function(){
      if(this._index++<3){
          this.push(this._index +'')
      }else{
          this.push(null)
      }
  }
  let counter = new Counter()
  counter.on('data',function(data){
      console.log('读到数据'+data.toString())
  })
  counter.on('end',function(data){
      conslole.log('end')
  })
  ```

2. 缓存区

   wrirable和readable流都会将数据存储到内部的缓冲器(buffer)中

3. 可读流的三种状态

4. readable

5. 暂停模式实现

#### TCP

1. 协议

   - 计算机的通信规则就是协议
   - 规则有多种协议也有多种
   - 协议就是数据封装格式+传输

2. OSI七层模型

   Open System Interconnection适用于所有网络

   - 将复杂流程分解为几个功能单一的子进程
   - 流程更清晰复杂问题简单化
   - 更容易发现问题并针对性的解决问题
     - 应用层(Application)提供网络与用户应用软件之间的接口服务
     - 表示层(Presentation)提供格式化的表示和转换数据服务比如加密压缩
     - 会话层(Session)提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制
     - 传输层(Transimission)提供建立维护和取消传输连接功能赋值可靠地址传输数据
     - 网络层(newwork)处理网路路由确保数据及时传送服务器
     - 数据链路层(DataLink)负责无错传输数据确认帧发错重传等
     - 物理层(Physics)提供机械电气功能和过程特性（网卡网线双绞线同轴电缆中继器）

3. TCP/IP模型

   - TCP/IP是传输控制协议网路互联协议的简称
   - 早期是四层结构，网络接口层 互联网层 传输层 应用层
   - 后期借鉴OSI模型将网路接口层分为物理层和数据链路层

   

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\tcp模型.png)

   常用协议

   - TCP/IP协议被称为传输控制协议、互联网协议、网络通讯协议
   - 物理层和数据链路层没有特定协议支持所有的标准和专用协议
   - 网络层定义了网络互联/IP协议
     - 网络协议IP负责主机和网络之间寻址和路由数据包
     - 地址解析协议ARP获得同一物理网络中硬件主机MAC地址
     - 反向地址转换协议允许局域网的物理机器从网关服务器的arp表或缓存上请求其IP地址
     - 网络控制消息协议ICMP发送消息报告有关数据包的错误信息
     - 互联网管理协议IGMP ip主机向本地多路广播路由器报告主机组成员
   - 传输层定义TCP（传输控制协议）和UDP（用户数据报）协议
   - 应用层定义HTTP（超文本传输协议）FTP（文件传输协议）DNS（域名系统）

   1. 网络接口层

      - 物理层 关系什么信号表示01 是否可以双向通信 连接建立终止
        - 为数据提供传送数据点多通路
        - 传输数据 激活物理连接在连接设备间形成通路、传输数据关心如何打包数据和控制传输速度 关闭物理连接
      - 数据链路层 
        - 将数据整合成数据帧
        - 数据链路建立维护拆除
        - 帧包装传输同步
        - 帧差错恢复
        - 流量控制
      - MAC地址
        - 用内置网卡地址标记计算机身份
        - MAC地址由48位二进制组成 分为6段 用16进制表示

   2. 网络层

      - 选址 交换机靠MAC地址寻址（MAC地址无层次）靠IP地址确认计算机位置即选址

      - 路由 在多条通路中选最短的一条路径工作

      - IP 每个计算机的唯一地址为IP地址

        - IP头部

          ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ip头部.png)

          ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ip头部2.png)

          ip头部服务类型

          ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ip头部3.png)

        - IP格式

          IP 地址为 32 位地址，被分为 4 个 8 位段

          ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ip格式.png)

        - IP组成

          - 网路地址 识别设备所在网路，网络 ID 的位数直接决定了可以分配的网络数量
          - 主机地址 识别该网路中的主机，主机 ID 的位数则决定了网络中最大的主机数量

        - IP表示

          ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ip地址.png)

        - IP分类

          - IP地址网络部分有Internet地址分配机构统一分配保证地址唯一性
          - 全为1的ip（255.255.255.255）为限制广播地址
          - 全为0的ip(0,0,0,0)表示启动时的ip地址 尚未分为时的ip地址
          - 127是用来本机测试的 除127.255.255.255外其他127开头地址都代表本机

          ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ip分类.png)

        - 公有地址/私有地址

          私有IP 非注册地址专门组织机构内部使用

          - A类 10.0.0.0--10.255.255.255
          - B类 172.16.0.0--172.31.255.255
          - C类 192.168.0.0--192.168.255.255

          其他范围内IP都为公有IP

        - 子网掩码

          子网掩码(subnet mask)用来只买一个ip地址的哪些标识是主机所在子网以及掩码。不能单独存在，必须结合IP地址一起使用，作用就是将ip地址划分成网络地址主机地址两部分

          - 子网掩码也是32个二进制位
          - 对应IP网络部分用1表示，主机部分用0表示
          - IP地址和子网掩码做逻辑运算得到网络地址，网络地址相同为在一片网络内
            - 0与任何数相与都是0
            - 1和任何数相与都是任何数本身
          - ABC三类地址都有自己默认的子网掩码
            - A类 255.0.0.0
            - B类 255.255.0.0
            - C类 255.255.255.0

   3. 传输层

      - 面向连接的可靠的进程到进程通信协议
      - TCP提供全双工服务即数据可在同一时间双向传播
      - TCP将若干个字节构成一个分组，此分组称为报文段

      传输层的功能：提供一种端对端的连接，只传送数据对是否成功不关心。

      协议的分类

      - TCP (transimision control protocal) 传输控制协议，可靠的面向连接的协议，传输效率低
      - UDP(user datagram protocal) 用户数据报协议，不可靠的无连接的服务，传输效率高

      TCP的功能

      - 将数据进行分段打包
      - 对每个数据报编号控制顺序
      - 运输中丢失重发和废弃处理
      - 流量控制避免拥堵

      TCP数据封装

      ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\tcp数据包.png)

      - 源端口号和目标端口号，计算机通过端口号识别访问哪个服务，比如http服务或ftp服务，发送端口号是随机端口 目标端口号决定了接收方哪个程序来
      - 32位序列号是TCP用序列号对数据包进行标记，以便达到目的后重新封装。0-2^32 -1范围内 数据段标记用于目的端对到达包的重组 。当前序列号为s发送数据长度为1，则下次发送数据的序列号为s+1。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。
      - 32位确认号，在0-2^32-1范围内，对发送端的确认信息，告诉发送端这个序列号之前的数据收到了
      - 16位校验和 控制TCP的连接传输开发断开
        - PSH（急迫位）缓存区将满立即传输速度
        - RST（重置位）连接断了重新连接
        - URG（紧急位）紧急信号
        - ACK（确认）为1表示确认号
        - SYN（建立联机）同步序号位 TCP建立连接时要将这个值设为1
        - FIN发送端完成位 提冲断开连接的一方把FN置为1表示要断开连接
      - 紧急指针 尽在URG控制位为1时有效 表示紧急数据的末尾在TCP诗句部分中的位置，通常由暂时中断通信时使用
      - 窗口值 说明本地可接收数据段的数目这个值的大小是可变的，当前网络畅通时这个窗口值变大加大传输速度，不稳时减少传输速度来保证网络数据的可靠传输。
      - 窗口大小用于表示从应答号开始能够接收多少个8位字节。

      握手和断开

      - TCP是面向连接的协议，在源点和终点之间建立虚拟连接而不是物理连接
      - 在数据通信前，发送端与接收端要先建立连接等数据发送结束后双方再算开连接
      - TCP连接的每一方都是由一个IP地址和一个端口组成

      **三次握手**

      - 第一次 主机a通过一个标识为SYN标识位的数据段发送给主机b请求连接，通过数据告诉主机b希望建立连接，需要b应答，并告诉主机b传输是起始序列号
      - 第二次 主机b用一个确认应答ACK和同步序列号SYNC标识位的数据来响应主机a 一是发送ACK告诉a收到了数据段二是通知主机a从那个序列号做标记
      - 第三次 主机a确认收到了主机b的数据段并可以开始传输实际数据

      **四次挥手**

      - 主机a发送FIN控制位发出断开连接的请求
      - 主机b进行响应确认收到断开并连接请求
      - 主机b提出反方向的关闭要求
      - 主机a确认收到的主机b的关闭连接请求

      UDP

      UDP是一个无连接不可保证可靠性的传输层协议，首部结构简单在数据传输时能实现最小的开销

      UDP的封装格式

      ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\udp格式.png)

      UDP应用 qq、视频软件

      **DNS服务器**

      - 域名

        ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\域名.png)

      - DNS（domain name service）是进行域名和对应IP地址转换的服务器

        - 客户端向本地域名服务器发出（www.baidu.com）请求ip地址
        - 本地DNS服务器向DNS根服务器发请求，根DNS服务器告诉本地服务器(.com)的服务器地址
        - 本地DNS服务器向(baidu.com)发请求，会得到(www.baidu.com)的IP地址1.1.1.1
        - 本地DNS服务器向客服端回复域名对应ip是1.1.1.1

   4. 应用层

      - 协议

        ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\应用层.png)

      - 常见协议

        - HTTP超文件传输协议
        - FTP文件传输协议
        - SMTP协议

   5. 案例

      ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\发送方1.png)

      ![发送方2](C:\Users\ASUS\Desktop\笔记\架构笔记\img\发送方2.png)

      ![接收方1](C:\Users\ASUS\Desktop\笔记\架构笔记\img\接收方1.png)

      ![接收方2](C:\Users\ASUS\Desktop\笔记\架构笔记\img\接收方2.png)

####net

 net模块用来实现TCP服务器和客户端的通信

使用putty连接服务器

1. tcp服务器

   - 创建 `net.createServer([options],[connectionListener])`
     - options.allowHalfOpen是否允许单方面连接默认false
     - connetcionListener用于指定当客户端与服务器建立连接时要调用的回调函数，函数有一个参数socket指tcp服务器监听的socket端口对象
     - 也可以通过监听connection来监听函数 `server,on('connection',function(socket){})`
   - 启动 `server.listen(port,[host],[backlog],[callback])`
     - port必须指定端口号
   - 使用
   - address
   - getconnections
   - close

2. socket

   socket是一个可读可写双工流

   - address
   - 读取数据
   - 监听关闭事件
   - pipe
   - unpipe
   - pause&resume
   - setTimeout

3. tcp客户端

   - 客户端  `socket = new net.socket()`
   - 写入数据
   - close
   - unref&ref
     - unref() 调用后当所有客户端关闭跟服务器的连接后将关闭服务器
   - bufferSize
   - keepAlive

   ```js
   //tcpserver
   let net = require('net')
   //创建一个服务器 监听客户端连接当客户端连接后执行监听函数
   let server = net.createServer({},function(socket){
       console.log('客户端已经连接')
       //表示客户端连接总数
       server.maxConnections = 2
       //获取当前有多少个客户端正在连接服务器
       server.getConnections((err,count)=>{
           console.log(`已经连接${count}个`)
       })
       cosole.log(socket.address())
       //指定编码
       socket.setEncoding('utf8')
       //获取可读流的数据
       socket.on('data',function(data){
           //data为buffer
           cosole.log('接到客户端发来的数据%s %s',data,1)
           socket.write('服务器确认'+data)
       })
       socket.on('error',function(err){
           console.log(err)
       })
       //客户端没有真正关闭 只是开始关闭
       socket.on('end',function(){
           console.log('end')
           //
       })
       setTimeOut(function(){
           //close()调用后此客户端不在接受新的连接但是也不会关闭现有服务器
           server.close()
       },500)
       //客户端真正关闭
       socket.on('close',funcion(hasError){
           console.log('关闭')    
       })
   })
   server.listen(8080,function(){
       cosole.log(server.address())
       cosole.log('服务器已经启动')
   })
   ```

   ```js
   //简易聊天室 可以设置昵称可以广播
   const net = require('net')
   let clients = {}
   let server = net.creatServer(function(socket){
       server.setEncoding('utf8')
       server.getConnetions((err,count)=>{
           socket.write('欢迎光临聊天室，在线人数：'+ count + '人，请输入昵称\r\n')
       })
       let username
       //监听客户端事件
       socket.on('data',function(data){
           data.replace(/\r\n/,'')
           if(username){
               broadcast(username,`${username}:${data}`)  //向所有客户端发送消息
           }else{
               if(client[username]){
                   socket.write('用户名被占用请更换\r\n')
               }else{
                   username = data
              	    //缓存用户的socket
               	clients[username] = socket
                   broadcast(username,`欢迎${username}加入聊天室`)  //向所有客户端发送消息
               }
           }
       })
       socket.on('end',function(){
            broadcast(username,`${username}离开聊天室`)  		 //向所有客户端发送消息
           client[username].destroy() //销毁此socket
           delete clients[username]
       })
   })
   function broadcast(username,msg){
       for(let name in clients){
           if(name != username){
               clients[name].write(msg+'\r\n')
           }
       }
   }
   server.listen(8080,()=>{
       console.log('TCP聊天室已经启动成功信息是',server.address())
   })
   ```
   
   ```js
   //广播b:内容 用户想向所有用户广播
   //私聊c:对方用户名:内容
   //列出在线用户列表 l:列表
   //修改昵称 n:新名字 表示客户端想修改自己名字
   const net = require('net')
   let clients = {}
   let server = net.creatServer(function(socket){
       //服务器地址+端口号来标识客户端
       let key = socket.remoteAddress+socket.remotePort
       clients[key] = {
           nickname:'匿名'，
           socket
       }
       server.setEncoding('utf8')
       //监听客户端事件
       socket.on('data',function(data){
           data.replace(/\r\n/,'')
           let type = data.slice(0,1)
           switch(type){
               case 'b':
                   let text = data.slice(2)
                   boardcast(text)
                   break
               case 'c':
                   let values = data.split(':')
                   let toUser = values[1]
                   let text = values[2]
                   sendTo(toUser,text)
                   break
               case 'l':
                   list()
                   break
               case 'n':
                   let newName = data.slice(2)
                   let oldUserObj = clients[key]
                   oldUserObj.nickname = newName
                   socket.write(`用户名已经修改为：${newName}\r\n`)
                   break
               default:
                   socket.write('此命令不能识别\r\n')
                   break
           }
           function list(){
               let result = '在线用户列表：\r\n'
               for(let user in clients){
                   result += client[user].nickname + '\r\n'
               }
               socket.write(result)
           }
           function sendTo(user,text){
               let toUerObj
               for(let user in clients){
                   if(toUserObj.nickname == toUser){
                       toUserObj = clients[user]
                       break
                   }
               }
               if(toUserObj){
                   let {nickname} = clients[key]
                   toUserObj.socket.write(`${nickname}:${text}\r\n`)
               }else{
                   socket.write('用户名不正确或已经下线')
               }
           }
           function broadcast(username,msg){
               let {nickname} = clients[key]
      			 for(let user in clients){
          		 	if(clients.hasOwnProperty(user)){
               		clients[user].socket.write(`${nickname}:${text}\r\n`)
          		 	}
      			 }
   		}
       })
       socket.on('end',function(){
           socket.destroy() //销毁此socket
           delete clients[key]
       })
   })
   server.listen(8080,()=>{
       console.log('TCP聊天室已经启动成功信息是',server.address())
   })
   ```

#### dgram

提供UDP的socket实现,不区分客户端服务端

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\udp.png)

```js
let dgram = require('dgram')
let socket = dgram.createSocket('udp4')
//在本机的41242端口监听消息
socket.bind(41234,'localhost')
socket.on('message',function(msg,rinfo){
   //回复消息
    socket.send(Buffer.from(msg),0,msg.length,rinfo.port,rinfo.address)
})

//向对方发送消息
let buf = Buffer.from('测试')
socket.send(buf,0,6,41234,'localhost',function(){
    console.log(arguments)
})
socket.on('message',function(msg,rinfo){
    cosnole.log(msg.toString())
})
```

#### http

1. http协议和tcp协议

2. URI和URL

   - URI 统一资源标识符 资源独一无二的符号
     - Uniform 不能根据上下文来识别资源指定的访问方式
     - Resouce 可以标识的任何东西
     - Identifier可以标识的对象
   - URL 统一资源定位符 表示资源的地点
     - Location 定位

   **URL格式**

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\url.png)

3. HTTP

   http是一种不保存状态的协议，请求方叫客户端响应方叫服务器端，通过请求和响应达成通信

   - 请求报文

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\请求报文.png)

     请求方法

     - GET 获取资源
     - POST 发送数据
     - PUT传输文件
     - DELETE删除文件
     - OPTIONS询问支持的方法
     - TRACE追踪路径

   - 响应报文

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\响应报文.png)

     状态码

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\状态码.png)

4. web服务器

   - 虚拟主机 在一台http服务器上搭建多个web站点，客户端发送请求必须在host首部完整指定主机名或域名的url

   - 通信转发程序：代理、网关

     - 代理：客户端和服务器的中间人

       使用代理可以利用缓存减少网络流量、获取访问日志、组织内部针对网站进行访问控制

       分为1.缓存代理 预先把资源副本保存在服务器上2.透明代理 不对报文进行任何加工

     - 网关：接受客户发送来的数据时会转发给其他服务器处理再由自己返回

       使用网关可以提高通信安全性、使通信线路上的服务器提供非HTTP协议服务

5. 首部

   - 通用首部字段

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\首部字段.png)

   - 请求首部字段

   - 响应首部字段

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\响应首部字段.png)

   - 实体首部字段

6. HTTP服务器

   - 创建http服务器 继承至net tcp服务器

      `let server = http.creareServer([requestListener]);server.on('request,requestListener')`

     requestListener 当服务器接收到客户端的连接后执行的处理

     - http.IncomingMessage请求对象
     - http.ServerResponse 服务器端响应对象

   - 启动

     `server.listen(port,[host]),[backlog],[callback];server.on('listening',callback)`

     backlog指定位于等待队列中的客户端连接数

   - 关闭

   - 监听

```js
读取静态html
let http = require('http')
let port = 3000 //端口号尽量使用3000以上端口
let fs = require('fs')
http.createServer((req,res)=>{
    //监听函数 请求到来时执行回调函数
    //req代表客户端 可读流 res代表服务端 可写流
    res.setHeader('Content-Type','text/plain;charset=utf8')
    fs.createReadStream('index.html').pipe(res)
    /*fs.readFile('index.html',function(err,data){
        res.end(data)
    })*/
}).listen(port,()=>{
    console.log(`服务器已经启动在${port}上`)
}) 
```



实现静态服务

```js
let fs = require('fs')
let url = require('url')
let mime = require('mime')
http.createServer((req,res)=>{
    let {pathname,query} = url.parse(req.url,true)
    fs.stat('.'+pathname,function(err.stats){
        if(err){
            res.statusCode = 404
            res.end(`${pathname} not found`)
        }else if(stats.isFile()){ //如果是文件
            res.setHeader('Content-Type',mime.getType(pathname),';charset=utf8') fs.createReadStream('.'+pathname).pipe(res)
        }else if(stats.isDirectory()){//如果是文件夹
            // ./也是文件夹
             res.setHeader('Content-Type','text/plain;charset=utf8')
            let p = path.join('.' + pathname,'./index.html')
            fs.createReadStream(p).pipe(res)
        }
    })
})
```

```js
//parser方法解析请求对象
/** 请求头模板
POST / http /1.1
Host:localhost:8080
User-Agent:curl/7.53.0
Accept: *\/*
Countent-length:15
Content-Type: application/x-www-form-urlencoded

name=test&age=9
*/
let fs = require('fs')
let path = require('path')
//把buffer转换成字符串保证不乱码
let {stringDecoder} = require('string_decoder')
fucntion parser(requestStream,requestListener){
    function readable(){
        requestStream.on('readable',function(){
        let buf,buffers = []
        while(null != (buf = requestStream.read())){
            buffers.push[buf]
            let str = decoder.write(buf)
            if(str.match(/\r\n\r\n/)){
                let result = Buffer.concat(buffers).toString()
                let values = result.split(/\r\n\r\n/)
                let headers = values.shift()
                let headerObj = parseHeader(headers)
                Object.assign(requestStream,headerObj)
                let body = values.join('\r\n\r\n')
                requestStream.removeListener('readable',onreadable)
                requestStream.unshift(Buffer.from(body))
                return requestListener(requestStream)
            }else{
                buffers.push[buf]
            }
       	  }
    	}
    }
    requestStream.on('readable',onReadable)
  )
}
function parseHeader(headerStr){
    let lines = headerStr.split(/\r\n/)
    let startLine = lines.shift()
    let starts = startLine.split(' ')
    let method = starts[0]
    let url = starts[1]
    let protocal = starts[2]
    let protocalName = protocal.split('/')[0]
    let protocalVersion = protocal.split('/')[1]
    let headers = {}
    lines.forEach(line=>{
        let row = line.split(': ')
        headers[row[0]] = row[1]
    })
    return {headers,method,url,protocalName,protocalVersion}
}
let rs = fs.createReadStream(path.join(_dirname,'req.txt'))
parser(rs,fucntion(req){
       console.log(req.method)
 	   console.log(req.url)
	   console.log(req.header)
       req.on('data',function(data){
    		console.log(data)
		})
        req.on('end',function(){
    		console.log('end')
		})
})
```

```js
//爬虫  node做中间层
//客户端
let http = require('http')
let options = {
    host:'localhost',
    port:8080,
    method:'GET'
    headers:{"Content-Type":'application/x-www-form-urlencoded'}
}
//请求并没有真正发出
let req = http.request(options)
//当服务端把请求发回来的时候 或者说客户端接收到服务端响应触发
req.on('response',function(res){
    let result = []
    res.on('data',function(data){
        result.push(data)
    })
    res.on('end',function(data){
        let str = Buffer.concat(result)
        console.log(str)
    })
})
//write向请求里写数据
req.write('name=test')
//结束请求响应体 只有调用end时候才会真正向服务器发送数据
req.end()

//服务器端
let http = require('http')
let server = http.createServer()
server.on('request',function(req,res){
    res.end('ok')
})
server.listen(8080)
```

```js
//静态文件服务器
//静态文件服务 缓存 断点续传分块获取 命令行工具和配置 加密和权限

```

#### zlib

zlib模块可以进行压缩集解压处理加快传输速度和节约带宽

压缩和解压缩对象都是一个可读可写流

- zlib.createGzip  返回Gzip流对象 使用Gzip算法对压缩数据压缩处理
- zlib.createGunzip 返回Gzip流对象 使用Gzip算法对压缩数据解压处理
- zlib.createDefiate 返回Defiate流对象 使用Defiate算法对压缩数据压缩处理
- zlib.createInflate 返回Defiate流对象 使用Defiate算法对压缩数据解压处理

```js
let fs = require('fs')
let zlib = require('zlib')
function gzip(src){
    //压缩
    fs.createReadStream(src)
        .pipe(zlib.createGzip())
        .pipe(fs.createWriteStream(src + 'gz'))
}
function gunzip(src){
    //解压
    fs.createReadStream(src)
      .pipe(zlib.createGunzip())
      .pipe(fs.createWriteStream(path.basename(src)))
}
/**
客户端向服务器端发请求的时候会通过accept-encoding告诉服务器支持的解压缩格式
Accept-encoding:gzip,deflate
*/
引入fs path url
let {promisify} = require('util')
//把异步stat转为promise
let stat = promisify(fs.stat)
//获取文件类型
let mimie = require('mime')
http.createServer(function(req,res){
    let {pathname} = url.parse(req.url)
    let filepath = path.join(_dirname,pathname)
    try{
        let statObj = await stat(filepath)
        //根据不同文件类型返回不同content
        res.setHeader('Content-Type',mime.getType(pathname))
        let acceptEncoding = req.header['accept-encoding']
        //内容协商
        if(acceptEncoding){
            //\b为单词边界
            if(acceptEncoding.match(/\bgzip\b/)){
                //服务器告诉客户端压缩算法
               res.setHeader('content-Encoding','gzip') fs.createReadStream(filepath).pipe(zlib.createGzip()).pipe(res)
            }else if(acceptEncoding.match(/\bdeflate\b/){
                    fs.createReadStream(filepath).pipe(zlib.createDeflate()).pipe(res) 
            }
        }else{
            fs.createReadStream(filepath).pipe(res)
        }
    }catch(e){
        res.statusCode = 404
        res.end()
    }
    
}).listen(8080)

```

#### crypto

1. crypto 是node中加密解密模块 node使用OpenSSL类库实现加密解密。

   加密好处

   - 校验要下载的文件是否被改动过
   - 对密码实施加密

2. 散列（哈希）算法

   哈希算法用来把任意长度的输入变换为固定长度的输出（md5，sha1）

   - 相同的输入会产生相同的输出
   - 不同的输入会产生不同的输出
   - 任意输入长度输出长度都是相同的
   - 不能从输出推算出输入的值

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\哈希算法.png)

   ```js
   let crypto = require('crypto')
   let str = 'hello'
   let md5 = crypto.createHash('md5')
   md5.update(str) //指定要加密的值 可以多次update
   console.log(md5.digest('hex')) //输出md5的值指定输出格式hex十六进制
   /**
   客户端访问服务器时服务器有可能返回一个响应头Content-MD5 就是响应体的md5值
   */
   let crypto = require('crypto')
   let path = require('path')
   let rs = require('fs').createReadStream(path.join(_dirname,'msg.txt'),{
       highWaterMark:2
   })
   let md5 = crypto.createHash('md5')
   rs.on('data',fucntion(data){
         md5.update(data)
   })
   rs.on('end',function(){
       let md5Val = md5.digest('hex')
       res.setHeader('content-MD5',md5Val)
   })
   ```

   获取所有散列算法 `crypto.getHashea()`

3. HMAC算法

   将哈希算法和密钥结合来组织对签名完整性的破坏

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\hamc.png)

   ```js
   let crypto = require('crypto')
   let path = require('path')
   //algorithm是可用的摘要算法(sha1/md5/sha256) key指定PEM格式密钥
   let hamc = crypto.createHamc(algorithm,key)
   hamc.update(data)
   ```

   **生成私钥**

   PEM是OpenSSL标准格式，OpenSSL使用PEM文件格式存储证书和密钥，基于Base64编码`$ openssl genrsa -out rsa_privite.key 1024`

   ```js
   let pem = fs.readFileSync(path.join(_dirname,'./rsa_private.key'))
   let key = pem.toString('ascii')
   let hamc = crypto.createHmac('sha1',key)
   let rs = fs.createReadStream(path.join(_dirname,'1.txt'))
   rs.on('data',function(data){
       hamc.update(data)
   })
   rs.on('end',function(){
       let result = hamc.digest('hex')
       console.log(result)
   })
   ```

4. 对称加密

   blowfish短发是一种对称加密算法 ，对称意思是加密解密使用的同一个密钥

   ```js
   let crypto = require('crypto')
   let fs = require('fs')
   let str = 'hello'
   let cipher = crypto.createCipher('blowfish',fs.readFileSync(path.join(_dirname,'rsa.private.key')))
   cipher.update(str,'utf8')
   let encry = cipher.final('hex')
   console.log(encry)
   
   let deciper = crypto.createDecipher('blowfish',fs.readFileSync(path.join(_dirname,'rsa.private.key')))
   let deEncy = deciper.update(encry,'hex')
   console.log(deEncy)
   ```

5. 非对称加密

   非对称加密算法需要两个密钥公开密钥和私有密钥

   公钥和私钥是一堆，如果公钥对数据加密，只有对应私钥才可以解密。

6. 签名

#### url

处理解析url

url.parse(url, true)  true将query转化成一个对象

解析对象转回url`url.format(urlObj)`

```
┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
```

protocol 协议

slashes //

auth 用户名密码

host  主机

#### yargs可执行脚本

可执行脚本

- 使用js写一个可执行脚本 `#!usr/bin/env.node console.log('hello')`

- 修改权限`chmod 755 hello`

- 执行脚本`./hello hello`

- 如果想把路径去掉可以把hello路径加入环境变量PATH 或在当前目录下创建一个package.json

  ```js
  {
  name:"hello",
  "bin":{
  	'hello':'hello'
  	}
  }
  ```

- npm link

命令行参数原始写法

`#!/usr/bin/env node console.log('hello',process.argv[2])`

`hello test process.env = ['node','hello','test']`

新建进程

脚本可以通过child_process模块新建子进程从而执行linux命令

```js
#!/usr/bin/env node
let name = process.argv[2]
let {exec} = require('child_process')
let child = exec('echo hello'+ name,(err,stdout,stderr)=>{
    if(err)throw err
    console.log(stdout)
})

hello test
```

yargs 解决如何处理命令行参数


1. 安装 `npm i yargs --save`

2. 读取命令行参数

   ```js
   let yargs = require('yargs')
   //用来解析命令行参数，把参数数组变成对象形式
   //process.argv 命令行工具的命令行参数
   let argv = yargs.argv
   consoel.log('hello',argv.name)
   
   hello --name=test
   hello --name test
   ```

   >process.argv `['/usr/local/bin/node','/usr/local/bin/hello4','--name=test']`
   >
   >argv `{name:'test'}`

3. 指定别名

   ```js
   let argv = require('yargs')
   					.alias('n','name')
   					.argv
   
   hello -n test
   hello --name test
   ```

4. 下划线属性

   argv对象有一个下划线属性可以获取非连词线开头参数

   ```js
   let argv = require('yargs').argv
   cosnole.log('hello',argv.n)
   console.log(argv._)
   
   hello A -n test B C
   hello test ['A','B','C']
   ```

5. 命令行参数配置

   - demand是否必选
   - default默认值
   - describe提示

   ```js
   #!/usr/bin/env node
   let argv = require('yargs')
   					.demand('[n]')
   					.default({n:'test'})
   					.describe({n:'你的名字'})
   console.log('hello',argv.n)
   //代表n不能省略 默认值为test并给出提示
   ```

   options方法允许将所有的配置写入配置对象

   ```js
   #!/usr/bin/env node
   let argv = require('yargs')
   					.options('n',{
                           alias:'name',
                           demand:true, //必填
                           default:'test',
                           describe:'请输入名字',
                           type:'string',
                           boolean:true
                       })
   					.usage('hellp[aoptions]')
   					.help() //指定帮助信息
   					.example('hello -name test','执行help命令传入name参数为test')
   					.alias('h','help')
   					.argv
   
   console.log('hello',argv.n)
   //有些参数不常用作用是开关时使用boolean指定这些参数返回布尔值
   ```

#### 静态资源服务器命令行工具

**静态文件服务器** 可以在任意目录下启动一个静态文件服务器，并把当前目录作为静态文件根目录

test-server -d 指定静态文件根目录 -p指定端口号 -指定监听的主机

```js
//app.js
/*
npm初始化app.js npm init -y
*/
//创建一个服务器
let config = require('./config')
let http = require('http')
//chalk 给命令行文件加颜色
let chalk = require('chalk')
//在控制台输出的模块 每个debug实例都有一个名字 是否在控制台打印取决于环境变量中debug值是否等于static:app static为项目名app为模块名
let debug = require('debug')('static:app')
let path =require('path')
let fs = require('fs')
let {promisify,inspect} = require('util')
let stat = promisify(fs.stat)
let readdir = promisify(fs.readdir)
let mime = require('mime')
//模板引擎
let handlebar = require('handlebars')
function list(){
    //编译模板得到渲染方法 传入实际数据 得到渲染html
    let tmp1 = fs.readFileSync(path.join(_dirname,'template','list.html'),'utf8')
    return handlebars.compaile(tmp1)
}
class Server{
    constructor(argv){
        this.list = list()
        this.config = Obejct.assign({},this.config.argv)
    }
    start(){
        let server = http.createServer()
        server.on('request',request.bind(this))
        server.listen(this.config.port,()=>{
            let url = `http://${this.config.host}:${this.config.port}`
            debug(`server started at ${chalk.green(url)}`)
        })
    }
    async request(req,res){
        //先渠道客户端想访问的文件或文件夹路径
        let {pathname} = url.parse(req.url)
        if(pathname == '/favicon.ico') return this.sendError(req,res)
        let filepath = path.join(this.config.root,pathname)
        try{
            let statObj = await stat(filepath)
            if(statObj.isDirectory()){
                //如果是目录的话应该显示目录下面的文件列表
                let files = await readdir(filepath)//读取文件列表
                files = files.map(file=>({
                    name:file,
                    url:path.join(pathname,file)
                }))
                let html = this.list({
                    title:pathname,
                    files
                })
                res.setHeader('content-Type','text/html')
                res.end(html)
            }else{
                this.sendFile(req,res,filepath,statObj)
            }
            
        }catch(e){
            debug(inspect(e))//inspect把对象转字符串
            this.sendError(req,res)
        }
    }
    sendFile(req,res,filepath,statObj){
        res.setHeader('content-Type',mime.getType(filepath))
        fs.createReadStream(filepath).pipe(res)
    }
    sendError(req,res){
        res.statusCode = 500
        res.end('wrong')
    }
}
module.exports = Server

//config.js
let path =require('path')
module.exports = {
    host:'localhost', //监听的主机
    port:8080, //监听的端口号
    root:path.resolve(_dirname,'..','public') //配置静态文件根目录
}
//建立bin/www 目录存放命令 修改package.json 'bin':{'test-server2':'bin/www'}
//www.js
let yargs = require('yargs')
let Server = require('../src/app.js')
let argv = yargs.option('d',{
    alias:'root',
    demand:'false',
    type:'string',
    default:process.cwd(),
    description:'静态文件根目录'
}).option('o',{
    alias:'host',
    demand:'false',
    type:'string',
    default:'localhost',
    description:'请配置监听的主机'
}).option('p',{
    alias:'port',
    demand:'false',
    type:'number',
    default:8080,
    description:'请配置端口号'
}).usage('test-server2 [options]')
  .exaple({'test-server2 -d / -p 9090 -o localhost','在本机的9090端口上监听客户端的请求'})
  .help('h')
  .argv
let server = new Server(argv)
server.start()
```

建立列表页模板

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\模板.png)

#### cache

1. 缓存的作用

   - 减少冗余数据传输节省网费
   - 减少服务器负担提高网站性能
   - 加快了客户端加载网页的速度

2. 缓存分类

   强制缓存如果生效不需要和服务器进行交互，对比缓存不管是否生效都需要与服务器端交互。两类缓存可以同时存在，强制缓存优先级高于对比缓存，当执行缓存规则时缓存生效直接使用缓存，不再执行对比缓存规则

   - 强制缓存  

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\强制缓存.png)

     

   - 对比缓存 需要比较判断是否可以使用的缓存

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\对比缓存.png)

3. 请求流程

   - 第一次请求

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\第一次请求.png)

     第一次请求服务器时，服务器返回资源和缓存的标识，客户端把此资源缓存在本地缓存数据库中

   - 第二次请求

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\第二次读取.jpg)

4. 通过最后修改时间判断缓存是否可用

   - last-Modified:响应时告诉客户端此资源的最后修改时间
   - If-Modifiled-Since:当资源过期（使用cache-contro标识的max-age）发现资源具有last-modified声明，则再向服务器请求时带上头If-Modifiled-Since
   - 服务器收到请求后发现有头If-Modifiled-Since则与被请求资源后的最后修改时间进行比对，若最后修改时间较新，说明资源又被改动过，则响应最新的资源内容并返回200状态码
   - 若最后修改时间和If-Modifiled-Since一样，说明资源没有修改则响应304表示未更新，告知浏览器继续使用所保持的缓存文件。

   ```js
   let http = require('http')
   let fs = require('fs')
   let url = require('url')
   let path = require('path')
   let mime = require('mime')
   http.createServer(function(req,res){
       let {pathname} = url.parse(req.url,true)
       let filepath = path.join(_dirname,pathname)
       fs.stat(filepath,(err,stat)=>{
           if(err){
               return sendError(req,res)
           }else{
               let ifModifiedSince = req.header['if-modified-since']
               let lastModified = stat.ctime.toGMTString()
               if(ifModifiedSince == lastModified){
                   res.writeHead(304)
                   res.end('')
               }else{
                   return send(req,res,filepath,stat)
               }
           }
       })
   }).listen(8080)
   function sendError(req,res){
       res.end('not found')
   }
   function send(req,res,filepath,stat){
       res.setHeader('Content-Type',mime.getType(filepath))
       //发给客户端之后客户端会把此事件保存起来 下次获取时把时间发给服务器
       res.setHeader('Last-Modifred',stat.ctime.toGMTString())
       fs.createReadStream(filepath).pipe(res)
   }
   ```

   问题：

   - 某些服务器不能精确得到文件的最后修改时间这样就无法通过修改时间来判断文件是否更新了。
   - 某些文件的修改非常频繁在秒以下时间修改，last-modified只能精确到秒
   - 一些文件的最后修改时间改变了但内容不变时不希望客户端认为这个文件被修改了
   - 同一个文件位于多个cdn服务器时内容虽然一样修改时间不一样

5. ETag

   ETag是实体标签的缩写，根据实体内容生成的一段hash字符串可以标识资源的状态，当资源发生改变时ETag也改变。ETag是web服务器端产生的发给浏览器客户端

   - 客户端想判断魂村是否可用可以先获取缓存中文档的ETag然后通过If-None-Match发送请求给web服务器询问此缓存是否可用
   - 服务器收到请求将服务器中此文件的ETag和请求头中的If-None-Match比较，如果值一样说明缓存还是最新的，web服务器将发送304给客户端表示缓存不变可用
   - 如果不一样web服务器端将发送最新版文档给本地浏览器客户端

   ```js
   let http = require('http')
   let fs = require('fs')
   let url = require('url')
   let crypto = require('crypto')
   let mime = require('mime')
   http.createServer(function(req,res){
       let file = path.join(_direname,req.url)
       fs.stat(file,(err,stat)=>{
            if(err){
                sendError(err,req,res,file,stat)
            }else{
                let ifNoneMatch = req.headers['if-none-match']
                let etag = crypto.createHash('sha1').update(stat.ctime.toGMTString() + stat.size).digest('hex')
                if(ifNoneMatch){
                    if(ifNoneMatch == etag){
                        res.writeHead(304)
                        res.end()
                    }else{
                        send(req,res,file,etag)
                    }
                }else{
                    send(req,res,file,etag)
                }
            }   
       })
   }).listen(8080)
   function sendError(req,res){
       res.end('not found')
   }
   function send(req,res,file,etag){
    	res.setHeader('ETag',etag)
       //第一次服务器返回时把标识发给客户端
       res.writeHead(200,{'Content-Type':mime.lookup(file)})
       fs.createReadStream(file).pipe(res)
   }
   ```

6. 如何不发请求-强制缓存

   - 浏览器会将文件缓存到cache目录，第二次请求时浏览器会先检查cache目录下是否含有文件，有并且还没到Expires设置的时间即文件还没有过期，此时浏览器直接从cache目录中读取文件，而不再发送请求
   - Expires是服务器响应消息头字段，在响应http请求时告诉浏览器过期时间，浏览器可以直接从浏览器缓存数据无需再次请求（http1.0）
   - Cache-Control与Expires作用一致都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存数据还是重新发请求到服务器取数据，同时设置时优先级高于Expires

   **Cache-Control**

   - private客户端可以缓存
   - public客户端和代理服务器都可以缓存
   - max-age-60缓存内容将在60s后失效
   - no-cache需要使用对比缓存验证数据强制想服务器再次验证
   - no-store所有内容不缓存，强制缓存和对比缓存都不触发

   ```js
   let http = require('http')
   let fs = require('fs')
   let url = require('url')
   let crypto = require('crypto')
   let mime = require('mime')
   http.createServer(function(req,res){
       let file = path.join(_direname,req.url)
       fs.stat(file,(err,stat)=>{
            if(err){
                sendError(err,req,res,file,stat)
            }else{
                send(req,res,file)
            }   
       })
   }).listen(8080)
   function sendError(req,res){
       res.end('not found')
   }
   function send(req,res,file,etag){
       let expires = new Date(Date.now()+60*1000)
       res.setHeader('Expires',expires.toUTCString())
    	res.setHeader('Cache-Control','max-age-60')
       //第一次服务器返回时把标识发给客户端
       res.writeHead(200,{'Content-Type':mime.lookup(file)})
       fs.createReadStream(file).pipe(res)
   }
   ```

#### 进程/process对象

node中每个应用程序都是一个进程类的实例对象

process对象代表这是一个全局对象，可以通过它来获取node应用程序及运行该程序的用户环境等信息

1. 进程对象属性

   - exexPath 可执行文件的绝对路径
   - version 版本号
   - platform 运行平台
   - stdin 标准输入可读流默认暂停状态
   - stdout标准输出可写流 同步
   - stderr错误输出可写流 同步
   - argv 属性值为数组
   - env 操作系统环境信息
   - pld应用程序进程id
   - title窗口标题
   - arch处理器架构

   ```js
   process.stdin.resume()
   process.stdin.on('data',function(chunk){
       process.stdout.write('进程收到数据'+chunk)
   })
   process.argv.forEach((val,index,ary)=>console.log(index,val))
   ```

2. memoryUsage方法 `process.memoryUsage()`

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\memoryUsage.png)

   返回值

   - rss 所有内存占用包括指令区和栈
   - heapTotal 堆总量
   - heapUsed 堆用量
   - exterial  v8引擎内部c++对象占用的内存

3. nextTick方法

   用于将一个函数推迟到代码中所书写的下一个同步方法执行完毕或一部方法的回调函数开始执行前调用

4.  `process.chdir(directory)` 修改node当前工作目录

5.  `process.cwd()`返回当前目录

6. `process.chdir`改变当前工作目录

   ```js
   console.log(`当前目录${process.cwd()}`)
   process.chdir(..)
   console.log(`上层目录${process.cwd()}`)
   ```

7. `process.exit()` 退出运行node应用程序的进程

8. `process.kill(pid,[signal])`向进程发送一个信号

   - SIGHT程序终止(interrupt)信号，在用户键入INTR字符（ctrl+c）时发出，用于通知前台进程终止进程
   - SIGTERM程序结束（teminate）信号，该信号可以被阻塞和处理，通常用来要求程序自己正常退出

   参数：

   - pid是一个整数用于指定需要接受信号的进程id
   - singnal发送的信号默认为SIGTERM

9. `process.uptime()`返回当前程序运行时间

10. hrtime 

    测试一段代码的运行时间，返回两个时间一个单位是秒另一个是纳秒

    ```js
    let fs = require('fs')
    let time = process.hrtime()
    let data = fs.readFileSync('index.txt')
    let diff = process.hrtime(time)
    console.log(diff[0])
    ```

11. exit事件 

    运行node应用程序的进程退出是触发进程对象的exit时间，可以通过指定事件回调函数来指定进程退出是所执行的处理

    ```js
    process.on('exit',function(){
        console.log('node进程被退出')
    })
    process.exit()
    ```

12. uncaughtException事件

    当应用程序跑出一个未被捕获的异常时触发进程对象的uncaughtException事件

    ```js
    process.on('uncoughtException',function(err){
        console.log('捕获一个未被处理的错误',err)
    })
    notExist()
    ```

13. 信号事件

    ```js
    process.stdin.resume()
    process.on('SIGINT',function(){
        console.log('接受到SIGINT信号')
    })
    ```

子进程

node只有一个线程执行所有操作，提供了一个child_process模块通过它可以开启多个子进程，在多个子进程之间可以共享内存空间，可以通过子进程的互相通信来实现信息的交换

1. spawn `child_process.spawn(command,[args],[options])`

   - command 必填 指定要执行的命令

   - args 存放所有运行该命令的参数

   - options指定开启子进程使用的选项 

     - cwd子进程的工作目录

     - env环境变量

     - detached 为true子进程为进程组的领头进程 父进程不存在也可以独立存在

     - stdio三个元素数组设置标准输入/输出

       - pipe 父进程可以图片那个高子进程的stdio[0]访问子进程的标准输入，通过stdio[1]访问标准1输出，stdio[2]访问错误输出

       - ipc 可以调用子进程send方法向子进程发信息，子进程会触发message事件

       - ignore 指定不为子进程设置文件描述符，这样子进程的标准输入、标准输出和错误输出被忽略

       - stream 子进程和父进程共享一个终端设备、文件、端口或管道

       - 正整数数值和共享一个Strem一样

       - null或undefined在子进程中创建父进程相连的管道

   默认情况下子进程的stdin,stdout,stderr导向childProcess对象的child stdin,child stdout, child stderr流

   ```js
   let spawn  = require('child_process').spawn
   spawn('prg',[],{stdio:['pipe','pipe',process.stderr]})
   ```

   - ignore['ignore','ignore','ignore'] 全部忽略
   - pipe['pipe','pipe','pipe']通过管道连接
   - inherit[process.stdin,process.stdout,process.stderr]/[0,1,2]和父进程共享输入输出

   ```js
   let spawn  = require('child_process').spawn
   spawn('prg',[],{stdio:'inhreit'})
   ```

   - spawn返回一个隐式创建的代表子进程的childProcess对象
   - 子进程对象拥有stdin属性值为一个可用于读入子进程的标准输入流对象
   - 子进程对象拥有stdout属性值和stder属性值

   **子进程事件**

   - close 

     子进程所有输入输出终止时会触发子进程对象的close

     ```js
     child.on('close',function(code,signal){})
     //code 值为0正常退出 null异常退出
     //在父进程中关闭子进程时，signal参数值为父进程发给子进程的信号名称
     ```

   - exit

     子进程退出时触发子进程对象的exit事件

     多个进程可能会共享i个输入/输出，当子进程退出时，子进程的输入/输出可能并未终止

     `child.on('exit',function(code,signal){})`

   - error

     子进程开启失败触发error `child.kill([signal])`

   - kill `child.kill([signal])`

     父进程还可以使用kill方法向子进程发送信号，参数为描述该信号的字符串，默认参数值为SIGTERM

     SIGTERM程序结束信号和SIFKILL不同的是该信号可以被阻塞和处理

   - detached

     默认情况下只有子进程全部退出后父进程才能退出。为了让父进程可以先退出，而子进程继续进行I/O操作可以在spawn中使用options参数，把detached属性值设置为true

     ```js
     let cp = require('child_process')
     let fs = require('fs')
     let path = require('path')
     let out = fs.openSync(path.join(_dirname,'msg.txt'),'w',0o666)
     let sp = cp.spawn('node',[detached.js],{
         detached:true,
         stdio:['ignore',out,'ignore']
     })
     sp.unref()
     
     let count = 10
     let $timer = setInterval(()=>{
         process.stdout.write(new Date().toString()+'\r\n')
         if(--count == 0){
             clearInterval($timer)
         }
     },500)
     ```

2. fork开启子进程

   使用fork开启一个转用于运行node的子进程，fork方法返回一个隐式创建的代表子进程的childprocess对象，子进程的输入输出操作执行完毕后，子进程不会自动退出，必须使用process.exit()

   `child_process.fork(modulePath,[args],[options])`

   args运行该文件模块文件时  使用的参数

   options {

   ​	cwd 指定子进程工作目录

   ​	env属性值为一个对象用于‘键名/键值’形式为子进程指定环境变量

   ​	encoding 字符串 用于指定输出输入标准错误输出数据编码格式 默认utf8

   ​	silent  布尔值 false时子进程和父进程共享标准 true时不共享

   }

   - 发送消息

     ```js
     child.send(message,[sendHandle]) //在父进程中向子进程发送消息
     process.send(message,[sendHandle])//在子进程中向父进程发送消息
     ```

     - message 对象 指定需要发送的消息
     - sendHandle指定一个当接收到对方发送消息后执行的回调函数
     - 子进程可以监听父进程的message事件 `process.on('message',function(m,setHandle){})`
     - 父进程收到子进程的消息触发子进程message事件`child.on('message,function(m,setHandle){}')`

     ```js
     //fork.js
     let {fork} = require('child_process')
     let path = require('path')
     let child = fork(path.join(_dirname,'fork.js'))
     child.on('message',function(m){
         console.log('父进程收到消息',m)
         process.exit()
     })
     child.send({name:'test'})
     child.on('error',fuction(err){
              cosole.error(arguments)
     })
     
     process.on('message',function(m,setHandle){
         cosnole.log('子进程收到消息',m)
         process.send({
             age:0
         })
     })
     ```

   - silent

     默认情况下子进程对象与父进程对象共享标准输入输出，如果要子进程用独立的标准输入输出，可以将silent属性值设为true

     ```js
     let {fork} = require('child_process')
     let path = require('path')
     let p1 = fork(path.join(_dirname,'fork.js'),['1','2','3'],{silent:true})
     let p2 = fork(path.join(_dirname,'fork2.js'))
     p1.stdout.on('data',function(data){
         cosnole.log('子进程：标准输出'+data)
         p2.send(data.toString())
     })
     p1.on('exit',function(code,signal){
         console.log('子进程退出，退出代码为：'+code)
     })
     p1.on('error',function(err){
         cosnole.log('子进程开启失败：'+err)
         process.exit()
     })
     
     //fork.js
     process.qrgv.forEach(function(item){
         process.stdout.write(item+'\r\n')
     })
     //fork2.js
     let fs = require('fs')
     let out = fs.createWriteStream(path.join(_dirname,'msg.txt'))
     process.on('message',function(data){
         out.write(data)
     })
     ```

   - 子进程与父进程共享http服务器

     ```js
     let http = require('http')
     let {fork} = require('child_process')
     let net = require('net')
     let path = require('path')
     let child = fork(path.join(_dirname,'child.js'))
     let server = net.createServer()
     server.listen(8080,'127.0.0.1',function(){
         child.send('server',server)
         cosole.log('父进程中的服务器已经创建')
         let httpServer = http.createServer()
         httpServer.on('request',fucntion(req,res){
              if(req.url != '/favico.ico'){
             	let sum = 0
                 for(let i=0;i<100000;i++){
                     sum+=1
                 }
             	res.write('客户端请求在父进程中被处理')
            		res.end('sunm'+sum)
         	 }         
         })
     	httpServer.listen(server)
     })
     
     process.on('message',function(msg,server){
         if(msg == 'server'){
             console.log('子进程的服务器已经被创建')
             let httpServer = http.createServer()
             httpServer.on('request',function(req,res){
                 if(req.url != '/favico.ico'){
             	let sum = 0
                 for(let i=0;i<100000;i++){
                     sum+=1
                 }
             	res.write('客户端请求在子进程中被处理')
            		res.end('sunm'+sum)
         	 }         
             })
             httpServer.listen(server)
         }
     })
     
     let options = {
         hostname:'localhost',
         port:8080,
         path:'/',
         method:'GET'
     }
     for(let i =0;i<10;i++){
         let req = http.request(options,function(res){
             res.on('data',function(chunk){
                 console.log('响应内容'+chunk)
             })
         })
         req.end()
     }
     ```

   - 子进程与父进程共享socket对象

     ```js
     let {fork} = require('child_process')
     let net = require('net')
     let path = require('path')
     let child = fork(path.join(_dirname,'socket.js'))
     let server = net.createServer()
     server.on('connection',function(socket){
         if(Date.now()%2 == 0){
             child.send('socket',socket)
         }else{
             socket.end('客户端请求被父进程处理')
         }
     })
     server.listen(41234)
     
     process.on('message',function(m,socket){
         if(m === 'socket'){
             socket.end('客户端请求被子进程处理')
         }
     })
     
     let client = new net.Socket()
     client.sendEncoding('uft8')
     client.connect(41234,'localhost')
     client.on('data',function(data){
         console.log(data)
     })
     ```
   
   3. exec开启子进程
   
      exec可以开启一个用于运行某个命令的子进程并缓存子进程的输出结果 ，spawn是一个异步方法，exec是一个同步方法
   
      `child_process.exec(command,[options],[callback])`
   
      command需要执行的命令
   
      options {
   
      ​	cwd 指定子进程工作目录
   
      ​	env指定环境变量
   
      ​	encoding 字符串 用于指定编码格式 默认utf8
   
      ​	timeout 子进程的超时时间
   
      ​    maxbuffer指定缓存标准输出赫尔错误输出的缓冲区最大长度
   
      ​	killSignal指定关闭子进程的信号 默认'SIFTERM'
   
      }
   
      callback 子进程终止时调用的回调函数`function(err,stdout,stderr){}`
   
      ```js
      //exec同步执行一个shell命令
      let {exec} = require('child_process')
      let path = require('path')
      let p1 = exec('node test1.js a b c',{
          cwd.path.join(_dirname,'test3')
      },function(err,stdout,stderr){
          if(err){
              console.log('子进程开启失败'+err)
          }else{
              cosnole.log('子进程标准输出\r\n'+stdout.toString())
              p2.stdin.write(stdout.toString())
          }
      })
      let p2 = exec('node test2.js',{
          cwd:path.join(_dirname,'test3')
      },function(err,stdout,stderr){
          process.exit()
      })
      
      process.argv.foreach(function(item){
          process.stdout.write(item+'\r\n')
      })
      
      let out = fs.createWriteStream(path.join(_dirname,'msg.txt'))
      process.stdin.on('data',function(data){
          out.write(data)
          process.exit()
      })
      ```
   
   4. execFile开启子进程
   
      可以使用execfile开启一个专业运行某个可执行文件的子进程，类似child_process.exec()但自己衍生命令
   
      `child_process.execFile(file,[args],[options],[callback])`
   
      ```js
      let {execFile} = require('child_process')
      let path = require('path')
      let p1 = execFile('node test1.js',{
          cwd.path.join(_dirname,'test4')
      },function(err,stdout,stderr){
          if(err){
              console.log('子进程开启失败'+err)
          }else{
              cosnole.log('子进程标准输出\r\n'+stdout.toString())
              p2.stdin.write(stdout.toString())
          }
      })
      let p2 = execFile('node test2.js',{
          cwd:path.join(_dirname,'test4')
      },function(err,stdout,stderr){
           if(err){
              console.log('子进程开启失败'+err)
              process.exit()
          }else{
              cosnole.log('子进程标准输出\r\n'+stdout.toString())
              p2.stdin.write(stdout.toString())
          }
         
      })
      
      process.argv.foreach(function(item){
          process.stdout.write(item+'\r\n')
      })
      
      let out = fs.createWriteStream(path.join(_dirname,'msg.txt'))
      process.stdin.on('data',function(data){
          out.write(data)
          process.exit()
      })
      ```
   
      
   
3. cluster

   cluster模块运行在多个子进程中运行不同的node应用程序


#### 多语言切换action

通过Accept-Language检测浏览器的语言

- 请求头格式 Accept-Language:`Accept-Language:zh-Cn,zh;q=0.9`

  q为语言权重

- 响应头格式 Content-Language:zh-Cn

```js
let http = require('http')
let server = http.createServer(request)
server.listen(8080)
const lanPack = {
    en:{
        title:'welcome'
    },
    zh:{
        title:'欢迎光临'
    }
}
function request(req,res){
    //实现服务器与客户端的协商
    //Accept-Language:zh-CN,zh;q=0.9;en;q=0.8;jp;q=0.7
    let acceptLanguage = req.headers['accept-language']
    if(acceptLanguage){
        let lans = acceptLanguage.split(',').map(function(item){
            let values = item.split(';')
            let name = values[0]
            let q = parseFloat(values[1].split('='))||1
            return {
                name,q
            }
        }).sort((a-b)=>b.q-a.q)
        const lan = 'en' //默认语言
        for(let i= 0;i<lans.length;i++){
            if(lanPack[lans[i]].name){
                lan = lans[i].name
                break
            }
        }
        res.end(lanPack[lan].title)
    }
}
```

#### 图片防盗链

- 从一个网站跳转或者网页引用某个资源文件时，http请求中带有Referer来表示原网页的url
- 通过检查请求头中的Referer来判断来源网页的域名
- 如果来源域名不在白名单内则返回错误提示
- 用浏览器直接访问图片地址是没有referer的

```js
let http = require('http')
let fs = require('fs')
let url = reuire('url')
const whiteList = {
    'test1.com',
    'test2.com'
}
let server = http.createServer(function(req,res){
    let refer = req.headers['referer'] || req.headers['refer']
    if(refer){
        //页面引用图片
        let currentHostname = url.parse(req.url,true).hostname
        let referHostname = url.parse(refer,true).hostname
        if(referHostname!=currentHostname && whiteList.indexOf(referHostname)== -1){
            //不允许访问返回失败图片
            res.setHeader('Content-Type','image/jpg')
            fs.crateReadStream(path.join(_dirname,'forbidden.jpg')).pipe(res)
        }
        return
        
    }
    res.setHeader('Content-Type','image/jpg')
    fs.createReadStream(path.join(_dirname,'test.jpg').pipe(res))
})
server.listen(8080)
```

#### 代理服务器

网络代理允许一个网络中断通过这个服务与另一个网络终端进行非直接的连接。代理服务器有利于保障网络终端的隐私或安全防止攻击。

- 正向代理 代理局域网和用户访问外网
- 反向代理 代理局域网内服务器

`npm i http-proxy --save`

- web代理普通的http请求
- listen port
- close关闭内置服务

```js
let httpProxy = require('http-proxy')
let http = require('http')
let proxy = httpProxy.createProxyServer()
http.createServer(function(req,res){
    proxy.web(req,res,{
        target:'http://localhost:8080'
    })
    proxy.on('error',function(err){
        res.end(err.toString())
    })
}).listen(8080)
```

#### 虚拟主机



```js
//反向代理 nginx原理
let http = require('http')
let proxyServer = require('http-proxy')
let ps = proxyServer.cerateProxyServer()
let config = {
    'test1.com':'http://loacalhost:8080',
    'test2.com':'http://localhost:9000'
}
let server = http.createServer(function(req,res){
    let host = req.headers['host']
    let target = config[host]
    if(target){
        ps.web(req,res,{
            target
        })
    }else{
        res.end(host)
    }
}).listen(80)
```

#### express

express是一个小巧灵活的node应用框架，可以用于开发单页、多页和混合web应用

1. express应用

   - 安装 `npm i express`

   - 使用  

     ```js
     //引入
     let express = require('express')
     //执行express函数
     let app =express()
     //监听端口
     app.listen(3000)
     ```

     ```js
     //express实现
     const http = require('http')
     const url  = require('url')
     function createApplication(){
         let app = function(req,res){
             const {pathname} = url.parse(req.url,true)
             //请求监听函数
             let index = 0
             function next(err){
                 if(index>=app.routes.length){
                     return res.end(`cannot ${req.method}${pathname}/`)
                 }
                 let route = app.routes[index++]
                 if(err){
                      if(route.method == 'middle'){
                         if(pathname.startWitsh(route,path)){
                             if(route.handler.length == 4){
                                 route.handler(err,req,res,next)
                             }else{
                                 next(err)
                             }
                     	}else{
                        		 next(err)
                     	}
                      }else{
                          next(err)
                      }
                 }else{
                      if(route.method == 'middle'){
                     //中间件
                     if(pathname.startWitsh(route,path)){
                         route.handler(req,res,next)
                     }else{
                         next()
                     }
                     
                 }else{
                     //路由
                     if(route.paramsNames){
                         //有路径参数
                         let machers = pathname.match(route.path)
                         if(machers){
                             for(let i =0;i<route.paramsNames.length;i++){
                                 params[route.paramsNames[i]] = machers[i+1]
                             }
                             req.params = params
                             for(let j=0;j<route.paramsNames.length;j++){
                                 let handler = app.paramHandlers[route.paramsNames[i]]
                                 if(handler){
                                     handler(req,res,()=> route.handler(req,res),req.params[name])
                                 }
                             }
                         }else{
                             next()
                         }
                     }else{
                          if((route.method == req.method.toLowerCase() || route.method == 'all') && (route.path == pathname ||route.path == '*')){
                    		 	return route.handler(req,res)
                  		}else{
                      		next()
                  		}
                     }
                }
                 }
             }
             next()
             /*for(let i = 0; i<app.routes.length;i++){
                 let route = app.routes[i]
                 if((route.method == req.method.toLowerCase() || route.method == 'all') && route.path == pathname ){
                     return route.handler(req,res)
                 }
             }*/
         }
         app.listen = function(){
             let server = http.createServer(app)
             server.listen.apply(server,arguments)
         }
         //保存路由规则
         app.routes = []
         http.METHODS.forEach(function(method){
             method = method.toLowerCase()
             app.[method] = function(path,handler){
                 const layer = {method,path,handler}
                 if(path.includes(':')){
                     let paramsNames = []
                     //把原来路径转为正则 提取出变量名
                     path = path.replace(/:([^\/]+)/g,function(){
                         paramsNames.push(arguments[1])
                         return ':([^\/]+)'
                     })
                     layer.path = new RegExp(path)
                     layer.paramsNames = paramsNames
                 }
             	app.routes.push(layer)
        	    }
         })
         app.paramHandlers = {}
     	app.param = function (name,handler){
         	paramHandlers[name] = handler
     	}
         app.all = function(path,handler){
             app.routes.push{
                 path,handler,method:'all'
             }
         }
         //添加一个中间件
         app.use = function(path,handler){
         	if(typeof handler != 'function'){
             	handler = path
                 path = '/'
         	}
             app.routes.push{
                 path,handler,method:'middle'
             }
     	}
         return app
     }
     module.exports = createApplication
     ```

   - 方法

     - get(path,handler) 根据请求路径来处理客户端发出的get请求

     - post()

     - all(path,handel) 处理所有请求 可以匹配所有的http动词，根据请求路径来处理所有客户端请求

       ```js
       app.all('/test',function(req,res){
           res.end('hello')
       })
       app.listen(3000)
       ```

     - send()

   - 中间件 

     中间件就是处理http请求的函数，用来完成各种特定的任务，比如检查用户是否登录，检测用户是否有访问权限等

     - 一个中间件处理完请求和响应把相应数据传给下一个中间件
     - 回调函数的next参数表示接受其他中间件的调用，函数体中的next()表示请求数据继续传递
     - 可以根据路径来区分返回执行不同的中间件

     中间件一般处理中间逻辑，中间件的路径只要匹配前缀就可以

     增加中间件

     ```js
     let express = require('express')
     let app = express()
     app.use(function(req,res,next){
         console.log('全部匹配')
         next()
     })
     app.use('/test',function(req,res,test){
         console.log('只匹配/test')
         next()
     })
     app.get('/test',function(req,res){
         res.end('test')
     })
     app.listen(3000)
     ```

     调用next时如果传一个任意参数表示此函数发生了错误，express会跳过后面所有中间件叫诶错误处理中间件来处理

     错误处理中间件

     ```js
     app.use(function(err,req,res,next){
         res.end(err)
     })
     ```

   - 获取参数和查询字符串

     - req.hostname 返回请求头里取的主机名
     - req.path 返回请求的url的路径名
     - req.query 查询字符串

     ```js
     app.get('/',function(req,res){
         res.write(JSON.stringfy(req.query))
         res.end(req.path+' '+req.path)
     })
     ```

     ```js
     //系统内置中间件
     app.use(fucntion(req,res,next){
         const urlObj = url.parse(req.url,true)
     	req.query = urlObj.query
     	req.path = urlObj.pathname
     	req.hostname = req.headers['hostname']
     	next()
     })
     ```

   - 获取params参数

     req.params匹配到的所有路径参数组成的对象

     ```js
     app.get('/school/:name/:age',function(req,res){
         //:为占位符用来匹配任意一个字符串
         cosole.log(req.params)
         res.end('test')
     })
     ```

     param()用来处理路径参数，保存路径参数名和处理函数

     ```js
     app.param('userid',function(req,res,next,userid){
         req.user = getUser(userid)
         next
     })
     function getUser(userid){
         return {userid:1,age:8,name:'test'}
     }
     ```

   **express实现**

   ​	1. 构建服务器

   - 创建express模块导出一个函数，执行函数可以返回一个app对象
   - app对象里定义get和listen方法
   - get方法用于给路由添加规则
   - 初始化router对象保存所有的路由
   - listen方法用于启动一个http服务器并指定处理函数

   ```js
   //测试用例
   const express = require('../index')
   const app = express()
   app.get('/',function(req,res){
   	res.end('hello')
   })
   app.listen(3000,function(){
       console.log('start')
   })
   ```

   实现

   ```js
   //index.js
   let router = [{ //路由规则
       path:'*',
       method:'*',
       handler(req,res){
           res.end(`cannot ${req.method}${req.url}`)
       }
   }]
   const http = require('http')
   const url = require('url')
   function createApplication(){
       return{
           get(path,handler){
               router.push({path,handler,method:'get'})
           },
           listen(){
               let server = http.createServer(function(req,res){
                   let {pathname} = url.parse(req.url,true)
                   for(let i = 0; i < router.length; i++){
                       let {path,method,handler} = router[i]
                       if(pathname == path && method == req.method.toLowerCase()){
                           return handler(req,res)
                       }
                   }
                   router[0].handler(req,res)
               })
               server.listen.apply(server,arguments)
           }
       }
   }
   module.exports = createApplication
   ```

   2. 封装rouer

      - app从字面量变成application类
      - 丰富http请求方法

      - 封装router
      - 路径一样的路由整合为一组，引入layer
      - 增加路由控制，支持next()增加错误捕获
      - 执行router.handler时传入out参数

      ```js
      //测试用例
      //路径的分组 相同路径的接口只匹配一次
      app.get('/',function(req,res,next){
          console.log(1)
          next('wrong')
      },function(req,res,next){
          console.log(11)
          next()
      }).get('/',function(req,res,next){
          console.log(2)
          next()
      }).get('/',function(req,res,next){
          console.log(3)
          res.end('ok')
      }).get('/',function(err,res,next){
          res.end('catch':+err)
      })
      app.listen(3000)
      ```

      实现

      ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\express.png)

      ```js
      //index.js
      const Route = require('./route')
      const Layer = require('./layer')
      const url = require('url')
      const methods = require('methods')
      const slice = Array.prototype.slice()
      function Router(){
          this.stack = []
      }
      //创建一个router实例，向当前路由系统中添加一个层
      Router.prototype.route = function(path){
          let route = new Route(path)
          let layer = new Layer(path,route.dispatch.bind(route))
          layer.route = route
          this.stack.push(layer)
          return toute
      }
      methods.forEach(function(method){
          Router.prototype[method] = function(path){
              let route = this.route(path)
          	route.get(handler)
              route[method].apply(route,slice.call(arguments,1))
          }
          return this
      })
      Router.prototype.handle = function(req,res,out){
          let idx = 0, self = this
          let {pathname} = url.parse(req.url,true)
          function next(err){
              if(idx >= self.stack.length){
                  return out()
              }
              let layer = self.stack[idx++]
              if(layer.match(pathname) && layer.route && layer.route.handler_method(req.method)){
                  if(err){
                      layer.handler_err(err,req,res,next)
                  }else{
                      layer.handler_request(req,res,next)
                  } 
              }else{
                  next()
              }
          }
      }
      module.exports = Router
      
      //route.js
      const methods = require('methods')
      const slice = Array.prototype.slice()
      const Layer = require('./layer')
      function Route(path){
          this.path = path
          this.stack = []
          //表示此路由有此方法的处理函数
          this.methods = []
      }
      Route.prototype.handler_method = function(method){
          method = method.toLowerCase()
          return this.methods[method]
      }
      methods.forEach(function(method){
          Route.prototype[method] = function(){
              let handlers = slice.call(arguments)
              this.methods[method] = true
              for(let i=0;i<handlers.length;i++){
                  let layer = new Layer('/',handlers[i])
          		layer.method = method
         			
          		this.stack.push(layer)
              }
              return this
          }
      })
      Route.prototype.dispatch = function(req,res,out){
          let idx = 0,self = this
          function next(err){
              if(err) return out(err)
              if(idx >= self.stack.length){
                   return out()
              }
              let layer = self.stack[idx++]
              if(layer.method == req.method.toLowerCase()){
                  layer.handler_request(req,ers,next)
              }else{
                  next()
              }
          }
          next()
      }
      module.exports = Route
      
      
      //layer.js
      function Layer(path,handler){
          this.path = path
          this.handler = handler
      }
      //判断传入的路径是否一致
      Layer.prototype.match = function(path){
          return this.path == path
      }
      Layer.prototype.handler_request = function(req,res,next){
          this.handler(req,res,next)
      }
      Layer.prototype.handler_err = function(err,req,res,next){
          if(this.handler.length != 4){
              return next()
          }
          this.hanlder(req,res,next)
      }
      module.exports = Layer
      
      //application.js
      //实现router和应用的分离
      const Router = require('./router')
      const http = require('http')
      const methods = require('methods')
      const slice = Array.prototype.slice()
      function Application(){
          
      }
      Application.prototype.lazyrouter = function(){
          if(!this._router){
              this._router = new Router()
          }
      }
      methods.forEach(function(method){
          Application.prototype[method] = function(){
              this.lazyouter()
          	this._router[method].apply(this._router,slice.call(arguments))
          }
          return this
      })
      Application.prototype.listen = function(){
          let self = this
          let server = http.createServer(function(req,res){
              function done(){
                  //如果没有路由规则
                  res.end('cannot ${req.method}${req.url}')
              }
              //路由无法处理即没有匹配到 把请求交给done
              self._router.handler(req,res,done)
          })
          server.listen(...arguments)
      }
      module.exports = Application
      
      
      //express.js
      const http =  require('http')
      const url = requre('url')
      const Application = require('./application')
      function createApplication(){
          return new Application()
      }
      module.exports = createApplication
      ```

   3. 实现中间件

      - application中添加use方法
      - Router变函数
      - 抽象出Router方便复用
      - Router处理中间件

      ```js
      //测试用例
      const express = require('../')
      const app = express()
      app.use(function(req,res,next){
          console.log('ware1',Date.now())
          next('wrong')
      })
      app.get('/',function(req,res,next){
          res.end(1)
      })
      //创建一个新的路由容器 二级路由
      const user = express.Router()
      //use表示使用中间件只要匹配前缀就好
      user.use(function(req,res,next){
          console.log('ware2',Date.now())
          next()
      })
      user.use('/2',function(req,res,next){
          res.end('2')
      })
      app.use('/use',user)
      app.use(function(err,res,next){
          res.end('catch':+err)
      })
      app.listen(3000,function(){
          console.log('server start')
      })
      ```

      实现

      ```js
      //index.js
      const Route = require('./route')
      const Layer = require('./layer')
      const url = require('url')
      const methods = require('methods')
      const slice = Array.prototype.slice()
      function Router(){
          function router(req,res,next){
              router.handle()
          }
          Object.setPrototypeOf(router,proto)
          router.stack = []
          return router
      }
      let proto = Object.create(null)
      //创建一个router实例，向当前路由系统中添加一个层
      proto.route = function(path){
          let route = new Route(path)
          let layer = new Layer(path,route.dispatch.bind(route))
          layer.route = route
          this.stack.push(layer)
          return toute
      }
      proto.use = function(path,handler){
          if(typeof handler != 'function'){
              handler = path
              path = '/'
          }
          let layer = new Layer(path,handler)
          layer.route = undefined //通过layer有没有route来判断是中间件还是路由
          this.stack.push(layer)
      }
      methods.forEach(function(method){
          proto[method] = function(path){
              let route = this.route(path)
          	route.get(handler)
              route[method].apply(route,slice.call(arguments,1))
          }
          return this
      })
      //处理中间件 处理子路由
      proto.handle = function(req,res,out){
          //slashAdd是否添加过'/'' remove被移除的字符串
          let idx = 0, self = this，slashAdd = false,remove = ''
          let {pathname} = url.parse(req.url,true)
          function next(err){
              if(removed.length>0){
                  req.url = removed + req.url
                  removed = ''
              }
              if(idx >= self.stack.length){
                  return out()
              }
              let layer = self.stack[idx++]
              if(layer.match(pathname)){
                  if(!layer.route){
                      //中间件
                      let removed = layer.path
                      req.url = req.url.slice(removed.length)
                      if(err){
                          layer.handler_err(err,req,res,next)
                      }else{
                          layer.handler_request(req,res,next)
                      }
                  }else{
                     if(layer.route && layer.route.handle_method(req.method)){
                         layer.handler_request(req,res,next)
                        }else{
                         next(err)
                     } 
                  }
              }else{
                  next(err)
              }
          }
      }
      module.exports = Router
      
      //layer.js
      function Layer(path,handler){
          this.path = path
          this.handler = handler
      }
      //判断传入的路径是否一致
      Layer.prototype.match = function(path){
          if(this.path == path){
              return true
          }
          if(!this.route){
              return path.startWith(this.path+'/')
          }
          return false
      }
      Layer.prototype.handler_request = function(req,res,next){
          this.handler(req,res,next)
      }
      Layer.prototype.handler_err = function(err,req,res,next){
          if(this.handler.length != 4){
              return next(err)
          }
          this.hanlder(req,res,next)
      }
      module.exports = Layer
      
      //application.js
      //实现router和应用的分离
      const Router = require('./router')
      const http = require('http')
      const methods = require('methods')
      const slice = Array.prototype.slice()
      function Application(){
          
      }
      Application.prototype.lazyrouter = function(){
          if(!this._router){
              this._router = new Router()
          }
      }
      methods.forEach(function(method){
          Application.prototype[method] = function(){
              this.lazyouter()
          	this._router[method].apply(this._router,slice.call(arguments))
          }
          return this
      })
      //添加中间件 中间件和普通路由在一个数组
      Application.prototype.use = function(){
          this.lazyrouter()
          this._router.use.apply(this._router,qrguments)
      }
      Application.prototype.listen = function(){
          let self = this
          let server = http.createServer(function(req,res){
              function done(){
                  //如果没有路由规则
                  res.end('cannot ${req.method}${req.url}')
              }
              //路由无法处理即没有匹配到 把请求交给done
              self._router.handler(req,res,done)
          })
          server.listen(...arguments)
      }
      module.exports = Application
      
      
      
      //express.js
      const http =  require('http')
      const url = require('url')
      const Router = require('./router')
      const Application = require('./application')
      function createApplication(){
          return new Application()
      }
      createApplication.Router = Router
      module.exports = createApplication
      ```

   4. req.params

      ce

      ```js
      //测试用例
      const express = require('../')
      const app = express()
      app.param('uid',function(req,res,next,val,name){
          req.user = {id:1,name:'test'}
          next()
      })
      app.param('uid',function(req,res,next,val,name){
          req.user.name = 'test2'
          next()
      })
      app.get('/user/:uid',function(req,res){
          console.log(req.user)
          res.end('user')
      })
      app.listen(3000)
      ```

      实现

      ```js
      //application.js
      Application.prototype.param = function(name,handler){
          this.lazyrouter()
          this._router.param.apply(this._router,arguments)
      }
      
      
      //index.js
      proto.param = function(name,handler){
          
      }
      
      ```

      

   5. 模板引擎

      ```js
      //tmpl.js
      let str = `
      <%if(user){%>i
      	hello user
      <%}else{%
      	helloguest
      <%}%>
      <ul>
      <%for(let i=0;i<total;i++){%>
      	<li><%=i%></li>
      <%}%>
      </ul>
      `
      let options = {user:{name:'test'},total:5}
      let ejs = require('ejs')
      function render(str,options,callback){
          let head = "let tpl = '';\nwith(obj){\n tpl+=`"
          str = str.replace(/<%([\s\S]+?)%>/g,function(){
              return "`;\n"+arguments[1]+"\n;tpl+=`"
          })
          let tail = "`}\nreturn tpl;"
          let html = head + str + tail
          let fn = new Function('obj',html)
          let result = fn(options)
          callback(null,result)
      }
      let result = render(str,options)
      
      //template.js
      const express = require('../lib/express')
      const path = require('path')
      const html = require('../lib/html')
      const app = express()
      const fs = require('fs')
      
      //views用来设置存放模板目录
      app.set('views',path.resolve('views'))
      //设置模板引擎如果render的没有指定模板后缀名，会以这个作为后缀名
      app.set('view engine','html')
      //遇到html结尾时用html渲染
      app.enginer('.html',require('ejs')._express)
      app.use(function(req,res,next){
          res.render = function(name,options){
              let ext = '.'+app.get('view engine')
              name = name.indexOf('.') != -1? name:name+ext
              let filepath = path.join(app.get('views'),name)
              let render = app.engines[ext]
              function done(err,html){
                  res.setHeader('Content-Type','text/html')
                  res.end(html)
              }
              render(filepath,options,done)
          }
      })
      ```

2. 模板应用

   - 安装ejs
   - 设置模板
   - 渲染html
   - 渲染视图
   - 模板实现

3. 静态文件服务器

4. 重定向

   - redirect使用
   - redirect实现

5. 接受post响应体

6. static中间件

   `express.static(root,[options])`

   express.static是express内置唯一一个中间件。基于serve-static开发，负责托管Express应用内的静态资源

   - root静态文件的根目录

   - options可选支持

     | 属性         | 描述                                            | 类型     | 默认值     |
     | ------------ | ----------------------------------------------- | -------- | ---------- |
     | dotdiles     | 控制点文件服务，可选值为allow,deny,ignore       | string   | ignore     |
     | etag         | 控制etag生成                                    | boolean  | true       |
     | extensions   | 社招文件后缀名补充                              | boolean  | false      |
     | index        | 设置目录访问的返回，false为禁止访问             | mixed    | index.html |
     | lastModified | 根据文件修改时间设置Last-Modified报头           | boolean  | true       |
     | maxAge       | 设置Cache-control报头的缓存控制时间，单位为毫秒 | number   | 0          |
     | redirect     | 当路径是目录时重定向到包含结尾的目录            | boolean  | true       |
     | setHeaders   | 函数用于为文件设置http头                        | function |            |

     使用
     
     ```js
     let express = require('express')
     let path = require('path')
     let app = express()
     app.use(express.static(path.join(_dirname,'public')))
     app.listen(8080)
     ```
     
     原理
     
     ```js
     //中间件会拦截客户端请求，去静态文件根目录下找有没有对应文件 有的话返回给客户端 没有next()
     function static(root,options={}){
         //所有的中间件都是一个方法 调用方法得到中间件函数
         let {dotfiles = 'ignore',etag = true,lastModified=true,maxAge=0} = options
         return function(req,res,next){
             let {pathname} = url.parse(req.url,true)
         	let file = path.join(root,pathname)
             let parts = file.split(path.sep)
             let isDotFile = parts[parts.length -1][0] == '.'
             if(isDotFile && dotfiles == 'deny'){
                 //拒绝访问.的隐藏文件
                 res.setHeader('Content-Type','text/html')
                 res.statusCode = 403
                 return res.end(http.STATUS_CODES[403])
             }
         	fs.stat(file,function(err,stat){
            	 if(err){
                	 next()
            	 }else{
                 	let contneType = mime.getType(pathname)
                	 res.setHeader('Content-Type',contentType)
                  if(etag){
                      res.setHeader('ETag',stat.mtime.toLocalDateString())
                  }
                  if(lastModified){
                      res.setHeader('Last-Modified',stat.mtime.toUTCString())
                  }
                  res.setHeader('Cache-Control',`max-age=${maxAge}`)
                	 fs.createReadStream(file).pipe(res)
           	  }
         	})
         }
     }
     ```
     
     

7. body-parse中间件

   body-parse是对post请求进行解析

   ```js
   app.use(bodyParser.json()) //处理json请求体
   app.use(bodyParser.unlencoded({extended:false})) //处理表单格式请求体
   ```

   - http报文头

     ```js
     POST / HTTP/1.1
     Host: 127.0.0.1:8080
     Content-Type:text/html;charset=utf8
     content-Encoding:gzip
     test
     ```

     - content-type 请求报文猪蹄的类型编码 常见类型有text/plain、application/json、application/www-form-urlencoded
     - content-encoding 声明报文主体的压缩格式 gzip、deflate、identity

     ```js
     //unrlencoded实现
     const queryString = require('querystring')
     const qs = require('qs')
     function urlencoded(options){
         let {extend} = options
         return function(req,res,next){
             let contentType = req.headers['content-type']
             if(contentType == 'application/www-form-urlencoded'){
                 let buffers = []
             	req.on('data',function(data){
                	 	buffers.push(data)
            		 })
             	req.on('end',function(){
                 	let result = buffers.toString()
                     if(extended){
                         //qs可以支持嵌套对象
                         req.body = qs.parse(result)
                     }else{
                         req.body = qsstring.parse(result)
                     }
             	})
             }else{
                 next()
             } 
         }
     }
     ```

   - body-parse工作

     - 处理不同类型的请求体 eg:text、json、urlencoded等
     - 处理不同的编码
     - 处理不同的压缩类型

   - 处理内容类型

     - 处理text/plain

       ```js
       //测试
       let http = require('http')
       let options = {
           hostname:'127.0.0.1',
           port:'3000',
           path:'/',
           method:'POST',
           headers:{
               'Content-Type':'text/plain',
               'Content-Encoding':'identity'
           }
       }
       let client = http.request(options,(res)=>{
           res.pipe(process.stdout)
       })
       client.end('test')
       ```

       ```js
       //实现
        let http = require('http')
        let parse = function(req,done){
            let arr = []
            req.on('data',data=>arr.push(data))
            req.on('end',()=>{
                let sresult = Bufer.concat(arr)
                done(result)
            })
        }
        let server = http.createServer(function(req,res){
            parse(req,(chunks)=>{
                res.end(chunks)
            })
        })
        server.listen(3000)
       ```

     - 处理application/json

       ```js
       'Content-Type':'application/json'
       client.end(JSON.stringify({name:test}))
       
       let json = JSON.parse(chunks.toString())
       ```

     - 处理application/x-www-form-urlencoded

       ```js
       'Content-Type':'form/x-www-form-urlencoded'
       client.end(querystring.stringify({name:test}))
       
       let body = querystring(chunks.toString())
       ```

   - 处理不同编码

     ```js
     let iconv = require('iconv-lite')
     let encoding = 'gbk'
     'Content-Type':'text/plain;charset='+encoding
     let buff = iconv.encode('test',encoding)
     
     let contentType = require('content-type')
     let obj = contenType.parse(req.headers['content-type'])
     let charset = obj.parameters.charset
     let body = iconv.decode(chunks,charset)
     ```

   - 处理不同压缩类型

     ```js
     let zlib = require('zlib')
     'Content-Encoding':'gzip'
     let buff = zlib.gzipSync('test')
     client.end(buff)
     
     let contentEncoding = req.headers['content-encoding']
     if(contentEncoding == 'gzip'){
         stream = zlib.creatrGunzip()
         req.pipe(stream)
     }
     ```

   - multipart/form-data

#### cookie

1. cookie介绍

   http1.0协议是无状态的 cookie是为看辨别用户身份进行会话跟踪而存储在客户端上的数据

2. cookie处理流程

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\cookies.png)

3. 使用

   ```js
   let http = require('http')
   let server = http.creareServer(function(req,res){
       if(req.url == '/write'){
           res.setHeader('Set-Cookie','name=test')
           res.end('ok')
       }else if(req.url == '/read'){
           let cookie = req.headers['cookie']
           res.end(cookie)
       }else{
           res.end('404')
       }
   }).listen(8080)
   
   
   //express中使用cookie
   const express = require('express')
   const app = express()
   const cookieParser = require('cookie-parser')
   app.use(cookieParser())
   app.get('/write',function(req,res){
       res.cookie('name','test')
       //res.cookie('name','test',{signed:true}) 加密
       res.end('ok')
   })
   app.get('/read',function(req,res){
       //let cookie = req.headers['cookie']
       res.send(req.cookies)
   })
   qpp.listen(8080)
   ```

   

   - 客户端第一次访问服务器时服务器通过响应头向客户端发送cookie 属性之间同分号空格分隔

     `Set-Cookie:name=test;`

   - 客户端接收到cookie后保存在本地

   - 客户端再请求服务器的时候会把cookie发送到服务器端

4. 属性

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\cookie属性.png)

   - name=value 键值对可以设置保存的key/value

   - domain 默认当前域名
   - path 表示cookie影响到的路由
   - expires/maxAge expires相对时间 maxage绝对时间
   - size
   - httpOnly 设置httpOnly属性后通过程序无法读取到cookie信息防止xss攻击产生 
   - secure 当secure为true时 在http中无效

5. 向客户端发送cookie

   ```js
   //1.设置cookie
   res.cookie(name,value,[options])
   ```

6. 获取cookie

   使用cookie-parse中间件 `npm i cookie-parser --save`

   ```js
   app.use(require('cookie-parser')) //使用中间件
   response.cookie(key,value) //在响应头向客户端设置cookie
   request.cookies //获取请求中的cookie对象
   response.clearCookie('username') //清除cookie
   ```

7. 记录客户端访问次数

   ```js
   let express = require('express')
   let cookieParser = require('cookie-parser')
   //加密时cookieParser要指定密码 设置signed等于true
   let app = express()
   app.use(cookieParser('test'))
   app.get('/write',function(req,res){
       //普通设置
       res.cookie('name','value')
       //设置域名
       res.cookie('name','test',{domain:'test.com'})
       //设置路径
       res.cookie('name','test',{path:'/visit'})
       //过期时间
       res.cookie('name','test',{expires:new Date(Date.now()+20*1000)})
       res.cookie('name','test',{MaxAge:20*1000})
       //httponly
       res.cookie('name','test',{httpOnly:true})
       res.cookie('age','11',{signed:true})
       res.end('ok')
   })
   app.get('/read',function(req,res){
       console.log(req.signedCookies)
       res.send(req.cookies)
   })
   //记录是客户端第几次访问
   qpp.get('/visit',function(req,res){
       res.cookie('count',isNaN(req.cookies.count)? 0 : parseInt(req.cookies.count)+1)
       res.send(req.cookies)
   })
   qpp.listen(8080)
   ```

8. 原理

   ```js
   res.secret = 'test'
   function cookieParser(req,res,next){
       if(!req.headers.cookie){
           return next()
       }
       req.cookies = require('querystring').parse(req.headers.cookie,';','=')
       if(req.secret){
           req.signedCookies = {}
           for(let attr in req.cookies){
               let val = req.cookies[attr]
               req.signedCookies[attr] = unsign(val,req.secret)
           }
       }
       next()
   }
   function cookie(name,val,options){
       var opt = options || {}
       if(req.secret){
           val = sign(val,secret)
       }
       var value = encodeURIComponent(val)
       var pairs = [name + '=' + value]
       if(null != opt.maxAge){
           var maxAge = opt.maxAge -0
           if(isNaN(maxAge)) throw Error('maxAge should be a Number')
           pairs.push('Max-Age='+Math.floor(maxAge))
       }
       if(opt.domain) pairs.push('Domain='+opt.domain)
       if(opt.path) pairs.push('Path='+opt.path)
       if(opt.expires) pairs.push('Expires=' +opt.expires.toUTCString())
       if(opt.httpOnly) pairs.push('httpOnly')
       if(opt.secure)  pairs.push('Secure')
       return pairs.join('; ')
   }
   var crypto = require('crypto')
   export.sign = function(val,secret){
       return val + '.' +crypto
       		.createHmac('test',secret)
       		.update(val)
       		.digest('base64')
       		.replace(/\=+$/,'')
   }
   export.unsign = function(cal,secret){
       var str = val.slice(0,val.lastIndexOf('.')), mac = exports.sign(str,secret)
       return mac == val?str:false
   }
   ```

9. 权限控制

   ```js
   //cookie.js
   
   let express = require('express')
   let path = require('path')
   let bodyPaser = require('body-parser')
   let cookieParser = require('cookie-parser')
   let app = express()
   app.use(bodyParser.urlencoded({extended:true}))
   app.use(cookieParser)
   app.set('view engine','html')
   app.set('views',path.join(_dirname,'views'))
   app.engine('html',require('ejs')._express)
   app.get('/login',function(req,res){
       res.render('login',{title:'登录'})
   })
   function checkLogin(req,res,next){
       //判断用户是否登录
       if(req.cookies.username){
           next()
       }else{
           res.redirect('/login')
       }
   }
   app.post('/login',function(req,res){
       let user = req.body
       if(user.username == '1' && user.password == '1'){
           res.cookie('username',user.username)
           res.redirect('/user')
       }else{
           res.redirect('back')
       }
   })
   app.get('/user',checkLogin,function(){
       let {username} = req.cookies
       res.render('user',{title:'登录'})
   })
   app.listen(8080)
   ```

10. 注意事项

    - 可能会被用户端篡改使用前验证合法性
    - 不要存放敏感数据
    - 使用httpOnly保证安全
    - 尽量减小cookie的体积
    - 设置正确的domain和path减少数据传输

#### session

sessions是另一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，session保存在服务器上

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只要从session中查找该客户的状态就可以。

1. cookie与session的区别

   - cookie数据存放在客户浏览器上，session存在服务器上
   - cookie不是很安全容易被篡改，session更安全
   - session绘制一定时间保存在服务器上，当访问增多会比较占用服务器的性能，考虑减轻服务器性能方面应该使用、cookie
   - 单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie

2. session实现

   - 在服务器端生成一个全局唯一标识符session_id
   - 在服务器内存里开辟此session_id对应的数据存储空间
   - 将session_id作为全局唯一标识符通过cookie发送给客户端
   - 客户端再次访问服务器会把session_id通过请求头中的cookie发送给服务器
   - 服务器通过session_id把此标识符在服务器端数据取出

   ```js
   const express = require('express')
   const cookieParser = require('cookie-parser')
   //生成一个唯一的不重复id
   const uuid = require('uuid')
   const app = express()
   //key是服务器向客户端写卡号时的name
   const SESSION_KEY = 'connect.sid'
   const sessions = {}
   app.get('/',function(req,res){
       let sessionId = req.cookies[SESSION_KEY]
       if(sessionId){
           let sessionObj = sessions[sessionId]
           if(sessionObj){
               sessionObj.balance -= 10
               res.send('success')
           }else{
               reg()
           }
       }else{
           reg()
       }
       function reg(){
           //id唯一 
           let sessionId = uuid.v4()
           sessions[sessionId] = {blance:200}
           res.cookie(SESSION_KEY,sessionId)
           res.send('reg success')
       }
   })
   app.listen(8080)
   ```

3. session中间件

   ```js
   const express = require('express')
   const session = require('express-session')
   const app = express()
   app.use(session{
      resave:true,
      saveUninitialized:true,
      secret:'test'   
   })
   app.listen(8080)
   ```

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\session.png)

4. 自定义存储位置

   ```js
   //测试用例
   const express = require('express')
   const session = require('express-session')
   const path = require('path')
   const FileStore = require('./filestore')(session)
   const app = express()
   app.use(session{
      resave:true,
      saveUninitialized:true,
      secret:'test',
      store:new FileStore({
           root:path.join(_dirname,'sessions')
   		maxAge:1000,
           gc: 1
      })
   })
   app.get('/visit',function(req,res){
       let visit = req.session.visit
       if(visit){
           visit = visit +1
       }else{
           visit = 1
       }
       req.session.visit = visit
       res.send('ok')
   })
   app.listen(8080)
   
   
   //实现
   let util = require('util')
   let mkdirp = require('mkdirp')
   let fs = require('fs')
   let path = require('path')
   module.exports = function (session){
       util.inherits(FileStore,session.Store)
       function FileStore(options){
           this.root = options.root
           this.maxAge = options.maxAge || 0
           this._gc = options.gc || 0.1
           mkdirp.sync(this.root)
       }
       FileStore.prototype.resolve = function(sid){
           return path.join(this.root,sid + '.json')
       }
       FileStore.prototype.get = function(sid,callback){
           fs.readFile(this.resolve(sid),'utf8',function(err,data){
               if(err) return callback(err)
               data = JSON.parse(data)
               callback(null,data)
           })
           if(this.needGc()) this._startGc()
       }
       FileStore.prototype.needGc = function(){
           return (1/this._gc) = Math.random <= 1
       }
       FileStore.prototype._startGc = function(){
           let self = this
           fs.readdir(this.root,(err,files) => {
               let ts = Date.now() =self._maxAge
               Promise.all(file.map((file)=>{
                   fs.stat(path.join(self.root,file),(err,stat){
                         console.log(stat.mtime.getTime(),ts-stat.mtime.getTime(),stat.mtime.getTime()<ts)
                   if(stat.mtime.getTime() < ts){
                       fs.unlink(path.join(self.root,file),relove)
                   }else{
                       resolve()
                   }
                           
                   })
               })).then(()=>{console.log('完成清理')})
           })
       }
   }
   ```

5. session实现权限

6. 自动登录

#### 仿cli工具

1. 创建项目

   ```js
   mkdir vue-auto-router-cli
   cd vue-auto-router-cli
   //初始化npm包
   npm init -y
   //安装需要的npm库
   npm i commander download-git-repo ora handlebars figlet clear chalk open -s
   ```

   ```js
   // --bin/routercli.js
   //指定脚本解释器为node
   #!/usr/bin/env node
   console.log('cli.....')
   // --修改package.json
   "bin": {
       //npm 输入routercli时执行routercli.js
    "routercli": "./bin/routercli.js"
   },
   // 将npm 将一个任意位置的 npm 包链接到全局执行环境，从而在任意位置使用命令行都可以直接运行该 npm 包 
   npm link
   // 删除的情况
   ls /usr/local/bin/
   rm /usr/local/bin/routercli
   ```

2. 定制命令行界面

   ```js
   //routercli.js
   #!/usr/bin/env node
   const program = require('commander')
   // routercli -v 实现
   program.version(require('../package').version)
   program
   	// 初始化项目命令
    .command('init <name>')
   	//项目描述
    .description('init project')
   	//执行init后执行的操作
    .action(name => {
    	console.log('init ' + name)
   	})
   program.parse(process.argv)
   ```

3. 打印欢迎页面

   ```js
   //lib/init.js
   const {promisify} = require('util')
   // figlet 是基于ASCII字符组成的字符画
   const figlet = promisify(require('figlet'))
   //清空命令行面板
   const clear = require('clear')
   //更改命令行日志颜色
   const chalk = require('chalk')
   const log = content =>console.log(chalk.green(content))
   module.exports = async name => {
    // 打印欢迎界面
    clear()
    const data = await figlet('routercli Welcome')
    log(data) 
   }
   //修改 bin/routercli.js
   program
    .command('init <name>')
    .description('init project')
    .action(require('../lib/init'))
   ```

4. 克隆脚手架

   ```js
   // ./lib/download.js
   const {promisify} = require('util')
   module.exports.clone = async function(repo,desc) {
    	//download-git-repo从git下载仓库
       const download = promisify(require('download-git-repo'))
       //下载进度条
    	const ora = require('ora')
    	const process = ora(`下载.....${repo}`)
    	process.start()
    	await download(repo, desc)
    	process.succeed()
   }
   
   //./lib/init.js
   const {clone} = require('./download')
   module.exports.init = async name => {
    // 打印日志
    log(' !创建项⽬:' + name)
    // 从github克隆项⽬到指定⽂件夹
    await clone('github:su37josephxia/vue-template', name)
   }
   ```

5. 安装依赖

   ```js
   // bin/routercli.js
   // 对接输出流
   const spawn = async (...args) => {
       //获取子进程
    	const { spawn } = require('child_process');
    	return new Promise(resolve => {
           //proc为子进程
    		const proc = spawn(...args)
    		proc.stdout.pipe(process.stdout)
   		proc.stderr.pipe(process.stderr)
   		proc.on('close', () => {resolve()})
    	})
   }
   module.exports.init = async name => {
    // ....
    log('安装依赖')
    await spawn('cnpm', ['install'], { cwd: `./${name}` })
    log(chalk.green(` "
   	安装完成：
   	To get Start:
   	===========================
   	 cd ${name}
   	 npm run serve
   	===========================
    `))
   }
   ```

6. 启动项目

   ```js
   const open = require("open")
   module.exports.init = async name => {
    // 打开浏览器
    open(`http://localhost:8080`);
    await spawn('npm', ['run', 'serve'], { cwd: `./${name}` })
   }
   ```

7. 路由功能

   ```js
   // ../lib/refresh.js
   const fs = require('fs')
   const handlebars = require('handlebars')
   const chalk = require('chalk')
   module.exports = async () => {
       // 获取⻚⾯列表
    const list = fs.readdirSync('./src/views')
    				.filter(v => v !== 'Home.vue')
    				.map(v => ({
    					name: v.replace('.vue', '').toLowerCase(),
    					file: v
    				}))
    // ⽣成路由定义
    compile({list}, './src/router.js', './template/router.js.hbs')
    // ⽣成菜单
    compile({list}, './src/App.vue', './template/App.vue.hbs')
    /**
    * 编译模板⽂件
    * @param meta 数据定义
    * @param filePath ⽬标⽂件路径
    * @param templatePath 模板⽂件路径
    */
    function compile(meta, filePath, templatePath) {
        //判断模板文件是否存在
    	if (fs.existsSync(templatePath)) {
    		const content = fs.readFileSync(templatePath).toString();
    		const result = handlebars.compile(content)(meta);
   		fs.writeFileSync(filePath, result);
    	}
   	 console.log(chalk.green(`${filePath} 创建成功`))
    }
   }
   
   // ../bin/routercli.js
   program
    .command('refresh')
    .description('refresh routers...')
    .action(require('../lib/refresh'))
   ```

8. 发布npm包

   ```js
   #!/usr/bin/env bash
   npm config get registry // 检查仓库镜像库
   npm config set registry=http://registry.npmjs.org
   echo '请进⾏登录相关操作：'
   npm login // 登录
   echo "-------publishing-------"
   npm publish // 发布
   npm config set registry=https://registry.npm.taobao.org # 设置为淘宝镜像
   echo "发布完成"
   exit
   ```

#### koa

1. 安装 `npm i koa`

2. 应用程序

   ```js
   const Koa = require('koa')
   const app = new Koa()
   //koa推荐使用async
   //ctx context是koa提供的一个对象 包括一些常见的方法
   app.use(async ctx =>{
       ctx.body = 'hello'
   })
   app.on('error',err=>{
       log.error('server error',err)
   })
   app.listen(8080)
   ```

   koa应用程序是一个包含一组中间件函数的对象，按照类堆栈的方式组织和执行

3. 级联中间件

   koa中间件以更传统的方式级联

4. 上下文context

   

5. 获取请求参数

   ```js
   const Koa = require('koa')
   const app = new Koa()
    
   app.use(function(ctx,next){
       console.log(ctx.method) //获取请求方法
       console.log(ctx.url) //获取请求url
       console.log(ctx.headers) //获取请求头对象
       console.log(ctx.querystring)  //查询响应字符串
       console.log(ctx.query)  //查询响应对象
       
       //res.en res.write不能直接使用
       //ctx.res.write() koa不能直接使用写入响应体
       ctx.body = ctx.header
       ctx.response.body = ctx.headers
       //body值可以为 字符串 buffer 对象 流
   })
   app.listen(8080)
   ```

6. 获取请求体

   ```js
   const Koa = require('koa')
   const app = new Koa()
   const querysting = require('querystring')
   app.use(async (ctx)=>{
       if(ctx.method == 'GET'){
           ctx.set('Content-Type','text/html;charset=utf-8')
           ctx.body = {
               `
   			<form method = 'POST'>
   				<input name='username'>
   				<input type='submit'>
   			</form>	
   			`
           }else if(ctx.method == 'POST'){
               ctx.set('Content-Type','application/json')
               ctx.body = await parseBody(ctx)
           }else {
               ctx.body = 'not allowed'
           }
       }
   })
   function parseBody(ctx){
       return new Promise(function(reslove,reject){
           let buffers = []
           ctx.req.on('data',function(data){
               bufferd.push(data)
           })
           ctx.req.on('end',function(data){
               let body = bufferd.toString()
               body = querystring.parse(body)
               resolve(body)
           })
           ctx.req.on('error',function(err){
               reject(err)
           })
       })
   }
   app.listen(8080)
   ```

7. 使用中间件获取请求体

   安装中间件 `npm i koa-bodyparser -s` 

   ```js
   const Koa = require('koa')
   const app = new Koa()
   const bodyParser = require('koa-bodyparser')
   
   app.use(bodyParser())
   app.use(async funcyion(ctx,next){
       if(ctx.url == '/user' && ctx.method == 'POST'){
       	//使用bodyparser中间件后 请求访问时会解析请求体赋值个ctx.request.body
       	ctx.body = ctx.request.body
   	}else{
           await next()
       }    
   })
   
   app.listen(8080)
   ```

8. 使用中间件获取包含文件的请求体

   上传文件时express使用multer中间件，koa里要用koa-better-body

   ```js
   const Koa = require('koa')
   const app = new Koa()
   const path = require('path')
   //把generatorz中间件转为koa2中间件
   const convert = require('koa-convert')
   const bodyParser = require('koa-better-body')
   //上传文件时 指定上传目录
   app.use(convert(bodyParser({
       uploadDir:path.join(_dirname,'uploads'),
       keepExtensions:true
   })))
   app.use(async funcyion(ctx,next){
       if(ctx.url == '/user' && ctx.method == 'GET'){
       	ctx.set('Content-Type','text/html;charset=utf-8')
           ctx.body = {
               //给表单上传文件需要给form增加entype='multipart/form-data'
               `
   			<form method = 'POST' entype='multipart/form-data'>
   				<input name='username'>
   				<input type = 'file' name='avatar'>
   				<input type='submit'>
   			</form>	
   			`
           }
   	}else{
           await next()
       }        
   })        
   app.use(async funcyion(ctx,next){
       if(ctx.url == '/user' && ctx.method == 'POST'){
       	//firlds是字段
       	ctx.body = ctx.request.fields
   	}else{
           await next()
       }    
   })
   app.listen(8080)
   ```

   koa-better-body原理

   ```js
   app.use(async funcyion(ctx,next){
       if(ctx.url == '/user' && ctx.method == 'POST'){
       	let contenetType = ctx.headers['content-type']
           if(contenetType.includes('multipart')){ 
               let maches = contentType.match(/\bboundary=(.+)/)
               let sep = '--' + matches[1] //获取请求体分隔符
               ctx.body = await getBody(ctx.req,sep)
               
               
           }else{
               next()
           }
   	}else{
           await next()
       }    
   })
   function getBody(req,seq){
       return new Promise(function(resolvw,reject){
           let buffers = []
           req.on('data',function(data){
               buffers.push(data)
           })
           req.on('end',function(){
               let all = Buffer.concat(buffers)
               let fields = {}
               let lines = all.split(seq)
               lines = lines.slice(1,-1)
               lines.forEach(function(line){
                   let [desc,val] = line.split('\r\n')
                   desc = desc.toString()
                   val = val.slice(0,-2) //去掉尾部\r\n
                   if(desc.includes('filename')){
                       let [,line1,line2] = desc.split(\r\n)
                       let lineObj1 = querystring.parse(line1,';')
                       let lineObj2 = querystring.parse(line2,';')
                       let filepath = path.join(_dirname,'uploads',uuid.v4())
                       fs.writeFileSync(filepath,val)
                       fields[lineObj1.name] = [{...lineObj1,...lineObj2,filepath}]
                                                      
                   }else{
                       let name = querystring.parse(desc,';').name.replace(/"/g,'')
                       fields[name] = val.toString()
                   }
               })
               resolve(fields)
           })
       })
   }
   Buffer.prototype.split= function(sep){
       let pos = 0 //记录开始查找的索引
       let len = sep.length
       let index = -1 //查找到的分割子串所在索引
       let parts = []
       while(-1 !=(index = this.indexOf(sep,pos))){
           parts.push(this.slice(pos,index))
           pos = index + len
       }
       parts.push(this.slice(pos))
       return parts
   }
   ```

9. 路由中间件

   安装 `npm install --save koa-router`

   单级路由

   ```js
   const koa = require('koa')
   const Router = require('koa-router')
   const app = new koa()
   
   let user = new Router()
   user.get('/user',function(ctx){
       ctx.body = 'get user'
   }).get('/query/:id',function(ctx){
       ctx.body = ctx.params
   }).post('/user',function(ctx){
       ctx.body = 'post user'
   }).get('/home',function(ctx){
       ctx.body = 'get home'
   })
   app.use(user.routes())
   app.listen(8080)
   ```

   多级路由

   ```js
   let user = new Router()
   user.get('/add',function(ctx){
       ctx.body = 'get user add'
   })
   let article = new Router()
   user.get('/article',function(ctx){
       ctx.body = 'get article add'
   })
   let router = new Router()
   router.use('/user',user.routes())
   router.usr('/article',article.routes)
   app.use(router.routes())
   ```

10. cookie

    - ctx.cookies.get(name,[options])读取上下文请求中的cookie

    - ctx.cookies.set(name,value,[options])在上下文中写入cookie

      options参数

      - domain cookie所在域名
      - path cookie所在路径
      - maxAge 最大有效时长
      - expires 失效时间
      - httpOnly是否只用http请求中获得
      - overwrite是否允许重写

    ```js
    qpp.use(async (ctx,next)=>{
        if(ctx.url == '/write'){
            ctx.cookies.set('name','zfpx')
            ctx.body = 'write'
        }else{
            next()
        }
    })
    qpp.use(async (ctx)=>{
        if(ctx.url == '/resd'){
            ctx.body = ctx.cookies.get('name')
        }
    })
    ```

11. session

    安装 `npm i  koa-session`

    ```js
    const Koa = require('koa')
    const session = require('koa-session')
    const app = new Koa()
    app.keys = 'test'
    app.use(session(),app)
    app.use(async (ctx)=>{
        let visit = ctx.session.visit
        if(visit){
            visit+=1
        }else{
            visit = 1
        }
        ctx.session.visit = visit
        ctx.body = `这是你的第${visit}次访问`
    })
    app.listen(8080)
    ```

12. 模板引擎

    安装`npm i koa-views ejs -s`

    ```js
    const Koa = require('koa')
    const views = require('koa-views')
    const path = require('path')
    const app = new Koa()
    app.use(views(path.join(_dirname,'./views'),{
        extensions:'ejs'
    }))
    app.use(async ctx =>{
        await ctx.reander('index',{name:'测试'})
    })
    app.listen(3000)
    ```

13. 静态资源中间件

    安装`npm i --save koa-static`

    ```js
    const static = require('koa-static')
    const app = new Koa()
    app.use(static(path.join(_dirname,'public')))
    app.use(async (ctx)=>{
        ctx.body = 'not found'
    })
    ```

14. koa实现

    ```js
    class Koa{
        constructor(){
            this.middleware = []
        }
        use(fn){
            this.middleware.push(fn)
        }
        listen(port){
            let middleware = this.middleware
            require('http').createSever((req,res)=>{
                let ctx = {req,res}
                /*koa1.0
                next(0)
                function next(idx){
                    middleware[idx](ctx,()=>next(idx+1))
                }*/
                //koa2.0
                (middleware.reduceRight((val,item)=>{
                    return item.bind(null,ctx,val)
                },function(){}))()
            }).listen(port)
        }
    }
    ```

15. generator

16. form-data

#### sokect实现



## 移动端布局

#### 屏幕尺寸与像素

https://mp.weixin.qq.com/s/y2kzv5S2TvkMwgwZPbSyKA

1. 手机屏幕尺寸

   手机屏幕尺寸是指屏幕对角线尺寸

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\手机尺寸.jpg)

2. 手机屏幕分辨率

   手机屏幕图像的显示都是由许多像素点排列组成的，屏幕分辨率就代表着像素个数，当用手机屏幕中横向的像素点与纵向的像素点相乘的时候，其比值就是手机屏幕的分辨率了。

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\像素.jpg)

3. 视网膜屏幕与PPI

   - 视网膜（Retina）屏幕是苹果公司"发明"的一个营销术语。并在部分移动产品使用。它将960×640的像素压缩到一个3.5英寸的显示屏内，即该屏幕的像素密度达到326像素/英寸（ppi），称之为“视网膜屏幕”。

   - ppi（pixels per inch）所表示的是每英寸长度所能够排列的像素（pixel）的数目。PPI数值越高，即代表显示屏能够以更高的密度显示图像。

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ppi.png)

4. 物理像素与逻辑像素

   物理像素：设备上设备屏幕实际拥有的像素点

   逻辑像素：程序认为屏幕横向纵向有多少个像素点

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\逻辑像素.png)

5. @2x、@3x图片

   假如网页展示一张图片`width:100px;height:100px`

   - iphone 3 一倍屏 图片一个像素使用一个物理像素表示 图片大小需要100px*100px
   - iphone 4 二倍屏 图片的一个像素使用两个物理像素表示 图片大小需要200px*200px
   - iphone 7Plus 三倍屏 图片的一个像素使用三个物理像素表示 图片大小需要300px*300px

#### viewport

https://mp.weixin.qq.com/s/DFOrEUsVqmujHW7tADsH0g

`<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">`

viewport即视口

- layout viewport 100%宽度有多少像素 通过 `document.documentElement.clientWidth`获得
- visual viewport  浏览器可视区大小 通过`window.innerWidth`获得
- ideal viewport 浏览器meta中device-width宽度 通过 `window.screen.width`获得

#### 移动端1px

https://mp.weixin.qq.com/s/N2vRHKOE9WH_TAtwBaiX_Q



#### flexible源码

https://mp.weixin.qq.com/s/ALXtRYIsaFM4FPEj3zwKqQ

#### rem布局

https://github.com/geeknull/rem-moka

## webpack

#### webpack使用

1. 介绍

   webpack会分析项目结构，找到js模块及其他一些浏览器下不能直接运行的拓展语言，并将其打包为合适的格式以供浏览器使用。

   - 代码转换 
   - 文件优化 压缩代码合并图片等
   - 代码分割 提取多个页面公共代码 提取首屏不需要执行部分的代码让其异步加载
   - 模块合并 
   - 自动刷新 监听本地源代码变化 自动重新构建刷新浏览器
   - 代码校验 检测代码是否符合规范 单元测试是否通过
   - 自动发布 更新完代码后自动构建出线上发布代码并传输给发布系统

2. 初始化项目

   ```js
   mkdir webpack-start
   cd webpack-start
   npm init
   ```

3. webpack核心及配置

   webpack核心概念

   - Entry  入口
   - Module 模块 webpack一切皆模块 一个模块对应一个文件 webpack会从entry开始递归所有模块
   - Chunk代码块 一个chunk由多个模块组成用于代码合并与分割
   - Loader模块转换器 用于把模块原内容按格式转为新内容
   - Plugin 扩展插件 
   - Output 输出

   > webpack启动会从entry里配置的module开始递归解析entry依赖的所有module，每找到一个module就会根据配置的loader去找对应的转换规则，对module转换后再解析出当前module依赖的module，这些模块会以entry为单位进行分组，一个entry和其所有依赖的module被分到一个组也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会再恰当的时机执行plugin里定义的逻辑

   配置webpack `npm i webpack webpack-cli -D`

   - 创建src
   - 创建dist 创建index.html
   - 配置文件webpack.config.js
   - 

4. 配置开发服务器

   ```js
   "script":{
       "build":'webpack --mode development'
}
   ```

5. 支持加载css

   ```js
   {
       test:/\.css$/,
       loader:['style-loader','css-loader','postcss-loader']    
   }
   //css-loader解析出路css文件中url路径
   //style-loader把css文件变成style标签插入header，多个loader执行顺序从右往左
   ```

6. 自动产出html

   `npm i html-webpack-plugin -D`

   ```js
   plugin:[
       new HtmlWebpackPlugin({
       	minify:{ //对html文件进行压缩
       		removeAttributeQuotes:true //去掉属性的双引号
       	},
       	hash:true, //引入资源时加上哈希值避免缓存
       	template:'./src/index.html', //模板路径
       	filename:'index.html' //产出文件名
           title:'标题'
       })
   ]
   //模板中科院引用变量title
   <title><%=htmlWebpackPlugin.options.title%></titile>
   ```

7. 支持图片

   手动添加图片 `npm i file-loader url-loader -D`

   - file-loader解决css等文件的引入图片路径
   - url-loader当图片较小时会把图片引入BASE64编码，大于limt参数时还是使用file-loader拷贝

   ```js
   {
       test:/\.(jpg|png|gif|svg)$/,
       use:"url-loader",
       include:path.join(_dirname,'./src'),
       exclude:/node_modules/    
   }
   ```

8. 分离css

   `npm i postcss-loader autoprefixer -D`

9. 编译less sass

   ```js
   {
       test:/\.less$/,
       loader:lessExtract.extract({
           use:['css-loader','less-loader']
       })    
   }
   ```

   

10. 处理css3属性前缀

11. 转义es6 es7 jsx

    ```js
    {
        test:/\.js/,
        use:{
            loader:'babel-loader',
            query:{
                  presets:['env','stage-0','react']
            }
        }    
    }
    ```

    

12. 调试打包后代码

    ```js
    devtool:'source-map', //单独文件可以定位到行列
    devtool:'cheap-module-source-map', //单独文件，只能定位到行
    devtool:'eval-source-map', //不会生成单独文件
    devtool:'cheap-module-eval-source-map'  //不会生成单独文件只定位到行  
    ```

    

13. 打包第三方类库

14. watch

    ```js
    watch:true,//监视源文件变化，改变后重新打包
    watchOptions:{
        ignored:/node_modules/,
        poll:1000,  //每秒轮询次数
        aggregateTimeout:500    
    },   
    ```

15. 拷贝静态文件

    ```js
    //npm i copy-webpack-plugin -D
    plugin:{
        new CopyWebpackPlugin([{
            from: '源文件地址',
            to:'目标地址'
        }])
    }
    ```

16. 压缩文件

    ```js
    {
        test:/\.css$/,
        loader:cssExtract.extract({
            use:['css-loader?minimize','postcss-loader']
        })    
    }
    //?minimize添加后生成压缩文件
    ```

    压缩js `npm i uglyfyjs-webpack-plugin`

17. 

####webpack源码

1. 类图

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\webpack类.png)

2. 模块 module

   Module是webpack最核心的类 其他加载的依赖都是module，子类包括

   - RawModule
   - NormalModule
   - MultiModule
   - ContextModule
   - DelegateModule
   - DllModule
   - ExternalModule

3. 依赖

   - Module类继承自DependenciesBlock 它有一个dependencies数组，表示此模块依赖的其他模块
   - webpack使用Dependency的个志子类表示不同的模块加载规范，每个规范都有自己的DenpendencyParserPlugin
     - AMDRequireDenpendency
     - AMDDefineDenpendency
     - AMDRequireDenpendency
     - CommonJSRequireDenpendency
     - SystemImportDenpendency
   - 每个Dependency都有自己的template方法，用来生成加载该依赖模块的js代码 

4. 执行流程

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\webpack流程.jpg)

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\webpackflow.png)

   - compile开始编译
   - make从入口点分析模块及其依赖的模块，创建模块对象
   - build-module 构建模块
   - after-compile完成构建
   - seal等车构建结束
   - emit把各个chunk输出到结果文件
   - after-emit完成输出

5. 编译核心对象compliation

   ```js
   this.compiler = compiler //cpmpiler对象
   this.resolvers = compiler.resolveers //模块解析包
   this.mainTemplate = new MainTemplate(this.outputOptions) //生成主模块js
   this.chunkTemplate = new ChunkTemplate(this.outputOptions,this.mainTemplate) //异步加载模块js
   this.hotUpdateChunkTemplate = new hotUpdateChunkTemplate(this.outputOptions) //热更新时的代码模块js
   this.moduleRemplate = new moduleTemplate(this.outputOptions) //入口模块代码
   this.entries = [] //入口
   this.preparedChunks = [] //预先加载的chunk
   this.chunks = [] //所有的chunk
   this.nameChunks = {} //每个chunk对应的name 可以通过nameChunks[name]获取chunk
   this.modules = [] //所有的module
   this.assets = {} //保存所有生成文件
   this.children = [] //保存子Compilation对象 子Compilation对象依赖它的上级Compilation对象生成的结果，所以等到父Compilation编译完成才能开始
   this.dependencyFactories = new ArrayMap() //保存dependency和moduleFactory的对应关系，方便创建该依赖对应的module
   this.dependencyTemplates = new ArrayMap()//保存dependency和Templates的对应关系，方便生成加载此模块的代码
   ```

   - 模块编译

     - SimpleEntryPlugin、MutiEntryPlugin插件中注册了对应make事件的监听，当compiler执行make时，触发Compilation addEntry方法，在addEntry内调用私有方法_addModuleChain
     - 使用acom生成AST并遍历AST收集依赖
     - webpack使用acom解析每一个经loader处理过的source，并生成AST遍历所有节点，当遇到require调用时会分析是AMD还是CMD的调用或者是require ensure

     - webpack在build模块时（调用doBuild方法）要先调用响应的loader对source进行加工，生成一段js代码后交给acom解析生成AST，所以不管是css/jpg/html文件最终经过loader处理会变成一个module
     - 比如url-loader 根据loader配置一段dataurl或使用loadercontext的emitFile方法向assets添加一个文件

     ```js
     _addModuleChain(context, dependency, onModule, callback) {
         ......
         // 取出对应的Factory
         const Dep = /** @type {DepConstructor} */ (dependency.constructor);
         const moduleFactory = this.dependencyFactories.get(Dep);
         ......
         this.semaphore.acquire(() => {
             moduleFactory.create(
                 {
                     contextInfo: {
                         issuer: "",
                         compiler: this.compiler.name
                     },
                     context: context,
                     dependencies: [dependency]
                 },
                 (err, module) => {
                     ......
                 }
             );
         });
         }
     ```

   - 封装
     - 调用send方法封装，逐次对每个module和chunk进行整理，生成编译后的源码合并拆分生成hash
     - webpack会根据不同的插件对minChunkSizePlugin、limtChunkCountPlugin将不同的module整理到不同的chunk里，每个chunk对应一个输出文件
     - 此时所有module仍然保存编译前的原文件内容，webpack会把源代码里require调用换成webpack模块加载代码

   - 通过template生成结果代码

     调用compilation类里的createCom   assets方法

     ```js
     //如果是入口 使用mainTemplate生成结果否则使用cunkTemplate
     const template = chunk.hasRuntime()?this.mainTemplate:this.chunkTemplate
     ```

     在mainTemplate和chunkTemplate中需要根据依赖的模块 逐个调用moduleTemplate的render方法

     ```js
     render(module,dependencyTemplate,options){
         const moduleSource = module.source(dependencyTempalte,this.runTimeTemplate)
     }
     ```

     在子类NormaiModule的source方法里必须把源代码中的require引入的模块代码替换成webpack模块加载代码normalModulejs

     ```js
     source(dependencyTempalte,runTimeTemplate){
         const source =this.generator.generate(this,dependencyTempalte,runTimeTemplate)
     }
     ```

     ```js
     Class JavascriptGenerator{
         generate(module,dependencyTempalte,runTimeTemplate){
             const source = new ReplaceSource(originalSource)
         }
     }
     ```

   - 输出结果文件

     webpack会再compiler的emitAsset方法里的结果写到输出文件里，在此之前会先创建输出目录，所以当你要开发一些自定义的插件要输出一些结果时，把文件放入compliation assets即可

6. webpack工作原理

   - 流程概括
     1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。
      2.开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。
      3.确定入口：根据配置中的 entry 找出所有的入口文件。
      4.编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
      5.完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
      6.输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。
      7.输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。
   - 三大阶段
     - 初始化：启动构建，读取与合并配置参数，加载plugin实例化compiler
     - 编译：从entry发出，针对每个module串行调用对应的loader去翻译文件内容，再找到该module依赖的module，递归的进行编译处理
     - 输出：对编译后的module组合成chunk把chunk转为文件 输出到文件系统

7. 调试 `npm i vscode-webpack-debugger -D`

8. 日志

   - 注册流程

     ```js
     
     ```

     

   - 触发流程

9. 完整流程

#### tapable

webpack中最核心的负责编译的conpiler和负责创建的bundles的compilation都是tapable的实例

1. tapable用法

   ```js
   const {
       SyncHook,
   	SyncBailHook,
       SyncWaterfallHook,
   	SyncLoopHook,
   	AsyncParallelHook,
   	AsyncParallelBailHook,
   	AsyncSeriesHook,
   	AsyncSeriesBailHook,
   	AsyncSeriesWaterfallHook,
   } = require('tapable')
   ```

2. Sync*类型的钩子

   注册在该钩子下的插件执行顺序都是顺序执行，只能使用tap注册，不能使用tapPromise和tapAsync注册

   - SyncHook

     串行同步执行不关系返回值

     ```js
     let {SyncHook} = require('tapbale')
     let queue = new SyncHook(['name']) //当触发此事件时需要传入name参数 监听函数可以获得name参数
     queue.tap('1',function(name){
         console.log(name,1)
     })
     queue.tap('2',function(name){
         console.log(name,2)
     })
     queue.tap('3',function(name){
         console.log(name,3)
     })
     queue.call('test') //call是触发事件的意思
     ```

     ```js
     //原理
     class SyncHook{
         constructor(){
             this.hooks = []
         }
         tap(name,fn){
             this.hooks.push(fn)
         }
         call(){
             this.hooks.forEach(hook =>hook(...arguments))
         }
     }
     ```

   - SyncBailHook

     串行同步执行，有一个返回值不为null则跳过剩下的逻辑

     ```js
     let {SyncBailHook} = require('tapbale')
     let queue = new SyncBailHook(['name']) 
     queue.tap('1',function(name){
         console.log(name,1)
         return 'wrong'
     })
     queue.tap('2',function(name){
         console.log(name,2)
     })
     queue.tap('3',function(name){
         console.log(name,3)
     })
     queue.call('test')
     ```

     ```js
     //原理
     class SyncHook{
         constructor(){
             this.hooks = []
         }
         tap(name,fn){
             this.hooks.push(fn)
         }
         call(){
             for(let i=0;i<hooks.length;i++){
                 let hook = this.hooks[i]
                 let result = hook(...arguments)
                 if(result) break
             }
         }
     }
     ```

   - SyncWaterfallHook

     ```js
     //瀑布类型 如果返回值不为null就把下一个回调的第一个参数变成返回值
     let {SyncWaterfallHook} = require('tapbale')
     let queue = new SyncWaterfallHook(['name']) 
     queue.tap('1',function(name){
         console.log(arguments)
         console.log(name,1)
         return 1
     })
     queue.tap('2',function(data){
         console.log(data,2)
     })
     queue.tap('3',function(data){
         console.log(data,3)
     })
     queue.call('test')
     ```

     ```js
     //原理
     class SyncWaterfallHook{
         constructor(){
             this.hooks = []
         }
         tap(name,fn){
             this.hooks.push(fn)
         }
         call(){
             let result 
             for(let i=0;i<hooks.length;i++){
                 let hook = this.hooks[i]
                 result = i==0? hook(...arguments):hook(result)
             }
         }
     }
     ```

   - SyncLoopHook

     当事件被触发时监听函数会反复执行，当监听函数返回true表示继续循环，false表示终止循环

     ```js
     let {SyncLoopHook} = require('tapbale')
     let queue = new SyncLoopHook(['name']) 
     queue.tap('1',function(name){
         console.log(name,count--)
         if(count>0){
             return true
         }else{
             return
         }
     })
     queue.call('test')
     ```

     ```js
     //原理
     class SyncLoopHook{
         constructor(){
             this.hooks
         }
         tap(name,fn){
             this.hooks = fn
         }
         call(){
             let result 
             do{
                 result = this.hook(...arguments)
             }while(result)
         }
     }
     ```

3. Async*类型的钩子

   注册tap、tapPromise、tapAsync注册，每次都是调用tap、tapPromise、tapAsync注册不同类型的插件钩子，通过调用call、callAsync、promise方式调用，调用时为了按照一定的执行策略执行，调用compile方法快速编译一个方法执行这些插件

   - AsyncParallel

     - AsyncParallelHook

       tap

       ```js
       //异步并发执行 
       let {AsyncParallelHook} = require('tapbale')
       let queue = new SyncLoopHook(['name']) 
       console.time('cost')
       queue.tap('1',function(name){
           console.log(1)
       })
       queue.tap('2',function(name){
           console.log(2)
       })
       queue.tap('3',function(name){
           console.log(3)
       })
       queue.callAsync('test',err=>{
           cosole.log(err)
           console.timeEnd('cost')
       })
       ```

       tapAsync

       ```js
       let {AsyncParallelHook} = require('tapbale')
       let queue = new SyncLoopHook(['name']) 
       console.time('cost')
       queue.tapAsync('1',function(name,cb){
           setTimeOut(function(){
                console.log(1,name)
               cb()
           },1000)
       })
       queue.tapAsync('2',function(name,cb){
           setTimeOut(function(){
                console.log(2,name)
               cb()
           },2000)
       })
       queue.tapAsync('3',function(name,cb){
           setTimeOut(function(){
                console.log(3,name)
               cb()
           },3000)
       })
       queue.callAsync('test',err=>{
           cosole.log(err)
           console.timeEnd('cost')
       })
       ```

       tapPromise

       ```js
       let {AsyncParallelHook} = require('tapbale')
       let queue = new SyncLoopHook(['name']) 
       console.time('cost')
       queue.tapPromise('1',function(resolve,reject){
           return new Promise(function(resolve,reject){
                setTimeOut(function(){
                	console.log(1,name)
               	resolve()
           	 },1000)
           })
       })
       queue.tapAsync('2',function(name,cb){
           return new Promise(function(resolve,reject){
                setTimeOut(function(){
                	console.log(2,name)
               	resolve()
           	 },2000)
           })
       })
       queue.tapAsync('3',function(name,cb){
            return new Promise(function(resolve,reject){
                setTimeOut(function(){
                	console.log(3,name)
               	resolve()
           	 },3000)
           })
       })
       queue.promise('test').then(()=>{
           cosole.log(err)
           console.timeEnd('cost')
       })
       ```

     - AsyncParallelBailHook

   - AsyncSeries

     - AsyncSeriesHook

       异步串行执行

       ```js
       //原理
       class AsyncSeriesHook{
           constructor(){
               this.hooks = []
           }
           tapAsync(name,fn){
               this.hooks.push(fn)
           }
           callAsync(){
               let args = Array.from(arguments)
               let done = args.pop()
               let idx = 0
               let that = this
               function next(){
                   let fn = that.hooks[idx++]
                   fn ? fn(...args,next) : done()
               }
               next()
           }
       }
       ```

     - AsyncSeriesBailHook

     - AsyncSeriesWaterfallHook

4. tapable

   ```js
   //已废弃
   const {Tapable,SyncHook} = require('tapable')
   const t = new Tapable()
   t.hooks = {
       myHook:new SyncHook()
   }
   let called = 0
   t.plugin('my-hook',()=>called++)
   t.hook.myHook.call()
   t.plugin('my-hook',()=>called+=10)
   t.hook.myHook.call()
   console.log(called)
   ```

#### webpack优化方案

1. 尽量减少文件搜索范围

   优化loader配置

   - include & exclude

     ```js
     module:{
         rules:[
             {
                 test:/\.js$/,
                 use:['babel-loader?cacheDirectory'],
                 include:path.resolve(_dirname,'src'), //只转换src目录下文件
                 exclude:/node_modules/ //排除node_modules
             }
         ]
     }
     ```

   - resolve.modules

     ```js
     resolve:{ //引入一个模块时要进行解析
         modules:[path.resolve(_dirname,'node_modules')]
     }
     ```

   - resolve.mainFields

     mainField用于配置第三方模块使用哪个入口文件 isomorphic-fetch

     - 当target为web或webworker时，值是['browswer','module','main']
     - 当target为其他情况时，值为['module','main']
     - mainFields:['main']

   - resolve.allas

     通过别名把原理导入路径映射成一个新的导入路径，此优化方法会影响使用tree-shaking去除无效代码

     ```js
     alias:{
         'react':path.resolve(_dirname,'./node_modules/react/cjs/eact.production.min.js')
     }
     ```

   - resolve.extensions

     在导入文件没带文件后缀时，webpack会自动带上后缀去尝试询问文件名是否存在，默认后缀是extensions:['js','json']

     - 后缀列表尽可能小
     - 高频率放最前
     - 导出语句里尽可能带后缀

     ```js
     resolve:{
         extensions:['js']
     }
     ```

   - module.noParse

     让webpack忽略此部分没有采用模块化的文件的递归处理

     ```js
     module:{
         noParse:[/react\.min\.js/]
     }
     //被忽略的文件里不应该包含import require define等模块化语句
     ```

2. DLL

   .dll为后缀的文件称为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据

   - 把基础模块独立打包到单独的动态链接库中
   - 当需要导入的模块在动态链接库里时候，模块不能再次被打包，而且去动态链接库里获取dll-plugin

   定义DLL

   - DLLPlugin插件用于打包出动态链接库
   - DLLReferencePlugin 在配置文件中引入DLLPlugin打包好的动态链接库

   ```js
   //webpack.react.config.js
   module.exports = {
       entry:{
           react:['react'] //react模块打包到一个动态链接库
       }，
       output:{
       	path:path.reslove(_dirname,'dist'),
           filename:'[name].dll.js' //文件名称
   		library:'_dll_[name]' //全局变量名称
   	}，
       plugin:{
           new webpack.DLLPlugin({
               name:'_dll_[name]',
               path:path.join(_dirname,'dist','[name].mainfest.json')
           })
       }
   }
   ```

   ```js
   //pakage.json scripts:
   webpack --config webpack.dll.config.js --mode production
   ```

   使用动态链接库文件

   ```js
   plugins:[
       new webpack.DllReferencePlugin({
           mainfest:require(path.join(_dirname,'dist','react.mainfest.json'))
       })
   ]
   ```

   ```js
   webpack --config webpack.config.js --mode development
   ```

3. HappyPack

   让webpack把任务分解给多个子进程并发执行，子进程处理完后再把结果发送给主进程

   `npm i happypack@next -D`

   ```js
   modules:{
       rules:[{
           test:/\.js$/,
           use:'happypack/loader?id=babel'
       },{
           test:/\.css$/,
           use:'happypack/loader?id=css'
       }
       ]
   }
   ```

   ```js
   plugins:{
       new HappyPack({
           //用唯一的标识符id来代表当前happypack处理哪类文件
           id:'babel',
           loaders:[{
               loader:'babel-loader',
               query:{
                   presets:['env','react']
               }
           }]
       }),
       new HappyPack({
           id:'css',
           loaders:['style-loadeer','css-loader'],
           threads:4 //开启几个子进程处理
           verbose:true
       })    
   }
   ```

4. ParallelUglifyPlugin

   把对js文件的串行压缩变成开启多个子进程并行执行

   `npm i -D webpack-parallel-uglify-plugin`

   ```js
   new parallelUglifyPlugin({
       workerCount:3, //开启几个子进程去并发的执行压缩 默认为cpu核数减1
       uglifyJS:{
           output:{
               beautify:false, //不需要格式化
               comments:false //不保留注释
           }，
           compress:{
           	warning:false, //在uglifyjs删除没有用到的代码时不输出警告
           	drop_console:true, //删除所有的console语句 可以兼容ie浏览器
           	collapse_vars:true, //内嵌定义了但是只用到一次的变量
           	reduce_vars:true //提取初出现很多次但是没有定义成变量去引用的静态值
       	}
       }
   })
   ```

5. 服务器自动刷新

   - 文件监听

     ```js
     watch:true,
     watchOptions:{
         ignoerd:/node_modules/,
         aggregateTimeout:300, //指定监听变化后等待执行的时间
         pool:1000 //轮询变化每秒次数   
     }    
     ```

   - 文件监听流程

     - webpack定时获取文件的更新时间，并和上次保存时间对比，不一致就表示发生了变化,poll配置轮询次数
     - webpack只会监听entry依赖的文件
     - 尽可能减少监听的文件数量和频率

   - 自动刷新浏览器

     ```js
     devServer:{
         contentBase:'./dist',
         inline:true    
     }
     ```

     webpack负责监听文件变化，webpack-dev-server负责刷新浏览器,这些文件会被打包到chunk中，他们会代理客户端向服务器发起websocket连接

   - 模块热替换

     模板热替换(hot module replacement)的技术可在不刷新整个网页时只更新指定的模块，原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器对应模块。

     ```js
     devServer:{
         hot:true
     }
     
     if(module.hot){
         module.hot.accept('/index.js',function(){
             console.log('accept index.js')
         })
     }
     ```

     优化模块热替换浏览器日志

     ```js
     plugin:[
         new webpack.NamedModulePlugin(),
         new webpack.HotModuleReplacementPlugin()
     ]
     //监听更少的文件 忽略掉node_Modules下的文件
     ```

6. 区分环境

   - 环境的区别

     - 线上代码被压缩
     - 开发环境可能会打印只有开发者才能看到的日志
     - 开发环境和线上环境后端数据接口可能不同

   - 使用

     ```js
     if(process.env.NODE_ENV == 'production'){
         console.log('生产环境')
     }else{
         console.log('开发环境')
     }
     //使用process模块时 webpack会把process模块打包进来
     new webpack.DefinePlugin({
         'process.env':{
             NODE_ENV:JSON.stringify('production')//给字符串包裹双引号
         }
     })
     new webpack.DefinePlugin({
         'process.env.NODE_ENV':JSON.stringfy(peocess.env.NODE_ENV)
     })
     ```

   - 区分方案

     - 通过npm命令区分

       ```js
       "script":{
           'build-production':'webpack --config webpack.production.config',
            'build-development':'webpack --config webpack.devlopment.config'   
       }
       ```

     - 通过环境变量区分 webpack-merge

       - 配置文件拆分出 webpack.base.config.js、webpack.lib.config.js、webpack.prod.config.js

       - 总配置文件webpack.config.js引入base、lib、prod

         ```js
         //package.js
         "script":{
             'build-production':'set NODE_ENV=production && webpack --mode',
              'build-development':'set NODE_ENV=development && webpack --mode'   
         }
         
         //config.js
         const base = require('webpack.base.config')
         const merge = require('webpack-merge') //合并配置文件
         const NODE_ENV = process.env.NODE_ENV
         const other
         if(NODE_ENV == 'development'){
             other = require('webpack.dev.config')
         }else{
             other = require('webpack.prod.config')
         }
         module.exports = merge(base,other)
         ```

     - 代码区分

7. cdn

   cdn又叫内容分发网络，通过把资源部署到各地，用户在访问时按照就近原则从最近的服务器获取资源，加速资源获取速度

   - html文件不缓存，放自己服务器上，关闭自己服务器的缓存，静态资源的URL变成指向CDN服务器的地址
   - 静态JS、CSS图片等文件开启CDN和缓存，文件名带上hash值
   - 为了并行加载不阻塞，把不同静态资源分配到不同CDN服务器

   ```js
   output:{
       path:path.resolve(_dirname,'dist'),
       filename:'[name]_[hash:8].js',
       publicPath:'http://test.com'   //配置cdn域名 
   }
   ```

8. tree shaking

   剔除js用不上的死代码，依赖静态ES6模块化语法

   ```js
   //不要编译es6模块
   {
       loader:'babel-loader',
           query:{
               presets:[{
                   'env',{modules:false} //关闭babel的es6模块转换
               }]
           }
   }
   
   webpack --display-used-exports
   
   const UglifyJSPlugin = require('uglifyjs-webpack-plugin')
   pulgins:[
       new UglifyJSPlugin()
   ]
   
   webpack --display-used-exports --optimize-minimize
   webpack --mode production
   ```

9. 提取公共代码

   提取代码

   - 基础类库方便长期缓存
   - 页面之间公有代码
   - 各个页面单独生成文件

   ```js
   entry:{
       pageA:'./src/pageA',
       pageB:'./src/pageB'    
   },
   optimization:{
       splitChunks:{
           cacheGroups:{
               commons:{ //公有模块
                   chunks:'initial',
                   minChunks:2,  //最少复用次数
                   maxInitialRequests:5,
                   minSize:0
               },
               vendor:{ //第三方模块
                   test:/node_modules/,
                   chunks:'initial',
                   name:'vendor',
                   priority:10，
                   enforce:true
               }        	
           }
       }
   },
   output:{
       path:path.join(_dirname,'dist')
   }    
   ```

   

10. scope hoisting

   让webpack打包出的代码文件更小运行更快

   ```js
   //demo
   export default 'hello'
   
   import str from 'hello.js'
   
   var util = ('hello')
   //使用
   const ModuleCouncatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin')
   
   module.exports = {
       resolve:{
           mainFields:['jsnext:main','browser','main']
       },
       plugin:[
           new ModuleConcatenationPlugin()
       ]
   }
   --display-optimization-bailout
   ```

   

11. 代码分离

    将代码分离到不同boundle中，可以按需加载或并行加载这些文件

    - 多入口 使用entry配置手动分离代码

      ```js
      entry:{
          index:'./src/index.js',
          anther:'./src/another-module.js'    
      }
      ```

    - 防止重复 使用splitChunks去重和分离chunk

      splitChunks可以将公共的依赖模块提取到一个新生成的chunk 

      ```js
      optimization:{
          splitChunks:{
              cacheGroups:{
                  commons:{ //公有模块
                      chunks:'initial',
                      minChunks:2,  //最少复用次数
                      maxInitialRequests:5,
                      minSize:0
                  },
                  vendor:{ //第三方模块
                      test:/node_modules/,
                      chunks:'initial',
                      name:'vendor',
                      priority:10，
                      enforce:true
                  }      
              }
          }
      }
      ```

    - 动态导入和懒加载 通过模块的内敛函数调用来分离代码

      动态导入原则 

      - 对网站功能划分，每一类一个chunk
      - 对于首次打开页面需要的功能懒加载尽快展示给用户
      - 某些依赖大量代码的功能点可以按需加载

      ```js
      document.getElementById('clickMe')
      		.addEventListener('click',()=>{
          		import('./video.js').then(function(){
                      console.log('click')
                  })
      		})
      ```

      

12. webpack-dev-middleware

13. 输出分析

14. library target和library

    webpack构建一个可以被其他模块导入使用的库时使用

    - output library target 配置以何种方式导出库
    - output library配置导出库的名称

    **output library target**是字符串的枚举类型，配置参数包括

    - var (默认)

      用library指定名称的变量给库赋值

      ```js
      //配置output library = 'libraryname'后
      var libraryname = lib_code //输出的库 lib_code是有返回值的自执行函数
      
      libraryname.doSomething() //使用库的方法
      //output.library为空时直接输出
      ```

    - commonjs

      编写的库通过commonjs规范导出

      ```js
      //输出
      exports['LibraryName'] = lib_code
      //使用
      require('library-name-in-npm')['LibraryName'].doSomething()
      //library-name-in-npm 是模块发布到npm时名称
      ```

    - commonjs2

      编写的库通过commonjs2规范导出

      ```js
      //输出
      module.exports = lib_node
      
      //使用
      require('library-name-in-npm').doSomething()
      ```

      commonjs2和commonjs规范想似，差别在于commonjs只能用exports导出，commonjs2增加了module.exports导出

    - this

      编写的库将通过this被赋值给通过library指定的名称、

      ```js
      //输出
      this['libraryname'] = lib_code
      //使用
      this.libraryname.doSomething()
      ```

    - window

      编写的库将通过window被赋值给通过library指定的名称，即把库挂载到window上

      ```js
      //输出
      window['libraryname'] = lib_code
      //使用
      window.libraryname.doSomething()
      ```

    - gobal

      把库挂载到global上

      ```js
      global['libraryname'] = lib_code
      global.libraryname.doSomething()
      ```

#### 自定义loader和plugin

##### loader

loader是导出为一个函数的node模块，该函数在loader转换资源时调用，给定的函数将调用loaderAPI并通过this上下文访问

1. 配置loader

   - 匹配单个loader

     ```js
     {
         test:/\.js$/
         use:[{
             loader:path.resolve('path/to/loader.js'),
             options:{}
         }]
     }
     ```

     ```js
     const loaderUtils = require('loader-utils')
     const validateOptions = require('schema-utils')
     module.exports = function(source){
         const options = loaderUtils.getOptions(this)
         let schema = {
             'type':'object',
             'properties':{
                 'content':{'type':'string'}
             }
         }
         validateOptions(schema,options,'参数校验')
         console.log(this.context) //当前处理文件所在目录
         console.log(this.resource)//当前处理文件完整请求路径
         console.log(this.resourcePath)//当前处理文件的路径
         console.log(this.resourceQuery)//当前处理文件的querystring
         console.log(this.loadModule)//loader处理一个文件时如果依赖其他文件的处理结果才能得出当前文件的结果时，就可以通过this.loadModule(request:string,callback:function(err,source,sourceMap,module))去获得request对应文件的处理结果
         console.log(this.resolve)//像require语句一样获得指定文件的完整路径使用方法为resolve(context:string,request:string,callback:function(err,result:string))
         console.log(this.addDependency)//给当前处理文件添加其他依赖文件，以便再依赖的文件发生变化时，会重新调用Loader处理该文件
         console.log(this.addContextDependency)//和addDependency类似 但addContextDependency是把整个目录加入当前正在处理的文件依赖中
         console.log(this.clearDependencies)//清除当前文件的所有依赖
         this.cacheable && this.cacheable()
         this.emitFile('myFile.txt','文件内容')
         let callback = this.async()
         
         console.log(source)
         this.callback(null,'let a')
     }
     ```

   - 匹配多个loaders

     ```js
     resolvwLoader:{
         module:[path.resolve('node_modules'),pathresolve(_dirname,'src','loaders')]
     }
     ```

     ```js
     var less = require('less')
     module.exports = function(source){
         less.render(source,(err,output)=>{
             this.callback(err,output.css)
         })
     }
     ```

     ```js
     var less = require('less')
     module.exports = function(source){
         console.log(source)
         return `let style = document.createElement('style');style.innerHTML = ${JSON.stringgfy(source)};document.head.appendChild(style)`
     }
     ```

     

   - npm link

2. loader用法

3. 用法准则

   - 单一职责
   - 从右到左链式执行，上一个loader的处理结果给下一个接着处理
   - 模块化
   - 无状态
   - loader的实用工具loader-utils和schema-utils
   - loader的依赖

4. API

   - 缓存结果 `this.cachebale()`

   - 异步

     ```js
     module.exports = function(source){
         let callback = this.async()
         doSomeAsyncOperation(content,function(err,result)){
                              if(err) return callback(err)
         callback(null,result)
                              }
     }
     ```

   - raw loader

     默认情况源文件是UTF-8,设置`module.exports.raw = true`可使用buffer格式处理

   - 获得loader的options

     ```js
     const loaderUtils = require('loader-utils')
     module.exports = function(source){
         //获取用户给当前loader传入的options
         const options = loaderUtils.getOptions(this)
         return source
     }
     ```

   - 返回其他结果

     ```js
     module.exports = function(source){
         //通过this.callback告诉webpack返回的结果
         this.callback(null,source,sourceMaps)
         //使用this.callback返回内容时，loader必须返回undefined，来让loader知道返回结果在this.callback中
         return
     }
     ```

     ```js
     this.callback(
         //无法转换原内容时，给webpack返回一个Error
         err:Error | null,
         //原内容转换后的内容
         content:string | Buffer,
         //把转换后的内容加sourceMap方便调试
         sourceMap?:SourceMap,
         //转换生成AST后返回该AST，方便之后需要AST的loader复用该AST
         abstractSyntaxTree?:AST
     )
     ```

   - 同步和异步

     同步loader转换流程都是同步，转换完成后再返回结果。部分场景的转换是异步

     ```js
     module.exports = function(source){
         //本次转换异步 loader会在callback中回调结果
         let callback = this.async()
         someAsyncOpration(source,function(err,result,sourceMaps,ast){
             callback(err,result,sourceMaps,ast)
         })
     }
     ```

   - 处理二进制数据

     ```js
     module.exports = function(source){
         return source
     }
     module.exports.raw = true
     ```

5. BannerLoader

   ```js
   const path = require('path')
   const fs = require('fs')
   module.exports = function(source){
       let callback = this.async()
       let banner = path.resolve(_dirname,'banner.js')
       this.addDependency(banner)
       fs.readFile(banner,'utf8',(err,banner)=>{
           if(err) return callback(err)
           callback(null,banner + '\r\n' +source)
       })
   }
   ```

6. html-layout-loader

   loader-utils

   - parseQuery
   - getLoaderConfig
   - stringfyRequest
   - getRemainingRequest
   - getCurrentRequest
   - isUrlRequest
   - urlToRequest
   - parseString
   - getHashDigest
   - interrpolateName

   ```js
   {
       test:/\.html$/,
       use:{
           loader:'html-layout-loader',
           options:{
               layout:path.join(_dirname,'src','layout.html'),
                   placeholder:'{{_contnet_}}'
           }    
       }    
   }
   ```

   ```js
   //原理 1.取得layout模板路径2.读取layout模板内容3.用source替换占位符返回
   const loaderUtils = require('loader-utils')
   let defaultOptions = {
       placeholder:'{{_content_}}'
   }
   module.export = function(source){
       let callback = this.async()
       let options = loaderUtils.getOptions(this)
       options = {...defaultOptions,...options}
       let {layout,placeholder} = options
       fs.readFile(layout,'utf8',function(err,html){
           html = html.replace(placeholder,source)
           callback(err,`module.exports = ${JSON.stringfy(html)}`)
       })
       return source
   }
   ```

##### plugin

1. 创建插件

   webpack插件组成

   - 一个js命名函数
   - 在插件函数的prototype上定义一个apply方法
   - 指定一个绑定到webpack自身的事件钩子
   - 处理webpack内部实例的特定数据
   - 功能完成后调用webpack提供的回调

   ```js
   class CompilationPlugin{
       constructor(options){
           this.options = options
       }
       apply(compiler){
           compiler.hooks.compilation.tap('CompilationPlugin',function(compilation){
               compilation.hooks.optimize.tap('optimize',function(){
                   console.log('资源在被优化')
               })
           })
       }
   }
   module.exports = CompilationPlugin
   ```

2. compiler和compilation

   - compiler对象代表了完整的webpack环境配置，这个对象在启动webpack时一次性简历，并配置好所有可操作的设置（options/loader/plugin）当在webpack环境中应用一个插件时，插件将收到此compiler对象的引用，可以用它来访问webpack的环境
   - compilation对象代表依次资源版本构建，当运行webpack开发环境中间件时，每当检测一个文件变化，就会创建一个新的compilation，从而生成一组新的编译资源，一个compilation对象表现了当时的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，compilation对象也提供了很多关键时机的回调，以供插件自定义处理时选择使用

3. 基本插件架构

   插件是由具有apply方法的prototype对象所实例化出来的，这个apply方法在安装插件时，会被webpack compier调用一次。apply方法可以接受一个webpack compier对象的引用，从而可以在回调函数中访问compier对象

   ```js
   class DonePlugin{
       constructor(options){
           this.options = options
       }
       apply(compiler){
           compiler.hooks.done.tap('DonePlugin',()=>{
               console.log(this.options.name)
           })
       }
   }
   module.exports = DonePlugin
   ```

   安装插件

   ```js
   let helloPlugin = require('hello')
   let webpackConfig = {
       plugins:[
           new helloPlugin(options:true)
       ]
   }
   ```

4. 访问complilation对象

   ```js
   class CompilationPlugin{
       constructor(options){
           this.options = options
       }
       apply(compiler){
           compiler.hooks.compilation.tap('CompilationPlugin',function(compilation){
                compilation.hooks.optimize.tap('optimize',function(){
                   console.log('资源在被优化')
               })
           })
       }
   }
   module.exports = CompilationPlugin
   ```

5. 异步编译插件

   异步编译插件需要传入一个callback回调函数并且在插件运行结束时必须调用这个回调函数

   ```js
   class CompilationAsyncPlugin{
       constructor(options){
           this.options = options
       }
       apply(compiler){
           compiler.hooks.emit.tapAsync('EmitPlugin',function(compilation,callback){
                setTimeout(function(){
                    console.log('异步完成')
                    callback()
                },500)
           })
       }
   }
   module.exports = CompilationAsyncPlugin
   ```

6. filelistPlugin

   ```js
   class FileListPlugin{
       //生成一个md文件放所有文件的文件名
       constructor(){
       }
       apply(compiler){
           compiler.hooks.emit.tap('FileListPlugin',function(compilation){
                let fileList = 'filelist"\n\n'
                for(let filename in compilation.assets){
                    fileList +=('- '+filename+'\n')
                }
               compilation.asset['filelist.md']={
                   source(){
                       return filelist
                   },
                   size(){
                       return filelist.length
                   }
               }
           })
       }
   }
   module.exports = FileListPlugin
   ```

7. InlineWebpackPlugin

   ```js
   const path = require('path')
   function InlineWebpackPlugin(){
       
   }
   InlineWebpackPlugin.prototype.apply = functiom(compiler){
       let self = this
       compiler.hooks.compilation.tap('compilation'function(compilation){
           compilation.hooks.htmlWbpackPluginAlterAssetTags.tapAsync('InlineWbpackPlugin',function(htmlPluginData,callback){
               if(!htmlPluginData.plugin.options.inlineSource){
                   return callback(null,htmlPluginData)
               }
               let regextStr = htmlPluginData.plugin.options.inlineSource
               let result = self.processTags(compilation,regextStr,htmlPluginData)
               console.log(result)
               callback(null,result)
           })
       })
   }
   InlineWebpackPlugin.prototype.processTags = function(compilation,regextStr,htmlPluginData){
       let self = this
       let head =[],body=[]
       let regex = new RegExp(regextStr)
       htmlPluginData.head.forEach(tag=>head.push(self.processTag(compilation,regex,tag)))
       htmlPluginData.body.forEach(tag=>body.push(self.processTag(compilation,regex,tag)))
       return {...htmlPluginData,head,body}
   }
   InlineWebpackPlugin.prototype.processTag = function(compilation,regex,tag){
       console.log(tag)
       let assetUrl
       if(tag.tagName =='script' && regex.test(tag.attributes.src)){
           assetUrl = tag.attributes.src
           tag = {
               tagName:'script',
               closeTag:true,
               attributes:{
                   type:'text/javascript'
               }
           }
       }else if(tag.tagName =='link' && regex.test(tag.attributes.href){
           assetUrl = tag.attributes.href
           tag = {
               tagName:'style',
               closeTag:true,
               attributes:{
                   type:'text/css'
               }
           }
        }
        if(assetUrl){
            let asset = compilation.assets[assetUrl]
            tag.innerHTML = asset.source()
        }
   	 return tag
   }
   module.exports = InlineWebpackPlugin
   ```

8. UploadPlugin

## AST 抽象语法树

#### AST概念

抽象语法树(Abstract Syntax Tree) 是webpack等多个工具、库使用来实现对代码的检查分析等操作

#### AST用途

- 代码语法、风格检查 代码格式化、高亮、错误提示、自动补全等
- 代码混淆压缩
- 优化变更代码，改变代码结构使达到想要的结构

#### AST定义

通过JS Parser把代码转成一颗抽象语法树，这个树定义的代码的结构，通过操作这个树可以精准的定位到声明语句等，实现对代码的分析、优化、变更等操作。

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ast语法树.png)

####js Parser

JavaScript Parser 把源码转为抽象语法树的解析器,浏览器会把js源码通过解析器转为抽象语法树，再进一步转为字节码或者机器码，一般来说每个js引擎都有自己的ast格式。

常见的JavaScript Parser有esprima、traceur、acom、shfit

**esprima**

- 通过esprima把源码转为AST
- 通过estraverse遍历更新AST
- 通过escodegen将AST重新生成源码
- astexplorer

```js
let esprima = require('esprima')
let estraverse = require('estraverse')
let escodegen = require('escodegen')
let code = 'function ast(){}'
console.log(ast)
```

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ast解构.png)

```js
estraverse.traverse(ast,{
    enter(node){
        node.name += '_ext'
    }
    leave(node){
    
	}
})
let generated = escodegen.generate(ast)
console.log(generated)
```

#### 转换箭头函数

访问者模式(visitor)对某个对象或者一组对象不同的访问者产生的结果也不同。

- babel-core
- babel-types
- babel插件手册

```js
let babel = require('babel-core')
let types = require('babel-types')
const code = `const sum = (a,b)=>a+b`
const Visitor = {
    ArrowFunctionExpression:{
        enter(path){
            let node = path.node
            let expression = node.body
            let returnStatement = types.returnStatement(expression)
            let block = types.blockStatement([returnStatement])
            let params = path.node.params
            let func = types.functionExpression(null,params,block,false,false)
            path.replceWidth(func)
        }
    }
}
const result = babel.transform(code,{
    plugins:[{visitor}]
})
console.log(result.code)
```

#### babel插件

```js
//预计算简单表达式的插件
const result = 1+2 ==>>>>const result = 3

let babel = require('babel-core')
let types = require('babel-types')
let visitor = {
    BinaryExpression(path){
        let noode = path.node
        if(!isNaN(node.left.value) && !isNaN(node.right.value)){
            let result = eval(node.left.value+node.operator+node.right.value)
            path.replaceWith(type.numericliteral(result))
            if(path.parentPath && path.parentPath.node.type == 'BinaryExpression'){
                //如果父元素也是表达式 递归计算
                visitor.BinaryExpression.call(null,path.parentPath)
            }
        }
    }
}
```

####webpack babel插件

实现按需加载 

```js
import {flatten,concat} from 'lodash' 
//转换为
import flatten from 'lodash/flatten'
import concat from 'lodash/flatten'
```

babel配置

transform-runtime默认只转换js语法不转换新的API（Iterator/Generator/Set/Maos/Proxy/Reflect/Symbol/Promise），启用插件babel-plugin-transform-runtime后babel就会使用bebel-runtime下的工具函数

```js
{
    'presets':['react','stage-0','env'], //从右往左编译
     'plugins':[
         ['extract',{'library':'lodash'}], //从左网友编译
         ['transform-runtime',{}]
     ]   
}
```

babel插件

```js
let babel = require('babel-core')
let types = require('babel-types')
const visitor = {
    ImportDeclaration:{
        let node = path.node
        let specifiers = node.specifiers
        if(res.opt.library == node.source.value && !type.isDefaultImportSpecifier(specifiers[0])){
            let newImports = specifiers.map(specifier=>{
                types.importDeclaration([types.ImportDefaultSpecifier(specifier.local)],type.stringLiteral(`${node.source.value}/${specifier.local.name}`))
            })
            path.replaceWithMultiple(newImports)
        }
    }
}
```

## react

####基础

##### jsx

JSX是js的语法扩展 `const element = <h1>hello</h1>`

1. JSX嵌入表达式

   ```js
   const name = 'test'
   const element = <h1>hello {name}</h1>
   ```

2. JSX也是表达式可以作为值返回

   ```js
   function getGreeting(user){
       if(user){
           return <h1>hello{format(user)}</h1>
       }else{
           return <h1>hello</h1>
       }
   }
   ```

3. JSX特定属性

   - 使用引号将属性值指定为字符串字面量

     `const element = <div tabIndex="0"></div`

   - 使用大括号在属性值中插入js表达式

     `const element = <img src={user.avatarUrl}/>`

4. 使用JSX指定子元素

   ```js
   const element = {
       <div>
       	<h1>hello</h1>
       	<h2>good</h2>
       </div>
   }
   ```

5. JSX防止注入攻击

   react dom在断然所有输入内容之前，默认进行转义。所有内容在渲染之前都被转换成了字符串。

6. JSX表示对象

   babel会把JSX转义成REact.createElement()调用

   ```js
   const element = (<h1 classname='greeting'>hello</h1>)
   //等效
   const element = React.createElement('h1',{className:'greeting'},'hello')                 
   ```

##### 元素渲染

React是创建开销极小的普通对象，ReactDOM会负责更新DOM来与React保持一致

- 把元素渲染为DOM

  使用React构建的应用通常只有单一的根节点，想要将一个React元素渲染到根DOM节点中，只需把它传入ReactDOM.render()

  ```js
  const element = <h1>hello</h1>
  ReactDOM.render(element,document.getElementById('root'))
  ```

- 更新已渲染的元素

  react元素是不可变对象，一旦被创建就无法更改它的子元素或属性。更新UI唯一的方式是创建一个全新元素，并将其传入ReactDOM.reander()

  ```js
  function tick(){
      const element ={
          <div>
          	<h2>it is {new Date().toLocaleTimeString()}</h2>
          </div>
      }
      ReactDOM.render(element,document.getElementById('root'))
  }
  setInterval(tick,1000)
  ```

  ReactDOM会将元素和它的子元素与他们之前的状态进行比较，并只会进行必要的更新。

##### 组件和props

组件类似js函数，接受任意的入参(props)并返回用于描述页面展示内容的react元素，组件有两种形式class组件和function组件

1. 定义组件

   ```js
   //有效组件条件1.接受唯一带有数据的props 2.返回一个react元素
   function Test(props){
       useEffect(()=>{
           //相对于componentDidMount componentWillUnmount
       },[])
       return <h1>hello</h1>
   }
   
   //或者使用es6的class定义组件
   //拥有状态和生命周期 继承于Component 实现render方法
   class Test extends React.Component{
       render(){
           return <h1>hello</h1>
       }
   }
   ```

2. 渲染组件

   当react元素为自定义组件时，会将JSX所接收的属性及子组件转换为单个对象传递给组件

   ```js
   function Test(props){
       return <h1>hello {props.name}</h1>
   }
   const element = <Test name="word"/>
   ReactDOM.render({element,document.getElementById('root')})    
   ```

3. 组合组件

   组件可以在其输出中引用其他组件

   ```js
   function Test(props){
       return <h1>hello {props.name}</h1>
   }
   function App(){
       return (
           <div>
           	<Test name="word1"/>
           	<Test name="word2"/>
           	<Test name="word3"/>
           </div>
       )
   }
   ReactDOM.render({<App/>,document.getElementById('root')})    
   ```

4. 提取组件

   把组件拆分成更小的组件

   ```js
   //社交网站评论
   function Comment(props){
       return (
       	<div className="Comment">
           	<div className="UserInfo">
           		<img className="Avatar" src={props.author.avatarUrl} alt={props.author.name}/>
           		<div className="UserInfo-name">
           			{props.author.name}
           		</div>
           	</div>
           	<div className="Comment-text">
           		{props.text}
           	</div>
           	<div className="Comment-date">
                   {formatDate(props.date)}
           	</div>
           </div>
       )
   }
   ```

   提取组件

   ```js
   //提取Avatar组件
   function Avatar(props){
       return (
           <img className="Avatar" src={props.user.avataUrl} alt={props.user.name}/>
       )
   }
   //提取UserInfo组件
   function UserInfo(props){
       return (
       	<div className="UserInfo">
           	<Avatar user={props.user}/>
   			<div className='UserInfo-name'>{props.user.name}</div>	
           </div>
       )
   }
   //简化comment
   function Comment(props){
       return (
       	<div class="Comment">
           	<UserInfo user={props.author} />
   			<div className="Comment-text">{props.text}</div>
   			<div className="Comment-date">{formatDate(props.date)}</div>
           </div>
       )
   }
   ```

5. props只读性

   组件无论是使用函数声明还是class声明都不能修改自身的props
   
6. 组件通信

   - 父子组件通信通过props传递 [demo](https://segmentfault.com/a/1190000014989351)

     共同的数据放在父组件上，独有数据放在组件内部state上。props可以一层层传递一般数据和函数数据

     - 一般数据->父组件传递数据给子组件->子组件读取数据
     - 函数数据->子组件传递数据给父组件->子组件调用函数

   - 跨层级组件通信使用context

   - 没有嵌套关系组件通信通过自定义事件的发布订阅 [demo](https://segmentfault.com/a/1190000012361461)

##### state和生命周期

react中只要更新组件state就会重新渲染页面，state与props类似是组件私有的，完全受控于组件。

```js
class Clock extends React.Component{
    constructor(props){
        super(props)
        this.state = {date:new Date()}
    }
    render(){
        return (
        	<div>
            	<h1>hello</h1>
            	<h2>{this.state.date.toLocalTimeString}</h2>
            </div>
        )
    }
}
ReactDOM.render(<Clock/>,document.getElementById('root'))
```

**state注意事项**

- 不能直接修改state

  ```js
  //wrong
  this.state.comment ='hello'
  //correct setState构造函数是唯一一个给this.state赋值的地方
  this.setState({comment:'hello'})
  setState(partialState,callback)
  //partialState obj|func 用于产生当前state合并的子集
  //calback state更新后被调用
  ```

- state更新可能是异步

  react可能会把多个setState()调用合并成一个调用，因此this.props和this.state可能会异步更新。解决这个问题可以使用setState()接受一个参数而不是一个对象，这个函数用上一个state作为第一个参数，将此次更新被应用时的props作为第二个参数。

  setState()在原生事件和setTimeout中是同步的

  ```js
  //wrong
  this.setState({
      counter:this.state.counter+this.props.increment
  })
  
  //correct
  this.setState(function(state,props){
      return {counter:state.counter+props.increment}
  })
  ```

- state更新可能会被合并

  当调用setState()时，react会把提供的对象合并到当前的state


当组件第一次被渲染到DOM时为其设置一个计时器即挂载，当DOM中组件被删除时清除定时器即卸载，组件挂载或卸载时执行的方法叫生命周期方法。

- componentDidMount()会在组件已经被渲染到DOM中后运行
- componentWillUnmount()会在组件卸载后执行

```js
class Clock extends React.Component{
    constructor(props){
        super(props)
        this.state = {date:new Date()}
    }
    componentDidMount(){
        //设置定时器
        this.timerID = setINterval(
            //处理this可以使用1.this.bind(this)2.箭头函数调用3.定义tick时使用属性初始化this.tick
            //3. timerID = ()=>{this.tick()}
        	()=>this.tick(),
            500
        )
    }
    componentWillUnmount(){
        //清除定时器
        clearInerval(this.timerID)
    }
    tick(){
        this.setState({date:new Date()})
    }
    render(){
        return (
        	<div>
            	<h1>hello</h1>
            	<h2>{this.state.date.toLocalTimeString}</h2>
            </div>
        )
    }
}
ReactDOM.render(<Clock/>,document.getElementById('root'))
```

**setState解析**

![react组件交互流程](C:\Users\ASUS\Desktop\笔记\架构笔记\img\react组件交互.png)

setState在setTimeOut/原生事件绑定里为同步执行，生命周期合成事件中异步执行。

1. 为什么要异步

   批量多次更新时延迟到最后合并渲染对性能优化很重要，每次SetState都引发组件更新时都走一圈生命周期比较浪费

2. setState实现流程

   setstate实现时会根据一个变量isBatchingUpdates判断直接更新this.state还是放入队列，isBatchingUpdates默认为false（同步更新this.state）。react调用事件处理函数和生命周期前会调用batcheUpdates函数，把isBathingUpdates修改为true（this.tate异步更新）。

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\setState.webp)

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\setState异步流程.webp)

this.setState把state放入pendingState队列中，将组件标记为dirtyComponent(react更新事务操作)，判断是否处于batchupdate，是的话保存在dirtyComponent，在事务更新时通过ReactUpdates.flushBatchesUpdates方法将所有的临时state merge并计算最新的props和state然后批量执行关闭结束事务。不是的话直接开启一次新的更新事务，标记为dirty后直接更新组件，当setState执行完毕时组件已经更新结束，造成定时器同步更新的情况。

##### 事件处理

- react事件命名采用小驼峰式而不是纯小写
- 使用JSX语法时需要传入一个函数作为事件处理函数而不是字符串
- 不能通过`return false`阻止默认行为，必须显式使用preventDefault

```js
function ActionLink(){
    function handleClick(e){
        e.preventDefault()
        console.log('clicked')
    }
    return (<a href="#" onClick={handlerClick}>click</a>)
}
```

react不要使用addEventListener为已创建的DOM元素添加监听器，只要在元素初始渲染时添加

```js
Class Toggle extends React.Component{
    constructor(props){
        super(props)
        this.state = {isToggleOn:true}
        //绑定this
        this.handleClick = this.hancleClick.bind(this)
    }
    handleClick(){
        this.setState(state=>({isToggleOn: !state.isToggleOn}))
    }
    render(){
        return (<button onClick={this.handleClick}>{this.state.isToggleOn? 'ON':'off'}</button>)
    }
}
ReactDOM.render(<Toggle/>,document.getElementById('root'))
```

**向事件处理程序传递参数**

```js
//事件对象显式传递
<button onClick={(e)=>this.deleteRow(id,e)}>delete</button>
//事件对象隐式传递
<button onClick={this.deleteRow.bind(this,id)}>delete</button>
```

##### 条件渲染

react可以创建不同的组件封装不同的应用，使用if或其他条件运算符来切换不同组件

```js
function UserGreeting(props) {
  return <h1>Welcome back!</h1>;
}

function GuestGreeting(props) {
  return <h1>Please sign up.</h1>;
}

function Greeting(props){
    const isLoggedIn = props.isLoggedIn
    if(ifLoggedIn){
        return <UserGreeting/>
    }
    return <GuestGreeting/>    
}
REactDOM.render(<Greeting isLoggedIn={false},document.getElementById('root'))    
```

- 元素变量  可以使用变量存储元素

  ```js
  function LoginButton(props) {
    return (
      <button onClick={props.onClick}>
        Login
      </button>
    );
  }
  
  function LogoutButton(props) {
    return (
      <button onClick={props.onClick}>
        Logout
      </button>
    );
  }
  
  class LoginControl extend React.Component{
      constructor(props) {
          super(props)
          this.handleLoginClick = this.handleLoginClick.bind(this)
          this.handleLogoutClick = this.handleLogoutClick.bind(this)
          this.state = {isLoggedIn:false}
      }
      handleLoginClick() {
      	this.setState({isLoggedIn: true})
   	}
   	handleLogoutClick() {
      	this.setState({isLoggedIn: false})
      }
      render(){
          const isLoggedIn = this.state.isLoggedIn
          let button
          if(isLoggedIn){
              button = <LogoutButton onClick={thi.handleLogoutClick}/>
          }else {
              button = <LoginButton onClick={this.handleLoginClick} />
          }
          return (
           	<div><Greeting isLoggedIn={isLoggedIn} />{button}</div>
          )    
      }
  }
  ReactDOM.render(<LoginControl />,document.getElementById('root'))
  ```

- 与运算符&&

  ```js
  function Mailbox(props) {
    const unreadMessages = props.unreadMessages;
    return (
      <div>
        <h1>Hello!</h1>
        //条件是true&右边被渲染 条件是false返回false
        {unreadMessages.length > 0 && <h2>You have {unreadMessages.length} unread messages.</h2>}
  	</div>
    )
  }
  
  const messages = ['React', 'Re: React', 'Re:Re: React']
  ReactDOM.render(<Mailbox unreadMessages={messages} />,document.getElementById('root'))
  ```

- 三目运算符

  ```js
  render() {
    const isLoggedIn = this.state.isLoggedIn;
    return (
      <div>
        {isLoggedIn ? <LogoutButton onClick={this.handleLogoutClick} /> : <LoginButton onClick={this.handleLoginClick} />}
      </div>
  	)
  }
  ```

- 阻止组件渲染

  隐藏组件可以通过render()返回null实现

  ```js
  function WarningBanner(props) {
    if (!props.warn) {
        return null
    }
    return (
      <div className="warning">
        Warning!
      </div>
    )
  }
  
  class Page extends React.Component {
    constructor(props) {
      super(props);
      this.state = {showWarning: true}
      this.handleToggleClick = this.handleToggleClick.bind(this)
    }
    handleToggleClick() {
      this.setState(state => ({
        showWarning: !state.showWarning
      }))
    }
    render() {
      return (
        <div>
          <WarningBanner warn={this.state.showWarning} />
  		<button onClick={this.handleToggleClick}>
            {this.state.showWarning ? 'Hide' : 'Show'}
          </button>
        </div>
      )
    }
  }
  
  ReactDOM.render(<Page />,document.getElementById('root'))
  ```

##### 列表和key

渲染多个组件

```js
const number = [1,2,3,4]
const listItems = numbers.map((number)=><li>number</li>)
                              
ReactDOM.render(<ul>{listItems}</ul>,document.getElementById('root'))                            
```

基础列表组件

```js
function NumberList(props) {
  const numbers = props.numbers
  //key值必须提供
  const listItems = numbers.map((number) =>
    <li key={number.toString()}>{number}</li>
  )
  return (
    <ul>{listItems}</ul>
  )
}

const numbers = [1, 2, 3, 4, 5]
ReactDOM.render(<NumberList numbers={numbers} />,document.getElementById('root'))
```

**key**

react通过key识别哪些元素改变了，一个元素的key最好是这个元素在列表中独一无二的字符串，通常使用数据的id作为元素的key。如果项目顺序可能会发生变化不建议使用索引作为key。

元素的key只有放在就近数组上下文才有意义

```js
function ListItem(props) {
  //这里不需要指定 key：
  return <li>{props.value}</li>
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // 正确！key 应该在数组的上下文中被指定
    <ListItem key={number.toString()} value={number} />
  )
  return (
    <ul>
      {listItems}
    </ul>
  )
}

const numbers = [1, 2, 3, 4, 5]
ReactDOM.render(<NumberList numbers={numbers} />,document.getElementById('root'))
```

key使用注意事项

- key只是在兄弟节点中唯一，不需要全局唯一
- key会传递信息给react不会传递给组件，组件需要使用key属性的值时需要属性名显式传递key值

JSX允许在大括号中嵌入任何表达式，不能放任何语句

```js
function NumberList(props) {
  const numbers = props.numbers
  return (
    <ul>
      {numbers.map((number) =><ListItem key={number.toString()}value={number} />)}
    </ul>
  )
}
```

##### 表单

受控组件：渲染表单的react组件还控制着用户输入过程中表单发生的操作，这种被控制取值的表单输入元素就是受控组件

```js
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''}
    this.handleChange = this.handleChange.bind(this)
    this.handleSubmit = this.handleSubmit.bind(this)
  }
  handleChange(event) {
      this.setState({value: event.target.value})
  }
  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault()
  }
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        //this.state.value使state称为唯一数据源
        <label>
          名字:
          <input type="text" value={this.state.value} onChange={this.handleChange} /></label>
        <input type="submit" value="提交" />
      </form>
    )
  }
}
```

- textarea标签  react中`<testarea>`使用value定义其文本

- select标签 react中不会使用selected属性，而在根select标签上使用value属性，可以将数组传递到value属性中来支持select标签选择多个选项
- 文件input标签 由于`<input type="file/>"`的value只读，所以是一个非受控组件

处理多个输入

需要处理多个input元素时，可以给每个元素添加name属性，让处理函数根据event.target.name的值选择执行的操作

```js
class Reservation extends React.component{
    constructor(props){
        super(props)
        this.tate = {
            isGoing:true,
            numberOfGuest:2
        }
        this.handleInputChange = this.handleInputChange.bind(this)
    }
    handleInputChange(event){
        const target = event.target
        const value =target.name === 'isGoing'?target.checked : target.value
        const name = target.name
        this.setState([name] : value)
    }
    render(){
        return(
        	<form>
            	<label>参与：<input name="isGoing" type="checkbox" checked={this.state.isGoing} onChange={this.handleInputChange} /></label>
				<br/>
            	<label>来宾人数:<input name="numberOfGuests" type="number" value={this.state.numberOfGuests}  onChange={this.handleInputChange}/>
            </form>
        )
    }
}
```

受控组件上指定value的prop会阻止yoghurt更改输入，value设置为undefined或null后恢复可编辑

低版本react中如果给一个非受控input设置了ref值为username，那么可以通过this.refs.username获取到对应的真实DOM元素，高版本使用`<input type="text" ref={input=>this.username=input}/> ` ref中的函数会在此虚拟dom转为真实dom并插入页面时执行

##### 状态提升

状态提升是多个组件共享的state向上移动到它们最近共同父组件中，来实现共享state。

```js
function tryConvert(temperature,convert){
    //温度转换
    const input = parseFloat(temperature)
    if(Number.isNaN(input)) return ''
    const output = convert(input)
    const rounded = Math.round(output*1000)/1000
    return rounded.toString()
}
function toCelsius(fahrenheit){
    //转为摄氏
    return (fahrenheit-32)*5/9
}
function toFahrenheit(celsius){
    //转为华氏
    return (celsiue*9)/5+32
}
//水状态提示组件
function BoilingVerdict(props) {
  if (props.celsius >= 100) {return <p>水开了</p>}
  return <p>水没开</p>
}

//input组件
class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this)
  }

  handleChange(e) {this.props.onTemperatureChange(e.target.value)}

  render() {
    const temperature = this.props.temperature
    const scale = this.props.scale
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}:</legend>
        <input value={temperature} onChange={this.handleChange} />
      </fieldset>
    )
  }
}
//父组件
class Calculaator extends React.Component{
    constructor(props){
        super(props)
        this.handleCelsiusChange = this.handleCelsiusChange.bind(this)
    	this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this)
    	this.state = {temperature: '', scale: 'c'}
    }
    handleCelsiusChange(temperature) {this.setState({scale: 'c', temperature})}
    handleFahrenheitChange(temperature) {this.setState({scale: 'f', temperature})}
    render(){
        const scale = this.state.scale
        const temperature = this.state.temperature
        const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;                 const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature
        return (
        	<div>
            	<TemperatureInput scale='c' temperature={celsius} onTemperatureChange={this.handleCelsiusChange} />
            	<TemperatureInput scale='f' temperature={fahrenheit} onTemperatureChange={this.handleFahrenheitChange} />
                 <BoilingVerdict celsius={parseFloat(celsius)} />
            </div>
        )
    }

}
```

#### 高级

##### 生命周期

```js
class Counter extends React.Component{
    //静态属性 默认属性对象
    static defaultProps = {name:'test'}
	constructor(props){
        super(props)
        //初始化默认状态对象
        this.state = {number:0}
        console.log('1.constructor构造函数')
    }
	componentWillMount(){ //取本地数据 同步 渲染之前获取数据只渲染一次
        console.log('2.组件即将加载')
    }
	componentDidMount(){
        console.log('4.组件挂载完成')
    }
	handleClick = () =>{
        this.setState({number:this.state.number+1})
    }
    destory = () =>{
        //卸载组件
        ReactDOM.unmountComponentAtNode(document.querySelector('#root'))
    }
    //询问组件是否被更新，当组件的属性或者状态发生了改变默认就会重新渲染
    shouldComponentUpdate(nextProps,nextState){
        console.log('5.组件是否更新')
        return nextState.number%2 
        //return nextState.number !== this.state.number
        //如果返回false render不会调用
    }
	componentWillUpdate(){
        console.log('6.组件将要更新')
    }
	componentDidUpdate(){
        console.log('7.组件完成更新')
    }
	componentWillUnmount(){
        console.log('组件被销毁')
    }
	render(){
        console.log('3.render')
        return (
        	<div>
            	<p>{thi.state.number}</p>
            	{this.state.number}>3?num:<ChildCounter n ={this.state.number}
				<button onClick={this.handleClik}>+</button>
				<button onClick={this.destory}>销毁</button>
            </div>
        )
    }
}
class ChildCounter extends Component{
    componentWillReceiveProps(){
        //子组件将接收到父组件传入的新属性时执行
        console.log('subCounter componentWillReceiveProps')
    }
    render(){
        return (
        	<div>子计数:{this.props.count}</div>
        )
    }
}
```

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\react生命周期.png)

V17可能会废弃的三个⽣命周期函数⽤getDerivedStateFromProps替代，⽬前使⽤的话加上`UNSAFE_`：

- componentWillMount

- componentWillReceiveProps

- componentWillUpdate

如果不想⼿动给将要废弃的⽣命周期添加 UNSAFE_ 前缀，可以⽤`npx react-codemod rename-unsafe-lifecycles <path>`

引⼊两个新的⽣命周期函数：

- static getDerivedStateFromProps(props, state) 在调⽤ render ⽅法之前调⽤，并且在初始挂载及后续更新时都会被调⽤。它返回⼀个对象来更新 state，如果返回 null 则不更新任何内容

- getSnapshotBeforeUpdate(prevProps, prevState)  在render之后，在componentDidUpdate之前。在最近⼀次渲染输出（提交到 DOM 节点）之前调⽤。它使得组件能在发⽣更改之前从 DOM 中捕获⼀些信息（例如，滚动位置）。此⽣命周期的任何返回值将作为参数传递给 componentDidUpdate(prevProps, prevState, snapshot)

##### refs&dom

refs允许我们访问DOM节点或在render中创建的react元素

```js
//refs使用
const FancyButton = React.forwardRef((props, ref) => (  //ref挂载完成 ref.current指向button节点
    <button ref={ref} className="FancyButton">    {props.children}
  </button>
));

//创建一个react ref并赋值给ref变量
const ref = React.createRef()
//指定ref为jsx属性
<FancyButton ref={ref}>Click me!</FancyButton>

```

1. 创建refs 

   使用React.createRef()创建

2. 使用refs

   - 字符串类型的refs 不建议使用

     ```js
     class Greeting extends React.Component {
         constructor(props) {
             super(props);
         }
         handleClick() {
             this.refs.inputTest.focus();
         }
         render() {
             return (
                 <div>
                     <input type="text" ref="inputTest" />
                     <input type="button" value="点我输入框获取焦点" onClick={this.handleClick.bind(this)} />
                 </div>
             );
         }
     }
     ```

   - 回调函数 ref传递一个函数

     ```js
     class TextInput extends React.Component {
         constructor(props) {
             super(props);
             this.textInput = null;
             this.setTextInput = ele => {
                 this.textInput = ele;
             }
             this.focusTextInput = () => {
                 if (this.textInput) {
                     this.textInput.focus();
                 }
             }
         }
     
         render() {
             return (
                 <div>
                     <input type="text" ref={this.setTextInput} />
                     <input type="button" value="点我输入框获取焦点" onClick={this.focusTextInput}/>
                 </div>
             );
         }
     }
     ```

     

   - React.createRef()

     ```js
     class TextInput extends React.Component {
         constructor(props) {
             super(props);
             this.handleClick = this.handleClick.bind(this);
             // 通过React.createRef();来创建Refs
             this.textInput = React.createRef();
         }
         handleClick() {
             // 通过 this.textInput.current访问Dom节点
             this.textInput.current.focus();
         }
         render() {
             return (
                 <div>
                     <input type="text" ref={this.textInput} />
                     <input type="button" value="点我输入框获取焦点" onClick={this.handleClick}/>
                 </div>
             );
         }
     }
     ```

3. 注意事项

   - 可以在类组件上使用ref属性
   - 不能在函数组件上使用ref属性
   - 可以在函数组件内部使用ref属性只要它指向一个DOM元素或class组件

##### pureComponent

React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate() ，⽽ React.PureComponent 中以浅层对⽐ prop 和 state 的⽅式来实现了该函数。

>React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层⽐较。如果对象中包含复杂的数据结构，则有可能因为⽆法检查深层的差别，产⽣错误的⽐对结果。仅在你的props 和 state 较为简单时，才使⽤ React.PureComponent ，或者在深层数据结构发⽣变化时调⽤ forceUpdate() 来确保组件被正确地更新。可以考虑使⽤ immutable 对象加速嵌套数据的⽐较。
>
> React.PureComponent 中的 shouldComponentUpdate() 将跳过所有⼦组件树的 prop更新。因此，请确保所有⼦组件也都是“纯”的组件。

实现性能优化

```js
import React, { Component, PureComponent } from "react";
export default class PureComponentPage extends PureComponent {
 constructor(props) {
	 super(props)
     //浅比较
 	 this.state = { counter: 0}
 }
    
 setCounter = () => {
		 this.setState({ counter: 100,})
 }
 
 render() {
	 const { counter, obj } = this.state;
 	 console.log("render");
	 return (
 			<div>
				 <h1>PuerComponentPage</h1>
				 <div onClick={this.setCounter}>counter: {counter}</div>
			</div>
	 )
 }
}
```

##### hook

hook是一个特殊的函数，可以通过hook购入react的特性。**Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）**。只能在函数最外层调⽤ Hook，不要在循环、条件判断或者⼦函数中调⽤。只能在 **React** 的函数组件中调⽤ Hook，不要在其他 JavaScript 函数中调⽤。（还有⼀个地⽅可以调⽤ Hook —— 就是⾃定义的 Hook 中）

1. effect hook

   eddect hook给函数组件增加了操作副作用的能力，跟 class 组件中的 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount` 具有相同的用途，只不过被合并成了一个 API。

   默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。副作用函数还可以通过返回一个函数来指定如何“清除”副作用。数据获取、设置订阅、手动更改react组件中的DOM都是副作用。

2. state hook

   ```js
   import React, { useState } from "react";
   export default function HookPage(props) {
    // 声明⼀个叫 “count” 的 state 变量，初始化为0
    	const [count, setCount] = useState(0);
    	return (
    		<div>
    			<h3>HookPage</h3>
    			<p>{count}</p>
    			<button onClick={() => setCount(count + 1)}>add</button>
   		</div>
    	)
   }
   ```

在函数组件主体内（这⾥指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录⽇志以及执⾏其他包含副作⽤的操作都是不被允许的，使⽤ useEffect 完成副作⽤操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执⾏。

**effect的条件执行**

通过给useEffect传递第⼆个参数，它是 effffect 所依赖的值数组

```js
import React, { useState, useEffect } from "react";
export default function HookPage(props) {
    // 声明⼀个叫 “count” 的 state 变量，初始化为0
	const [count, setCount] = useState(0);
	const [date, setDate] = useState(new Date());
 	// 与 componentDidMount 和 componentDidUpdate相似
	useEffect(() => {
		// 更新 title
		document.title = `You clicked ${count} times`
 	}, [count]) //count值改变才更新
 	useEffect(() => {
 		const timer = setInterval(() => {
 			setDate(new Date())
 		}, 1000)
 	}, [])
 	return (
 		<div>
 			<h3>HookPage</h3>
			 <p>{count}</p>
			 <button onClick={() => setCount(count + 1)}>add</button>
			 <p>{date.toLocaleTimeString()}</p>
 		</div>
 	)
}
```

**清除effect**

```js
useEffect(() => {
 const timer = setInterval(() => {
 setDate(new Date())}, 1000)
 return () => clearInterval(timer)
}, [])
```

自定义hook

在组件之间重用一些状态逻辑类似高阶组件和render props，自定义hook是一个函数，名称以use开头，内部可以调用其他的hook

```js
function useClock() {
 const [date, setDate] = useState(new Date())
 useEffect(() => {
 	console.log("date effect")
 	const timer = setInterval(() => {
 		setDate(new Date());
 	}, 1000);
 	return () => clearInterval(timer)
 }, [])
 return date
}
```

hook api

- useMemo

  ```js
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])
  ```

  把“创建”函数和依赖项数组作为参数传⼊ useMemo ，它仅会在某个依赖项改变时才重新计算memoized 值。这种优化有助于避免在每次渲染时都进⾏⾼开销的计算。传入 `useMemo` 的函数会在渲染期间执行

- useCallback

  ```js
  const memoizedCallback = useCallback(
    () => {doSomething(a, b)},
    [a, b],
  )
  ```

  把内联回调函数及依赖项数组作为参数传⼊ useCallback ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使⽤引⽤相等性去避免⾮必要渲染（例如 shouldComponentUpdate ）的⼦组件时，它将⾮常有⽤

#####类型检测

 react内置了类型检测的功能，在组件里进行类型检测使用propTypes属性

- .array 数组
- .bool布尔值
- .func函数
- .number数字
- .object对象
- .string字符串
- .symbol符号
- .node 任何东西都可以被渲染
- .element react元素
- .instanceOf(message)类的一个实例
- .oneOf(['news','photos']) 枚举值
- .oneOfType([proTypes.string,proTypes.string])多种类型之一
- .arrayOf()某种类型的数组
- .objectOf()某种类型的对象
- .shape(fontSize:propTypes.number)特定形式的对象
- .func.isRequired可以使用'isRequired'上任意一个，确保在没有提供prop的情况下显示警告
- .any.isRequire任何数据类型的值
- function(props,propName,componentName){return new Error()}自定义的验证器
- .arrayOf(function(propValue,key,componentName,location,propFullName)){}

```js
import PropTypes from 'prop-types'

class Person extends React.component{
    static propTypes = {
        name:PropTypes.string.isRequired,
        age(props,propName,componentName){
            let age = props[propName],
            if(age<0||age>120){
                return new Error(`invaild prop ${propName} suppliento ${componentName}`)
            }    
        },
        gender:ProTypes.oneOf(['男','女']),
        hobby:proTypes.array,
        position:ProTypes.shape({x:ProTypes.number,y:ProTypes.number})
    }
}
```

##### 优化性能

react最大限度减少更新UI所需单独DOM操作数量

1. 使用生产版本

   最好在开发应用时使用开发模式，部署应用时切换生产模式

   Create ReactApp ` npm run build`

   单文件构建

   ```js
   <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
   <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
   ```

   webpack

   ```js
   new webpack.definePlugin({
       'process.env':{NODE_ENV:JSON.stringfy('production')}
   })
   new webpack.optimize.UglifyJsPlugin()
   ```

2. 使用Chrome性能分析工具分析组件性能

   - 通过添加?react_perf查询字段加载应用(http://localhost:3000?react_perf)
   - 打开chrome devtool perfomance点击record `timeline-tool`
   - 执行要分析的操作不超过20s
   - 停止记录
   - 在UserTiming标签下，react事件将会分组列出

3. 避免重新渲染

   当组件的props和state改变时，react通过比较新返回的元素和之前渲染的元素来决定是否有必要更细的呢DOM元素，二者不等时更新DOM元素
   
   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\should-component.png)
   
   - shouldComponentUpdate优化
   
     ```js
     handleClick = () =>{
         let todo = this.todo.value
         this.state.todos.push(todo)
         this.setState({todo:this.state.todos})
     }
     //重写来减少渲染 state不改变时不重新渲染
     shouldComponentUpdate(nextProps,nextState){
         if(nextState.todos === this.state.todos){
             return false
         }else{
             return true
         }
     }
     ```
   
   - React.PureComponent与React.Component完全相同，但是在shouldComponentUpdate中实现时，使用了props和state的浅比较
   
     ```js
     class PureComponent extends Component{
         shouldComponentUpdate(nextProps,nextState){
             for(let prop in nextProps){
                 //循环下一个新的state每一个属性，判断新的属性值和旧属性是不是同一个
                 if(nextProps[prop] !== this.props[prop]){
                     return true
                 }
             }
             for(let prop in nextState){
                 if(nextProps[prop] !== this.state[prop]){
                     return true
                 }
             }
             return false
         }
     }
     ```
   
   - React.memo
   
     React.memo为高阶组件，与React.pureComponent类似，适用于函数组件（不适用与calss组件）。若函数组件在相同props时渲染相同结果时可以包装在react.memo中调用，react将直接复用最近一次渲染的结果。默认为浅比较，第二个参数控制对比过程。
     
     ```js
   //memo使用
     const MemoCounter = memo(props=>{
       //return <div>{props.count}</div>
         return <div>{props.count.count}</div>
     },(prevProps,nextProps)=>{
     	return prevProps.count.count == nextProps.count.count
   })
     ```
     
   - useCallback
   
     把创建函数和依赖项作为参数传入useCallback，返回回调函数的memorized版本，回调函数只在某个依赖项改变时更新
     
     ```js
   const expensive = useCallback(()=>{
         let sum = 0
       for(let i=0;i<count;i++){
             sum+=i
         }
         return sum
       //count改变时才执行
     },[count])
     ```
     
     useCallback(fn,deps)相当于useMemo(()=>fn,deps)
     
   - useMemo
   
     把创建函数和依赖项作为参数传入usememo，它仅会在某个依赖项改变时重新计算memorized的值
     
     ```js
   const expensive = useMemo(()=>{
         let sum = 0
       for(let i=0;i<count;i++){
             sum+=i
         }
         return sum
       //count改变时才执行
     },[count])
     ```
     
   - 使用Immutable数据结构
   
     - 不可变 一个集合一旦创建在其他时间不可更改，对Immutable对象的任何修改或添加删除都会返回一个新的Immutable对象
     - 持久的 新的集合可以基于之前的集合创建并发生突变
     - 结构共享 新的集合尽可能通过之前相同的结构创建，最小程度地减少复制操作提高性能
   
     ```js
   import {is} from 'Immutable'
     shouldComponentUpdate:(nextProps,nextState)=>{
       return !(this.props === nextProps || is(this.props,nextProps) || !(this.state === next.state || is(this.state,nextState)))
     }
   
     //优化为
     this.setState({data:this.state.data.update('counter',counter=>counter+1)})
     ```
     
     Immutable Data实现原理是Perssient Data Struture（持久化数据结构） 使用旧数据创建新数据时保证旧数据可用且不变，同时为了避免deepCopy把所有节点赋值一遍带来的性能损耗，Immutable使用了结构共享，即对象树种一个节点发生变化只修改这个节点和受它影响的父级节点，其他节点则共享。
     
     **Immutable类库**
     
   - Immutable.js  实现了完整的Persistent Data Structure还有很多易用的数据类型(collection、list、Map、Set、Record、Seq)
     
     ```js
       let Immutable = require('Immutable')
       let objA = Immutable.fromJS({info:{age:8}})
       let objB = objA.setIn(['info','age'],9)
       console.log(objA.getIn(['info','age']))
       console.log(objA.getIn(['info','age']))
       console.log(objA===objB)
     ```
   
     - seamless-immutable 使用Object.defineProperty扩展了JS的Array和Object实现，只支持Array和Object
   
       ```js
     let Immutable = require('seamless-imutable')
       let objA = Immutable({info:{age:8}})
       let objB = objA.merge({info:{age:9}})
       console.log(objA.info.age)
       console.log(objB.info.age)
       ```
   
     Immutable优势
   
     - 降低复杂度
     
       ```js
       let obj = {age:8}
       handle(obj)
       connsole.log(obj.age)
       ```
     ```
     
     - 减少内容
     
       ```js
       let Immutable = require('immutable')
       let p1 = Immutable.fromJS({name:'test',home:{name:'hello'}})
       let p2 = p1.set('name','test2')
       console.log(p1.get('home')==p2.get('home'))
     ```
     
     - 方便回溯
   

常用API

```js
//直接比较对象的值
Immutable.is(map1,map2)
```

```js
//Map() 原生obj转Map对象 只会转换第一层
Immutable.Map({name:'test',age:8})
//List() 原生array转List对象 只会转换第一层
Immutable.List([1,2,3,4,5])
//fromJS() 原生js转Immutable对象 深度转换 会将内嵌套的对象数组全不转为Immutable
Immutable.fromJS([1,2,3,4])
Immutable.fromJS({name:'test',age:10})
//Immutable对象转为原生js 深度转换会将内部潜逃的MapList全部转为js
Immutable.toJS()
//查看list或者map大小
Immutable.size 或 Immutable.count()
//merge()对象合并
let imA = Immutable.fromJS({a:1,b:2})
let imB = Immutable.fromJS({c:3})
let imC = imA.merge(imB)
console.log(imC.toJS())
//增删改查 所有操作都会返回新的值不会修改原来的值
let ImmutableData = Immutable.fromJs({a:1,b:2,c:{d:3}})
let data1 = ImmutableData.get('a') 
let data2 = ImmutableData.getIn(['c','d']) //getIn用于深层结构
let data3 = ImmutableData.set({a:2}) 
let data4 = ImmutableData.setIn(['c','d'],4) 
let data5 = ImmutableData.update('a',function(x){return x+4})
let data6 = ImmutableData.updateIn(['c','d'],function(x){return x+4})
let data7 = ImmutableData.delete('a')
let data8 = ImmutableData.deleteIn(['c','d'])
```

##### Reconciliation

当比较不同的两个树，react首先比较两个根元素，根矩根元素的类型不同，做不同的操作。

- 当根元素类型不同时，react会销毁原先的树并重新构建新的树
- 当比较两个相同类型的ReactDOM元素时，react检查他们的属性，保留相同的底层DOM节点，只更新发生改变的属性
- 当一个组件更新时组件实例保持不变，以便渲染中保持state，react会更新组件实例的属性来匹配新的元素，并在元素实例上调用componentWillReceiveProps()和componentWillUpdate()
- 默认情况当递归一个DOM节点的子节点时，react只要同时遍历所有孩子节点同时生成一个改变节点
- keys用来指示在不同的渲染中哪个保持不变

##### 上下文

使用Context来在整个组件树中传递数据

- react.createContext 创建一个Context对象 当react渲染一个订阅了此Context对象的组件，这个组件会从组件数中离自身最近的provider中读取到 当前的context值
- Context.provider 接受一个value属性，传递给消费组件允许消费组件订阅 context 的变化。⼀个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使⽤，⾥层的会覆盖外层的数据
- context.contextType 挂载在 class 上的 contextType 属性会被重赋值为⼀个由React.createContext() 创建的 Context 对象。这可以通过this.context 来消费最近 Context 上的那个值，在任何⽣命周期中访问到它，包括 render 函数中。
- context.consumer 这个函数接收当前的 context 值，返回⼀个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的Provider，value 参数等同于传递给 createContext() 的defaultValue

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'
class Header extends Component{
    render(){
        return (<div><Title/></div>)
    }
}
class Title extends Component{
    //定义接受子上下文对象的属性
    static contextTypes={color:ProTypes.string,setColor:propTypes.func}
	render(){
        return (<div style={color:this.context.color}>Title</div>)
    }
}
class Content extends Component{
    //定义接受子上下文对象的属性
    static contextTypes={color:ProTypes.string,setColor:propTypes.func}
	render(){
        return (
            <div>
            	<h1 style={color:this.context.color}>Content</h1>
				<button onClick={()=>this.context.setColor('blue')}>blue</button>
				<button onClick={()=>this.context.setColor('green')}>green</button>
			</div>)
    }
}
class Main extends Component{
    render(){
        return (<div><Content/></div>)
    }
}
class HomePage extends Component{
    //定义子上下文类型 
    static childContentType = {color:ProTypes.string,setColor:propTypes.func}
	constructor(props){
        super(props)
        this.state = {color:'red'}
    }
	//定义方法返回上下文对象
	getChildContext(){
        return { color:this.state.color,setColor:this.setColor}
    }
	setColor = (color)=>{
        this.setState({color})
    }
	render(){
        return (<div><Header/><Main/></div>)
    }
}
```

##### 片段

片段可以把子元素列表添加到一个分组中并且不会在DOM中增加额外节点

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
class List extends Component{
    render(){
        return (
            //可以简写为<></>
        	<React.Fragment>{this.props.todos.map(item=><li>{item}</li>)}</React.Fragment>
        )
    }
}
class Todos extends Component{
    constructor(){
        super()
        this.state = {todos:['a','b','c']}
    }
    render(){
        return (
        	<ul><List todo={this.state.todos}/></ul>
        )
    }
}
ReactDOM.render(<Todos/>,document.getElementById('#root'))
```

##### 插槽

portals可以将子节点渲染到父组件DOM层次结构之外的DOM节点

`ReactDom.createPortal(child,container)`

- 第一个参数是任何可渲染的react子元素
- 第二个参数是一个DOM元素

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
class Modal extends Component{
    constructor(){
        super()
        this.modal = document.querySelector('Modal-root')
    }
    render(){
        return ReactDOM.createPortal(this.props.children,this.modal)
    }
}
class Page extend Component{
    constructor(){
        super()
        this.state = {show:false}
    }
    handleClick = () => {
        this.setState({show:!this.state.show})
    }
    render(){
        return (
        	<div>
            	<button conClick={this.handleClick}>显示模态窗口</button>
    			{
                    this.state.show && <Modal>
                    <div id='modal' className='modal'></div>     
                }
            </div>
        )
    }
}
```

##### 错误边界

部分UI的js错误不会破坏整个应用程序

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
class ErrorBoundary extends Component{
    constructor(props){
        super(props)
        this.state = {hasError:false}
    }
    componentDidCatch(err,info){
        this.setState({hasError:true})
    }
    render(){
        if(this.state.hasError){
            return <h1>wrong</h1>
        }
        return this.props.children
    }
}
class Page extends Component{
    render(){
        return (
        	<ErrorBoundary><Clock/></ErrorBoundary>
        )
    }
}
class Clock extends Component{
    render(){
        return (<div>{null.toString()}</div>)
    }
}
ReactDOM.render(<Page/>document.wuerySelector('#root'))
```

##### 高阶组件

高阶组件就是一个普通的函数 传入一个组件返回一个新的组件，可以链式调用

```js
const NewComponent = higherOrderComponent(OldComponent)
```

```js
const foo = cmp => props =>{
    //双箭头函数
    return (
    	<div className='green'>
        	<Cmp {...props}/>
        </div>
    )
}
```

高阶组件装饰器

高阶组件本身是对装饰模式的应用，可以利用es7中装饰器来写

`npm i -D @babel/plugin-proposal-decorators`

更新config-overrirides.js

```js
//配置后需重启
const {addDecoratorsLegacy} require('customize-cra')
module.export = override(
	...
    addDecoratorsLegacy() //配置装饰器
)
```

vscode对装饰器有warning时设置`'javascripConfig.implicitProjectConfig.experimentalDecorators':true`

```js
@foo
class Child extends Component{
    render(){
        return (
        	<div>child</div>
        )
    }
}
//使用时直接使用child组件
```

高阶组件注意事项

**不能在render中使用**  diff算法使用组件标识来确定它是应该更新现有子树还是丢弃并挂载新子树。如果从render返回的组件与前一个渲染中的组件相同，react通过将子树和新子树区分来递归更新子树，不相等会完全卸载前一个子树。

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
export default (wrappedComponent,name)=>{
    class HigherOrderComponent extends Component{
        constructor(){
            super()
            this.state = {date:''}
        }
        componentWillMount(){
            let data = localStorage.getItem(name)
            this.setState({data})
        }
        render(){
            return <wrappedComponent data={this.state.data}/>
        }   
    }
    return HigherOrderComponent   
}
```

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
import wrapLocalData from './wrapLoaclData'
let UserName = (props) => {
    return <input type="text" defaultValue={props.data}
}
let Password= (props) => {
    return <input type="text" defaultValue={props.data}
}
let NewUserName = wrapLocalData(UserName,'username')
let NewPassword = wrapLocalData(Password,'Password')
class Form extends component{
    render(){
        return (
        	<form>
            	<NewUserName />
            	<NewPassword />
            </form>
        )
    }
}
ReactDOM.render(<Form/>,document.querySelector('#root'))
```

```js
import React,{Component} from 'react'
import ReactDOM from 'react-dom'
export default (WrappedComponent,name) => {
    class HigherOrderComponent extends Component{
        constructor(){
            super()
            this.state = {data:''}
        }
        componentWillMount(){
            fetch('./data.json',{methos:'GET'}).then(response => response.json()).then(data=>{
                this.setState({data:data[name]})
            })
        }
        save = (event)=>{localStorage.setItem(name,event.target.value)}
        render(){
            return <OldComponent data={this.state.data} save={thi.save}
        }
    }
}
```

表单组件设计实现

```js
export default function kFormCreate(cmp){
    return class extends Component{
        constructor(props){
            super(props)
            this.state = {}
            this.options = {}
        }
        handleChange = e=>{
            let {name,value} = e.target
            this.setState({[name]:value})
        }
        getFieldDecorator = (filed,option) => {
            this.options[field] = option
            return InputCmp => {
                return React.cloneElement(InputCmp,{
                    name:filed,
                    value: this.state[filed] || '',
                    onChange:this.handleChange
                })
            }
        }
        getFieldsValue=()=>{
            return {...this.state}
        }
        getFieldValue=(field)=>{
            return this.state[field]
        }
        validateFields = callback =>{
            //校验错误信息
            const errors = {}
            const state = {...this.state}
            for(let name in this.options){
                if(state[name] === undefined){
                    errors[name] = 'error'
                }
            }
            if(JSON.stringfy(errors) === '{}'){
                callback(undefined,state)
            }else{
                callback(errors,state)
            }
        }
        render(){
            return (
            	<div className='border'>
                	<Cmp getFieldDecorator={this.getFieldDecorator} getFieldsValue={this.getFieldsValue}/>
                </div>
            )
        }
    }
}
```

弹窗组件

portal react v16后出现的portal可以实现内容传送功能

```js
import React,{Component} from 'react'
import {createPortal} from 'react-dom'

export default class Dialog exentends Component{
    constructor(props){
        super(props)
        const doc = window.document
        this.node = doc.createElement('div')
        doc.body.appendChild(node)
    }
    componentWillUnmount(){
        window.document.body.removeChild(this.node)
    }
    render(){
        return createPortal(
        	<div className='dialog'>dialog{this.props.children}</div>,
            this.node
        )
    }
}
```

##### 事件系统

react通过合成事件对象提供全浏览器一致的事件系统

react合成事件与原生事件对应关系存放在react事件插件(eventPlugin)中，事件插件是不同事件处理函数封装的模块，每个模块只处理对应的合成事件。react启动时注册完所有事件插件，并在eventPluginRegistry里初始化全局对象。

- registrationNameModule（react事件到plugin的映射包含react支持的所有事件类型）用来判断组件的props是否是事件类型。
- registrationNameDependencied 合成事件到原生事件的映射
- plugins 注册的所有插件列表 eventplugin{eventTypes,extractEvents} eventTypes数组包含了所有合成事件相关信息，extractEvents函数当原生事件触发时执行

1. 绑定事件

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\reactEvent.jpg)

   - react执行diff操作标记哪些dom类型节点需要添加或更新
   - 检测到需要创建或更新节点时，使用registrationNameModule查看一个prop是不是事件类型
   - prop为事件类型时通过registrationNameDependencies检查react事件依赖的原生事件类型
   - 检查这些原型事件类型有没有注册过，有的话忽略
   - 没有注册过就注册这个原生事件到document上，回调为react提供的dispatchEvent()

2. 触发事件

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\reactEvent2.jpg)

   - 事件被触发执行dispatchEvent
   - dispatchEvent执行batchedEventUpdates(handleTopLevel)，batchedEventUpdates会打开批量渲染开关调用handleTopLevel
   - hanfdleTopLevel依次执行plugins里所有事件插件
   - 插件检测到需要处理的是事件类型时，通过原生事件类型决定使用哪种合成事件类型，如果对象池里有这个类型的实例，取出实例覆盖属性，作为本次派发的事件对象，没有的话新建实例。

   从点击的原生事件中找到对应 DOM 节点，从 DOM 节点中找到一个最近的React组件实例， 从而找到了一条由这个实例父节点不断向上组成的链， 这个链就是我们要触发合成事件的链，(只包含原生类型组件， `div`， `a` 这种原生组件)。反向触发这条链，父-> 子，模拟捕获阶段，触发所有 props 中含有 `onClickCapture` 的实例。正向触发这条链，子-> 父，模拟冒泡阶段，触发所有 props 中含有 `onClick` 的实例。

#### 路由

react-router包含3个库，react-router react-router-dom和react-router-native react-router提供最基本的路由功能，实际使用不会直接安装react-router，而是根据应用运行的环境选择安装react-router-dom(在浏览器中使用)或react-router-native(在rn中使用)。

react-router-dom和react-router-native都依赖react-router所以在安装时react-router也会自动安装。

##### 1. 安装

   `npm i react-router-dom --save`

   容器组件的区别

   - BrowserRouter 浏览器自带的H5API需要后台配合

   - HashRouter 使用hash方式进行路由 路径后均有#

     browerRouter与hashRouter的对比

	- hashRouter最简单不需要服务器端渲染，靠浏览器的#来区分path就可以 browserRouter需要服务器端对不同的url返回不同的html后端配置即可
	- browserRouter使用html5 history API(pushState/replaceState/popState事件)让页面的UI与url同步
	- hashRouter不支持location.key和location.state动态路由跳转需要通过?传递参数
	- hashHistory不需要服务器任何配置就可以运行
	
	> 开发时一般使用HashRouter 上线后改用BrowserRouter


react-router中一切皆组件 路由器Router 链接Link 路由Route 独占Switch 重定向Redirect都以组件形式存在

##### 2. 使用

route有三种渲染内容的方式 ，route渲染优先级children>component>render 三种方式互斥只能使用一种

- children 不管location是否匹配都有渲染一些内容
- component 只有location匹配时渲染
- render 用render是调用的只是个函数，只在location匹配的时候渲染

   ```js
   import React,{Component} from 'react'
   import ReactDOM from 'react-dom'
   import {HashRouter,Route} from 'react-router-dom'
   let Home = ()=> <div>home</div>
   let User = ()=> <div>user</div>
   let Profile = ()=> <div>profile</div>
   ReactDOM.render(
   	<HashRouter>
       	<div>
           //exact精确匹配
       		<Route exact path='/home' component={Home}/>
   			<Route path='/user' component={User}/>
            <Route path='/profile' component={Profile}/>    
       	</div>
       </HashRouter>
   	document.getElementById('#root')
   )
   ```

   ```js
   //hashRouter.js
   import React,{Component} from 'react'
   import PropTypes from 'prop-types'
   export default class HashRouter extends Component{
       static childContextTypes = { location: PropTypes.object}
   	constructor(props){
           super(props)
           this.state = {location:{pathname:window.location.hash.slice(1) || '/'}}
       }
   	getChildContext(){
           return location:this.state.location,
               	  history:{
                      push(path){
                          if(typeof path == 'object'){
                              let {pathname,state} = path
                              this.setState({location:{...this.state.location,state}},()=>{window.location.hash=pathname})
                          }else{
                              window.location.hash=path
                      	  }
                  }
       }
   	componentDidMount(){
           window.location.hash = window.location.hash || '/'
           let render = () =>{this.setState(location:{...this.state.Location,pathname:window.location.hash.slice(1) || '/'})}
           window.addEventListener('hashchange',render)
       }
   	render(){
           return this.props.children?React.Children.only(this.props.chhildren):null
       }
   }
   
   //route.js
   import React,{Component} from 'react'
   import PropTypes from 'prop-types'
   export default class Route extends Component{
       static contextTypes = {
           location:PropTypes.object,
           history:PropTypes.object
       }
       render(){
           let {path,component:Component} = this.props
           let {location:{pathname}} = this.context
           if( path == pathname || pathname.starsWith(path)){
               return <Component location={this.context.location} history={this.context.history}/>
           }
           return null
       }
   }
   ```

设定一个没有path的路由在路由列表最后面表示一定匹配

```js
//404页面
<Switch>
    <Route exact path='/' component={Home}/>
    <Route exact path='/user' component={User}/>
    <Route component={EmptyPage}/>    
</Switch>
```

##### 3. memoryRouter

把url的历史记录保存在内存中的`<Router>`(不读取不写入地址栏)。在测试和非浏览器环境中很有用(reactnative)

```js
import {memoryRouter} from 'react-router-dom'
<MemoryRouter><App/></MemoryRouter>
```

##### 4. link组件

   ```js
   import {Link} from 'react-router-dom'
   export default class App extends Component{
       render(){
           return (
             <HashRouter>
           	<div className="container">
               	<nav className="navbar">
               		<div className="container-fluid">
               			<div className="navbar-header">
               				<div className="navbar-brand">管理系统</div>
               			</div>
               			<ul class="nav navbar-nav">
               				<li><Link to="/home"/>首页</link></li>
               				<li><Link to="/User"/>用户</link></li>
               				<li><Link to="/profile"/>个人日志</link></li>
               			</ul>
               		</div>
               	</nav>
               	<div className='row'>
               		<div className='col-md-12'>{this.pops.children}</div>
               	</div>
               </div>
   		  </HashRouter>
           )
       }
   }
   ReactDOM.render(
   	<App>
       	<div>
       		<Route path='/home' component={Home}/>
   			<Route path='/user' component={User}/>
               <Route path='/profile' component={Profile}/>    
       	</div>
       </App>
   	document.getElementById('#root')
   )
   ```

   ```js
   import React,{Component} from 'react'
   export default class Link extends Component{
       static contextTypes={
           history:PropTypes.object
       }
       render(){
           return (
           	<a onClick={()=>this.context.history.push(this.props.to)}>{this.props.children}</a>
           )
       }
   }
   ```

##### 5. 二级路由

   ```js
   class User extends Component{
       render(){
           return (
           	<div classNamt="row">
               	<div className="rol-md-2">
               		<ul>
               			<li><Link to="/user/add">用户添加</Link></li>
               			<li><Link to="/user/list">用户列表</Link></li>
               		</ul>
               	</div>
               	<div className="rol-md-10">
               		<Route path="/user/add" component={UserAdd} />
   					<Route path="/user/list" component={UserList} />
                       <Route path="/user/detail/:id" component={UserDetail} />
               	</div>
               </div>
           )
       }
   }
   class UserAdd extends Component{
       handleSubmit = (event)=>{
           event.preventDefault()
           let username = this.username.value
           let user = {id:Date.now(),username}
           let userStr = localStorage.getItem('users')
           let users = userStr?JSON.parse(userStr):[]
           users.push(user)
           localStorage.setItem('users',JSON.stringify(users))
           this.props.history.push('/user/list')
           
       }
       render(){
           return (
           	<form onSubmit={this.handleSubmit}>
               	<div className="form-group">
                       <label>用户名</label>
   					<input className='form-control'>
                   </div>
   				<div className="form-group">
                       <input type='submit' className='btn btn-primary'>
                   </div>
               </form>
           )
       }
   }
   class UserList extends Component{
       constructor(){
           super()
           this.state = {user:[]}
       }
       componentDidMount(){
           let userStr = localStorage.getItem('users')
           let users = userStr?JSON.parse(userStr):[]
           this.setState({users})
       }
       render(){
           return (
           	<ul className='list-group'>{this.state.users.map((user,idx)=><li key={idx} class='list-group-item'>{user.username}</li>)}</ul>
           )
       }
   }
   ```

##### 6. 路径参数

   `npm i  path=to=regexp -s`

   ```js
   class UserDetail extends Component{
       constructor(){
           super()
           this.state = {user:{}}
       }
       componentDidMount(){
           let userStr = localStorage.getItem('users')
           let users = userStr?JSON.parse(userStr):[]
           let user = users.find(user=>user.id == this.paops.match.params.id)
           this.setState({user})
       }
       render(){
           return(
           	<div>{this.state.user.id}:{user.username}</div>
           )
       }
   }
   //改造列表
   class UserList extends Component{
       constructor(){
           super()
           this.state = {user:[]}
       }
       componentDidMount(){
           let userStr = localStorage.getItem('users')
           let users = userStr?JSON.parse(userStr):[]
           this.setState({users})
       }
       render(){
           return (
           	<ul className='list-group'>{this.state.users.map((user,idx)=><li key={idx} class='list-group-item'><Link to={'/user/detail/'+user.id}>{user.username}</Link></li>)}</ul>
           )
       }
   }
   //改route.js
   export default class Route extends Component{
       constructor(props){
           super(props)
           let {path} = props
           this.keys = []
           this.regexp = pathToRegexp(path,this.keys,{end:false})
           this.keys = this.keys.map(key=>key.name)
       }
       static contextTypes = {
           location:PropTypes.object,
           history:PropTypes.object
       }
       render(){
           let {path,component:Component} = this.props
           let {location:{pathname}} = this.context
           let result = location.pathname.match(this.regexp)
           let props = {
               location,
               history:this.context.history
           }
           if(result){
               let [url,...values] = result
               props.match = {url,path,params:this.keys.reduce((memo,key,idx)=>{memo[key] = values[idx] return memo},{})} 
               return <Component {...props}/>
           }else{
               return null
           }
          
           return null
       }
   }
   ```

   ```js
   let pathToRegexp = require('path-to-regexp')
   let str = 'user/detail/:id/:name'
   let keys = []
   let reg = pathToRegexp(str,keys,{end:false})
   keys = keys.map(key=>key.name)
   let link = 'user/detail/1/test'
   let [url,...values] = link.match(reg)
   let params = keys.reduce((memo,key,idx)=>{memo[key]=values[idx]},{})
   ```

##### 7. switch

   匹配一个后就停止匹配，不再匹配下一个路由

   ```js
import React,{Component} from 'react'
import PropTypes from 'prop-types'
import pathToRegexp from 'path-to-regexp'

export default class Switch extends Component{
    static contextTypes = {location:PropTypes.object}
	render(){
        let children = this.props.children
        let {pathname} = this.context.location
        for(let i=0;i<children.length;i++){
            let child = children[i]
            let {path} = child.props
            if(match(pathname,path)){
                return child
            }
        }
        return null
    }
}
function match(pathname,path){
    return pathToRegexp(path).test(pathname)
}
   ```

##### 8. 受保护的路由

- 执行对部分路由屏蔽操作eg:登录后访问，在本地存一个变量来表示是否登录，增加一个登录路由，点击登录按钮将本地变量改为登录成功状态即可以访问用户列表页面
- 匹配到/user路由时根据状态判断是否有权限，没有跳转登录页面
- Redirect组件是用来重定向的，增加form属性来记录当前匹配的url，为了保证登录后可以调回本页面
- 默认点击profile会跳转到Login组件中，点击登录可以再次跳回Profile来实现受保护的路由

```js
//protected.js
import React,{Component} from 'react'
import {Route,Redirect} from '../react-router-dom'

export default ({component:Component,...rest})=>{
    return <Route {...rest} render={props=>{
        localStorage.getItem('logined')?<Component {...props}/>:<Redirect to={{pathname:'/login',state:{from:props.location.pathname}}}
    }} />
}

export default class Login extends Component{
    handleClick = ()=>{
        localStorage.setItem('login',true)
        this.props.history.push(this.props.location.state.from)
    }
    render(){
        return (
        	<div>
            	<button onClick={this.handleClick} className='btn btn-primary'>登录</button>
            </div>
        )
    }
}
```

```js
//redirect.js
class Redirect  extends Component{
    static contextTypes = {history:PropTypes.object}
	ComponentWillMount(){
        this.context.history.push(this.props.to)
    }
	render(){
        return null
    }
}
```

##### 9. 自定义菜单

给点击后的菜单增加激活样式

```js
import React,{Component} from 'react'
import {Route,Link} from '../react-router-dom'
import './MenuLink.css'
export default ({to,children})=>{
    return <Route path={to} chidren={props=>{return <li className={'nav-item'+(props.match?'active':'')}><Link to={to} className="nav-link">{children}</Link></li>}}
}
```

>children属性与render不同 children无论是否路由匹配到都会执行此函数，render只要匹配后才会执行

##### 10. browserRouter原理

```js
//browserRouter.js
import {createBrowserHistory} from 'history'
export default class BrowserRouter extends Component{
    constructor(props){
        super(props)
        this.state = {location:this.history.location}
        this.history = createBrowserHistory()
        this.unlisten = this.history.listen(location=>{this.setState({location})})
    }
    componentWillUnmount(){
        if(this.unlisten){
            this.unlisten()
        }
    }
    render(){
        return <RouterContext.provider value={history:this.history,location:this.state.location}>{this.props.children}</RouterContext.provider>
    }
}
```


```js
//link.js
export default class Link extends Component{
    handleClick = (event,history) =>{
        event.preventDefault()
        history.push(this.props.to)
    }
    render(){
        const {to,children} = this.props
        return (
        	<RouterContext.Consumer>
            {context=>{
             	 <a href={to} onClick={event => this.handleClick(event,context.history)}>{children}</a>
            }}
            </RouterContext.Consumer>
        )
    }
}
```

```js
//route.js
//源码matchPath文件
import matchPath from './mathpath'
export default class Route extends Component{
    render(){
        return <RouterContext.Consumer>
            	{context=>{
                 	const {path,component,children,render} = this.props
        			//const match = window.location.pathname === path
        			const match = matchPath(location.pathname,this.props)
                    const location = context.location
                    const props = {
                        ...context,
                        location,
                        match
                    }
                 	//return match ? React.createElement(component,this.props) : null
                    return match ? (children ? (typeof children ==='function' ? children(props):children) : (component ? React.createElement(component,this.props) : (render ? render(props) : null))) : (typeof children === 'function' ? children(props):null)
                }}
               </RouterContext.Consumer>
    }
}
```

```js
//routerContext.js
export RouterContext = React.createContext()
```



#### dom-diff

virtual dom虚拟节点，通过js的object对象模拟DOM中的节点，再通过特点的render渲染成真实的DOM节点

dom diff通过JS层面的计算，返回一个patch对象，通过特定的操作解析path对象完成页面的重新渲染

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\虚拟节点.png)

实现步骤

- 用JS对象模拟DOM
- 把此虚拟DOM转为真实DOM并插入页面中
- 如果有事件发生修改了虚拟DOM
- 比较两个虚拟DOM树的差异，得到patch对象
- 把patch对象应用到真正的DOM树上

1. 虚拟DOM

   ```js
   let createElement = require('./element')
   let ul1 = createElement('ul',{class:'list'},[
       createElement('li',{class:'list1'},['1']),
       createElement('li',{class:'list2'},['2']),
       createElement('li',{class:'list3'},['3']),
   ])
   let ul1Element = ul1.render()
   document.body.appendChild(ul1Element)
   
   class Element{
       constructor(tagName,attrs,children){
           this.tagName = tagName
           this.attrs = attrs
           this.children = children || []
       }
       //把虚拟DOM节点渲染成真实DOM节点
       render(){
           let element = document.createElement(this.tagName)
           //给此DOM节点添加属性
           for(let attr in this.attrs){
               utils.setAttr(element,attr,this.attrs[attr])
           }
           this.children.forEach(child => {
               //如果子节点是一个元素的话，调用render()创建子节点的真实DOM 是字符串的话创建文本
               let childElement = (child instanceof Element)?child.render():document.createTextNode(child)
               element.appendChild(childElement)
           })
           return element
       }
   }
   module.exports = function(tagName,attrs,children){
   	return new Element(tagName,attrs,children)
   }
   
   
   //utils
   let utils = {
       setAttr(element,attr,value){
           switch(attr){
               case 'style':
                   element.style.cssText = value
                   break
               case 'value':
                   let tagName = element.tagName.toLowerCase()
                   if(tagName == 'input' || tagName == 'textarea'){
                       element.value = value
                   }else{
                       element.setAttribute(attr,value)
                   }
                   break
               deafult:
                   element.setAttribute(attr,value)
                   break
           }
       }
   }
   module.exports = utils
   ```

2. DOM DIFF

   react diff算法有三个优化策略

   - DOM节点的跨层级移动特别少，可以忽略不计

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\reactdiff1.png)

   - 拥有相同类的两个组件会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构

   - 对于同一层级的一组节点，可以通过唯一的key进行区分，开发人员可以使用一个key指示在不同的渲染中哪些元素可以保持稳定

   diff算法实现

   元素类型不相同，当根元素类型不同时，react将会销毁原先的树并重写构建新的树

   ```js
   //比较两个相同类型的ReactDOM元素时，React检查它的属性，保留相同的底层DOM节点
   <div className='before' title='stuff'/>
   <div className='after' title='stuff'/>
   ```

   通过比较两个元素react会仅修改底层DOM节点的className属性，当更新style属性，react也会只更新已改变的属性

   ```js
   <div style={{'{{'}}color:'red',fontWeight:'bold'}}/>
   <div style={{'{{'}}color:'green',fontWeight:'bold'}}
   ```

   当Reac对两个元素进行转化时，仅会修改color而不会修改fontWight在处理染当前DOM节点后React会递归处理子节点

3. 计算差异

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\reactdiff2.png)

   ```js
   //patch.js
   let keyIndex = 0;
   let utils = require('./utils');
   let allPatches;//这里就是完整的补丁包
   function patch(root, patches) {
       allPatches = patches;
       walk(root);
   }
   function walk(node) {
       let currentPatches = allPatches[keyIndex++];
       (node.childNodes || []).forEach(child => walk(child));
       if (currentPatches) {
           doPatch(node, currentPatches);
       }
   }
   function doPatch(node,currentPatches){
       currentPatches.foreach(pathc=>{
           switch(patch.type){
               case utils.ATTRS:
                   for(let attr in patch.attrs){
                       let value = patch.attrs[attr]
                       if(value){
                           utils.setAttr(node,attr,value)
                       }else{
                           node.removeAttribute(attr)
                       }
                   }
                   break;
               case utils.TEXT:
                   node.textContent = patch.content;
                   break;
               case utils.REPLACE:
                   let newNode = (patch.node instanceof Element) ? path.node.render() : document.createTextNode(path.node);
                   node.parentNode.replaceChild(newNode, node);
                   break;
               case utils.REMOVE:
                   node.parentNode.removeChild(node);
                   break;
           }
       })
   }
   
   module.exports = patch;
   ```

   ```js
   //utils.js
   let utils = {
       //元素变化有哪些种类
       REMOVE: 'REMOVE',//此节点被移除
       ATTRS: "ATTRS",//属性被改变
       TEXT: "TEXT",//文本内容被改变
       REPLACE: "REPLACE", //节点要被整个替换  
       setAttr(element, attr, value) {
           switch (attr) {
               case 'style':
                   element.style.cssText = value;
                   break;
               case 'value':
                   let tagName = element.tagName.toLowerCase();
                   if (tagName == 'input' || tagName == 'textarea') {
                       element.value = value;
                   } else {
                       element.setAttribute(attr, value);
                   }
                   break;
               default:
                   element.setAttribute(attr, value);
                   break;
           }
       },
       type(obj) {
           // [object String]
           return Object.prototype.toString.call(obj).replace(/\[object\s|\]/g, '');
       },
       isString(str) {
           return utils.type(str) == 'String';
       }
   }
   module.exports = utils;
   ```

   ```js
   //diff.js
   let utils = require('./utils');
   
   let keyIndex = 0;
   function diff(oldTree, newTree) {
       //记录差异的空对象。key就是老节点在原来虚拟DOM树中的序号，值就是一个差异对象数组
       let patches = {};
       keyIndex = 0;
       let index = 0;
       walk(oldTree, newTree, index, patches);
       return patches;
   }
   //遍历
   //REMOVE: 'REMOVE',//此节点被移除
   //ATTRS: "ATTRS",//属性被改变
   //TEXT: "TEXT",//文本内容被改变
   //REPLACE: "REPLACE", //节点要被整个替换  
   function walk(oldNode, newNode, index, patches) {
       let currentPatches = [];//这个数组里记录了所有的oldNode的变化
       if (!newNode) {//如果新节点没有了，则认为此节点被删除了
           currentPatches.push({ type: utils.REMOVE, index });
           //如果说老节点的新的节点都是文本节点的话
       } else if (utils.isString(oldNode) && utils.isString(newNode)) {
           //如果新的字符符值和旧的不一样
           if (oldNode != newNode) {
               ///文本改变 
               currentPatches.push({ type: utils.TEXT, content: newNode });
           }
       } else if (oldNode.tagName == newNode.tagName) {
           //比较新旧元素的属性对象
           let attrsPatch = diffAttr(oldNode.attrs, newNode.attrs);
           //如果新旧元素有差异 的属性的话
           if (Object.keys(attrsPatch).length > 0) {
               //添加到差异数组中去
               currentPatches.push({ type: utils.ATTRS, attrs: attrsPatch });
           }
           //自己比完后再比自己的儿子们
           diffChildren(oldNode.children, newNode.children, index, patches, currentPatches);
       } else {
           currentPatches.push({ type: utils.REPLACE, node: newNode });
       }
       if (currentPatches.length > 0) {
         patches[index] = currentPatches;
       }
   }
   //老的节点的儿子们 新节点的儿子们 父节点的序号 完整补丁对象 当前旧节点的补丁对象
   function diffChildren(oldChildren, newChildren, index, patches, currentPatches) {
       oldChildren.forEach((child, idx) => {
           walk(child, newChildren[idx], ++keyIndex, patches);
       });
   }
   function diffAttr(oldAttrs, newAttrs) {
       let attrsPatch = {};
       for (let attr in oldAttrs) {
           //如果说老的属性和新属性不一样。一种是值改变 ，一种是属性被删除 了
           if (oldAttrs[attr] != newAttrs[attr]) {
               attrsPatch[attr] = newAttrs[attr];
           }
       }
       for (let attr in newAttrs) {
           if (!oldAttrs.hasOwnProperty(attr)) {
               attrsPatch[attr] = newAttrs[attr];
           }
       }
       return attrsPatch;
   }
   module.exports = diff;
   ```

   ```js
   //index.js  测试用例
   let { createElement } = require('./element');
   let diff = require('./diff');
   let patch = require('./patch');
   let ul1 = createElement('ul', { class: 'list' }, [
       createElement('li', { class: 'item' }, ['1']),
       createElement('li', { class: 'item' }, ['2']),
       createElement('li', { class: 'item' }, ['3'])
   ]);
   let root = ul1.render();
   document.body.appendChild(root);
   let ul2 = createElement('ul', { class: 'list' }, [
       createElement('li', { class: 'item' }, ['1']),
       createElement('li', { class: 'item' }, ['2']),
       createElement('li', { class: 'item' }, ['3']),
       createElement('li', { class: 'item' }, ['4'])
   ]);
   let patches = diff(ul1, ul2);
   console.log(patches);
   //{2:[{type:'TEXT',content:3},4:[{type:'TEXT',content:2},6:[{type:'TEXT',content:1}]
   patch(root, patches);
   ```

4. keys作用

   ```js
   const oldKeys = ['A','B','C','D']
   const root = document.createElement('ul')
   oldKeys.roeEach(key=>{
       let li = document.creaElement('li')
       li.innerHTML = key
       root.appendChild(li)
   })
   document.body.appendChild(root)
   
   const newKeys = ['C','B','D','E']
   const patches = diff(oldKeys,newKeys)
   cosnoel.log(patches)
   patch(root,patches)
   
   function patch(node,patches){
       patches.forEach(patch=>{
           switch (patch.Types) {
    			 case 'INSERT':
       			let newLi=document.creaElement('li')
                   newLi.innerHTML = patch.key
                   let afterNode = node.childNodes[patch.index]
                   if(afterNode){
                       node.insertBefore(newLi,afterNode)
                   }else{
                       node.appendChild(newLi)
                   }
       			break;
    			 case 'REMOVE':
                   node.removeChild(node.chilfNodes[patch.index])
   				break;
     			default:
       			break;
   		}
       })
   }
   function diff(oldKeys,newKeys){
       let index = 0
       let patches = []
       while(index<oldKeys.length){
           if(!newKeys.include(oldKeys[index])){
               remove(index)
               oldKeys.splice(index,1)
           }
           index++
       }
       let oldIdx=0,newIdx=0
       while(newIdex<newKeys.length){
           let oldKey = oldKeys[oldIdx]
           let newKey = newKeys[newIdx]
           if(oldKey!=newKey){
               //key不相等
               insert(newIdx,newKey)
               newIdx++
               continue
           }
           if(!oldKey){
               //没有对应老的key直接插入
               insert(newIdx,newKey)
               newIdx++
               continue
           }
           oldIdx++
           newIdx++
       }
       while(oldIdx++<oldKeys.length){remove(newIdx)}
       function insert(index,key){
           patches.push({type:'INSERT',index,key})
       }
       function remove(index){
           patches.push({type:'REMOVE',index})
       }
       return pathces
   }
   ```

5. 常见优化

   - 头部添加

     ```js
     const oldKeys = ['A','B','C','D']
     const newKeys = ['D','A','B','C','E']
     
     [{type:'INSERT',index:0,key:'E'}]
     ```

   - 中间添加

     ```js
     const oldKeys = ['A','B','C','D']
     const newKeys = ['A','B','E','C','D']
     
     [{type:'INSERT',index:2,key:'E'}]
     ```

   - 尾部添加

     ```js
     const oldKeys = ['A','B','C','D']
     const newKeys = ['A','B','C','D','E']
     
     [{type:'INSERT',index:4,key:'E'}]
     ```

   - 头部删除

   - 中间删除

   - 尾部删除

#### react源码

1. createElement

   ```js
   function createElement (type,props,...children){
       delete props._source,props._self
       return {
           type,
           props:{
               ...props,
               children:children.map(child=>typeof child === 'object' ? child : createTextNode(child))
           }
       }
   }
   function createTextNode(text){
       return {
           type: 'TEXT',
           props:{
               children:[],
               nodeValue:text
           }
       }
   }
   ```

   

2. render

   ```js
   function render(vnode,container){
       const node = createNode(vnode)
       container.appendChild(node)
   }
   function createNode(props){
       const {type,props} = vnode
       let node
       if(typeof type ==='function'){
           node = type.isReactComponent ? updateClassComponent(vnode) : updateFunctionComponent(vnode)
       }else if(type === 'TEXT'){
           node = document.createTextNode('')
       }else if(type){
           node = document.createElement(type)
       }else{
           node = document.createDocumentFragment()
       }
       updateNode(node,props)
       reconcilerChildren(props.children,node)
       return node
   }
   function reconcilerChildren(children,node){
       for(let i=0; i<children.length;i++){
           let child = children[i]
           if(Array.isArray(child)){
               for(let j =0;i<child.length;j++){
                   render(child[j],node)
               }
           }else{
               render(child,node)
           }
       }
   }
   function updateNode(node,prevVal,nextVal){
      //更新节点上的属性
    Object.keys(prevVal).filter(k=>k!=='children').forEach(k=>{
           if(k.slice(0,2)=='on'){
               //事件
               let eventName = k.slice(2).toLowerCase()
               node.removeEventListener(eventName,nextVal[k])
           }else{
               if(!k in nextVal){
                   //上一次的属性值出现过下一次没有了
                   node[k] = ''
               }
           }
       })   Object.keys(nextVal).filter(k=>k!=='children').forEach(k=>{
           if(k.slice(0,2)=='on'){
               //事件
               let eventName = k.slice(2).toLowerCase()
               node.addEventListener(eventName,nextVal[k])
           }else{
               node[k] = nextVal[k]
           }
       })
   }
   function updateFunctionComponent(vnode){
       const {type,props} = vnode
       const vvnode = type(props)
       const node = createNode(vvnode)
       return node
   }
   function updateClassComponent(vnode){
       const {type,props} = vnode
       const cmp = new type(props)
       const vvnode = cmp.render()
       const node = createNode(vvnode)
       return node
   }
   ```

   

3. component.js

   ```js
   export default class Component{
       static isReactComponent = {}
       constrctor(props){
           this.props = props
       }
   }
   ```

   

4. fiber fiber是指组件上将要完成或者已经完成的任务，每个组

   件可以⼀个或者多个。

   Fiber 是 React 16 中新的协调引擎，主要⽬的是使Virtual DOM 可以进⾏增量式渲染。以React Fiber⼀个更新过程被分为两个阶段(Phase)：第⼀个阶段ReconciliationPhase和第⼆阶段Commit Phase。

   原理

   `window.requestIdleCallback(callback[, options])`

   ```js
   //const.js
   export const PLACEMENT = 'PLACEMENT'
   export const UPDATE = 'UPDATE'
   export const DELETIONS = 'DELETIONS'
   
   //requestIdleCallback
   requestIdleCallback(workLoop)
   //定义子任务
   let unitOfWork = null
   //下一个子任务
   let nextUnitOfWork = null
   //work in progess 工作中的fiberroot
   let wipRoot = null
   //初始值
   let currentRoot = null
   //删除fiber数组
   let deletions = null
   
   //初始化
   function render(vnode,container){
       wipRoot = {
           node:container,
           props:{children:[vnode]},
           base:currentRoot
       }
       deletions = []
       nextUnitOfWork = wipRoot
   }
   //根据vnode创建一个node
   function createNode(props){
       const {type,props} = vnode
       let node
       if(type === 'TEXT'){
           node = document.createTextNode('')
       }else if(type){
           node = document.createElement(type)
       }
       updateNode(node,{},props)
       return node
   }
   function reconcilerChildren(workInProgessFiber,children){
       //构建fiber结构 数组元素的更新删除新增
       let prevSibing = null
       let oldFiber = workInProgessFiber.base && workInProgessFiber.base.child
       for(let i=0;i<children.length;i++){
           let child = children[i]
           let newFiber = null
           //比较type key
           const sameType = child && oldFiber && child.type === oldFiber.type
           if(sameType){
               //复用update
               newFiber = {
               	type:oldFiber.type, //类型区分不同的fiber
               	props:child.props, //属性参数等
               	node:oldFiber.node, //真实dom
               	base:oldFiber, //存储fiber便于比较
               	parent:workInProgessFiber,
               	effectTag: UPDATE
           	}
           }
           if(!sameType&&child){
               newFiber = {
               	type:child.type, //类型区分不同的fiber
               	props:child.props, //属性参数等
               	node:null, //真实dom
               	base:null, //存储fiber便于比较
               	parent:workInProgessFiber,
               	effectTag: PLECEMENT
           	}
           }
           if(!sameType&&oldFiber){
               oldFiber.effectTag = DELETIONS
               deletions.push(oldFiber)
           }
           if(oldFiber){
               oldFiber = oldFiber.sibling
           }
           //parent
           
           //child
           if(i==0){
               workInProgessFiber.child = newFiber
           }else{
               prevFibing.sibling = newFiber
               //sibling
           }
           prevSibing = newFiber
       }
   }
   
   function workLoop(deadline){
       
       while(nextUnitOfWork && deadline.timeRemaining()>1){
           performUnitOfWork(nextUnitOfWork)
       }
       //没有子任务
       if(!nextUnitOfWork && wipRoot){
           //提交
           commitroot()
       }
       //提交
       requestIdleCallback(workLoop)
   }
   //提交
   function commitRoot(){
       deletions.forEach(commitWorker)
       commitWorker(wipRoot.child)
       currentRoot = wipRoot
       wipRoot = null
   }
   function commitWorker(fiber){
       if(!fiber) return
       //向上查找
       let parentNodeFiber = fiber.parent
       while(!parentNodeFiber.node){
           parentNodeFiber = parentNodeFiber.parent
       }
       const parentNode = parentNodeFiber.node
       if(fiber.effectTag == PLACEMENT && fiber.nide !==null){
           parentNode.appentChild(fiber.node)
       }else if(fiber.effectTag==UPDATE&&fiber.node!==null){
           updateNode(fiber.node,fiber.base.props,fiber.props)
       }else if(fiber.effectTag==DELETIONS&&fiber.node!==null){
           commitDeletions(fiber,parentNode)
       }
       commitWorker(fiber.child)
       commitWorker(fiber.sibling)
   }
   function commitDeletions(fiber){
       if(fiber.node){
           parentNode.removeChild(fiber.node)
       }else{
           commitDeletions(fiber.child,parentNode)
       }
   }
   
   function performUnitOfWork(fiber){
       //执行子任务
    const {type} = fiber
       if(typeof type ==='function'){
           type.isReactComponent?updateClassComponent(fiber):updateFunctionComponent(fiber)
       }else if(type){
           updateHostComponent(fiber)
       }else{
           updateFragmentComponent(fiber)
       }
       //返回下一个子任务 优先子元素
       if(fiber.child){
           return fiber.child
       }
       let nextFiber = fiber
       while(nextFilber){
           if(nextFiber.sibling){
               return nextFiber.sibling
           }
           nextFiber = nextFiber.parent
       }
       
   }
   function updateHostComponent(fiber){
       if(!fiber.node){
           fiber.node = createNode(fiber)
       }
       const {children} = fiber.props
       reconcilerChildren(fiber,children)
   }
   function updateFunctionComponent(fiber){
       const {type,props} = fiber
       const children = [type(props)]
       reconcilerChildren(fiber,children)
   }
   function updateClassComponent(fiber){
       const {type,props} = fiber
       const cmp = new type(props)
       const children = [cmp.render()]
       reconcilerChildren(fiber,children)
   }
   function updateFragmentComponent(fiber){
       const {children} = fiber.props
       reconcilerChildren(fiber,children)
   }
   ```
   
   5. hook原理
   
   ```js
   //useState
   //当前正在工作的fiber
   let wipFiber = null
   let hookIndex = null
   export function useState(init){
       //init为初始值
       const oldHook = wipFiber.base && wipFiber.base.hooks[hookIndex]
       const hook = {
           state: oldHook?oldHook.state:init,
           queue:[]
       }
       const actions = oldHook?oldHook.queue:[]
       actions.forEach(action=>{hook.state = action})
       const setState = action =>{
           hook.queue.push(action)
           wipRoot = {
               node:currentRoot.node,
               props:currentRoot.props,
               base:currentRoot
           }
           nextUnitOfWork = wipRoot
           deletions = []
       }
       wipFiber.hooks.push(hook)
       hookIndex++
       return {hook.state,setState}
   }
   function updateFunctionComponent(fiber){
       wipFiber = fiber
       wipFiber.hooks = []
       hookIndex = 0
       const {type,props} = fiber
       const children = [type(props)]
       reconcilerChildren(fiber,children)
   }
   ```
   
   



## redux

redux设计思想1)web应用是一个是、状态机，视图和状态是一一对应的 2)所有的状态保存在一个对象里

redux安装 `npm i redux --save`

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\redux.png)

所有state都以一个对象树的形式存放在一个单一的store中，改变state需要触发action(描述发生了什么)，为了描述action如何改变state需要编写reducer

#### action

action把数据从应用传到store

```js
const action = {
    type:'ADD_TODO', //type字段表示将要执行的动作
    text:'test',
    index:5   //index是用户完成任务的动作序列号
}
```

应用规模大时使用单独的模块存放action

```js
import {ADD_TODO,REMOVE_TODO} from './actionTypes'
```

action creater是生成action的方法

```js
function addTodo(text){
    return {
        type:ADD_TODO,
        text
    }
}
const action = addTodo('test')
```

#### reducer

reducer指定改变store的具体操作，reducer就是一个纯函数，接受旧的state和acrion

```js
(previousState,action) => newState
//reducer禁止  修改传入参数 执行有副作用的操作（API操作 路由跳转）调用非纯函数
function todoApp(state=innitialState,action){
    switch(action.type){
        case SET_VISIBILITY_FILTER:
            //不直接修改state
            return Object.assign({},state,{visibilityFilter:cation.filter})
        default:
            //默认情况返回旧state
            return state
    }
}
```

#### store

store作用

- 维持应用的state
- 提供getState()获取state
- 提供dispatch(action)更新state
- 提供subscribe(listener)注册监听器
- 提供subscribe(lisrener)返回函数注销监听器

```js
import {createStore} from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
```

#### react-redux

1. 安装`npm i react-redux --save`

2. 使用

   reacr-redux提供两个api

   - provider为后代组件提供store

     ```js
     import React from 'react'
     import ReactDOM from 'react-dom'
     import App from './App'
     import store from './store'
     import {Provider} from 'react-redux'
     
     React.render({
         <Provider store={store}>
         	<App/>
         </Provider>,
         document.getElementById('root')
     })
     ```

   - connect为组件提供数据和变更方法

     ```js
     import React,{Component} from 'react'
     import {connect} from 'react-redux'
     
     export default connect(
         //map state to props
          state => ({num:state}),
         //map dispatch to props
         //object
         {
             add:()=>({type:'ADD'})
         }
         //function
         dispatch =>{
         	const res = {add:()=>({type:'ADD'})}
     		res = bindActionCreators(res,dispatch)
         	return {
         		dispatch,
                 ...res
         	}
         }
     )(class ReactReduxPage extends Component{
         render(
         	const {num,dispatch} = this.props
         	return (
             	<div>
       				<p>{num}</p>
     				/*<button onClick={()=>dispatch({type:'ADD'})}>add</button>*/
     				<button onClick={add}></button>
         		</div>
             )
         )
     })
     ```

redux原理

```js
export function createStore(reducer){
    let currentState = undefined
    let currentListeners = []
    function getState(){
        return currentState
    }
    function dispatch(action){
        currentState = reducer(currentState,action)
        currentListeners.map(listener => listener())
    }
    function subscribe(listener){
        currrentListeners.push(listener)
    }
    //初始值 不能和项目中值相同 随机生成字符串
    dispatch({type:'@init/REDUX-KKB'})
    return {
        getState,
        dispatch,
        subscribe
    }
}
```

#### 中间件

redux只是状态管理器默认只支持同步执行，需要实现异步任务需要使用中间件(redux-thunk/redux-logger/redux-saga)

中间件就是一个函数，对store.dispatch方法进行改造，在发出action和执行reducer之间添加了其他功能

1. redux-thunk

`npm i redux-thunk redux-logger --save`

使用

```js
import {createStore,applyMiddleware} from 'redux'
//监控日志
import logger from 'redux-logger'
//实现异步
import thunk from 'redux-thunk'
import counterReducer from './counterReducer'

const store = createReducer(counterREducer,applyMiddleware(logger,thunk))
asyAdd = ()=>{
    store.dispatch(dispatch=>{
        setTimeout(()=>{dispatch({type:'ADD'})},1000)
    })
}
```

原理

```js
export function createStore(reducer,enhancer){
    if(enhancer){
        return enhancer(createStore)(reducer)
    }
    let currentState = undefined
    let currentListeners = []
    function getState(){
        return currentState
    }
    function dispatch(action){
        currentState = reducer(currentState,action)
        currentListeners.map(listener => listener())
    }
    function subscribe(listener){
        currrentListeners.push(listener)
    }
    //初始值 不能和项目中值相同 随机生成字符串
    dispatch({type:'@init/REDUX-KKB'})
    return {
        getState,
        dispatch,
        subscribe
    }
}
export function applyMiddleware(...middlerwares){
    return createStore=>(...args)=>{
        const store = cerateStore(...args)
        let dispatch = store.dispatch
        const middleApi = {
            getState:store.getState,
            dispatch
        }
       const middlewareChain =  middlewares.map(middleware=>middleware(middleApi))
       dispatch = compose(...middlewareChain)(dispatch)
        return{
            ...store,
            dispatch
        }
    }
}
function compose(...funcs){
    if(func.length === 0){
        return arg => args
    }
    if(func.lentgh ===1){
        return funcs[0]
    }
    return funcs.reduce((a,b)=>(...args)=>a(b(...args)))
}
function logger(){
    return dispatch =>action=>{
        console.log(action.type = '执行')
        return dispatch(action)
    }
}
function thunk({getState,dispatch}){
    return dispatch => action=>{
        if(typeof action == 'function'){
            return action(dispatch,getState)
        }else{
            return dispatch(action)
        }
    }
}
```

2. redux-saga

redux-saga是一个用于管理应用程序sideEffect(异步获取数据、访问浏览器缓存等)的library，sagas都用Generator实现

`npm i --save redux-saga`

- put 作用和Redux的dispatch相同

  `yield put({ type: "loginSuccess")`

- call 阻塞调用子saga或返回paromise函数

- fork 非阻塞调用子saga

- take 等待 redux dispatch 匹配某个 pattern 的 action

- takeEvery takeEvery 可以让多个 saga 任务并⾏被 fork 执⾏

call： 调⽤异步操作

put：状态更新

takeEvery：做saga监听

## umi&dva

umi、dva、roadhog关系

- roadhog是基于webpack的封装工具，为简化webpack配置
- umi是roadhog+路由
- dva是纯粹的数据流 基于redux和redux-saga的数据流方案

dva数据结构

- Page 负责与⽤户直接打交道：渲染⻚⾯、接受⽤户的操作输⼊，侧重于展示型交互性逻辑。
- Model 负责处理业务逻辑，为 Page 做数据、状态的读写、变换、暂存等。
- Service 负责与 HTTP 接⼝对接，进⾏纯粹的数据读写

##ant-design

#### 配置

[create react app](https://create-react-app.bootcss.com/)

通过脚手架配置 `npx create-react-app myapp`

脚手架优点：

- 零配置
- 集成了开发服务器
- 配置好浏览器热加载
- 集成了对react jsx es6 flow的支持
- 在js中可以直接import css和图片
- 自动处理css兼容问题 无需添加-webkit前缀
- 集成好了编译命令

启动项目`npm start`

自定义脚手架配置 `npm run eject` 操作不可逆

安装插件 `npm i less less-loader antd babel-plugin-import axios  `

修改webpack.config.js 

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\antd.png)

定制主题

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\antd2.png)

```js
//router.js
import React,{Component} from 'react'
import {Link,Switch,Route,Router,Redirect} from 'react-router-dom'
import history from './history'
import App from './App'
import Login from './pages/login'
import Home from './pages/home'
import Admin from './pages/admin'
import Order from './pages/order'

export default class ERoute extends Component{
    render(){
        return {
            <Router history={history}>
            	<Switch>
            		<Route path='/'>
                        <App>
                        	<Switch>
                        		<Route path='/' component={Login}></Route>
        						<Route path='/home'>
                                    <Home>
                                    	<Switch>
                                    		<Route exaxt path='/home' component={Admin}></Route>
        									<Route path='/home/order' component={Order}></Route>
        									<Redirect to='/home'/>
                                    	</Switch>
                                    </Home>
                                </Route>
        						<Redirect to='/'/>
                        	</Switch>
                        </App>
                    </Route>
            	</Switch>
            </Router>
        }
    }
}
```

#### 登录表单

```js
///login
import React,{Component} from 'react'
import BaseService from './component/baseService'
import history from '../../history'

export default class Login extends Component{
    loginSubmit = (value)=>{
        BaseService.ajax({
            url:urls.login,
            data:value,
            isMock:true
        }).then((response)=>{
            if(response.data.code ==0){
                history.push('./home')
            }else{
                //弹出错误
            }
        })
    }
    render(){
        return (
        	<div className='login-page'>
            	<div className='login-content-wrap'>
            		<div className='login-content'>
            			<div classname='word'>管理系统</div>
            			<div classname='login-box'>
            				<div classname='title'>欢迎</div>
            				<LoginForm loginSubmit={this.loginSubmit}/>
            			</div>
            		</div>
            	</div>
            </div>
        )
    }
}

import {Form,Input,Button} from 'antd'
const FormItem = Form.Item
class LoginForm extends Compoent{
    checkUserName= ()=>{
        ler reg = /1\d{10}/
        if(!value){
            callback('请输入用户名')
        }else if(!reg.test(value)){
            callback('用户名不合法')
        }else{
            callback()
        }
    }
    submitLogin = ()=>{
        let data = this.props.form.getFieldsValue
        this.props.submitLogin(data)
    }
    render(){
        const {getFieldDecorator} = this.props.form
        return (
        	<Form>
            	<FormItem>
            		{
                        getFieldDecorator('username',{rules:[{validator:this.checkUserName}]})(<Input placeholder='用户名'>)
                    }
            	</FormItem>
            	<FormItem>
                    {
                        getFieldDecorator('password',{rules:[{required:true,meaasge:'请输入密码'}]})(<Input placeholder='密码' type='password'>)
                    }
            	</FormItem>
            	<FormItem>
            		<Button type='primary' className='login-form-button' onClick={this.submitLogin}>登录</Button>
            	</FormItem>
            </From>
        )
    }
}
LoginForm = From.create({})(LoginForm)
```

#### 封装请求方法

```js
//baseService.js
import React from 'react'
import axios from 'axios'
import urls from './urls'
export default class BaseServrse{
    static ajax(){
        let Mokc = ''
        if(option.isMock){
            option.baseURL = MockApi
        }else{
            option.baseURL = urls.baseURL
        }
        return new Promise((resolve,reject)=>{
            axios({
                url:options.url,
                method:options.type || 'post'
                data:JSON.stringfy(option.data || ''),
                timeout:8000,
                baseURL:option.baseURL    
            }).then((response)=>{
            	if(response.status==200){
                    let result = response.data
                    if(result.error){
                        alert(result,error.message)
                    }
                    resolve(result)
                }else{
                    reject(response.data)
                }
       		}).catch((error)=>{
            	console.error(`request URL ${error}`)
        	})
        })
    }
}

//urls.js
let urls = {}
let protocol = window.location.protocol
let host = window.location.host

urls.baseURL = protocol + '//' + host
urls.login = '/login'
url.order_list = '/order/list'
export default urls
```

#### 分页

```js
import React from 'react'
import Header from '../components/header'
import {Row,Col} from 'antd'
import NavLeft from '../components/navleft'
import menuList from '../components/menuConfig'

export default Home extends Component{
    state={}
    componentWillMount(){
        this.setState({menuList})
    }
    render(){
        return (
        	<div>
            	<div className='welcome-page'>
            		<Header username={'用户名'}/>
            		<Row>
            			<col span={3} className='nav-left'><NavLeft menuList={this.state.menuList}/></col>
            			<col span={21} className='right-container'>{this.props.children}</col>
            		</Row>
            	</div>
            </div>
        )
    }
}

//header
export default class Header extends Component{
    logout=()=>{
        history.push('/')
    }
    render(){
        return (
        	<div className='header'>
            	<Row className='header'>
            		<Col span='18'><Link ='/home'>
            管理系统</Link></Col>
            		<Col soan='6'><Icon type='smile-0' />{this.props.username}<span className='anction' onClick={this.logout}>退出</span></Col>
            	</Row>
            </div>
        )
    }
}
//navleft
const SubMenu = Menu.SubMenu
export default class NavLeft extends Component{
    componentWillMount(){
        let menuList = this.props.menuList
        let munus = this.listMenu(menulist)
        var key = window.location.hash
        this.setState({menu,selected:key})
    }
    listMenu=(data)=>{
        return data.map((item,key)=>{
            if(item.children){
                return (
                	<SubMenu key={key+item.key} title={item.title}>{this.listMenu(item.children,key+item.key)}</SubMenu>
                )
            }
    		return (<Menu.Item key={key+item.key} name={item.title}><link to={key+item.key}>{item.title}</link></Menu.Item>)
        })
    }
    render(){
        return (
        	<div><Menu className='nav-left' mode='inline' selectKeys={this.state.keys}>{this.state.menu}</Menu></div>
        )
    }
}
```



#### 菜单

```js
//menu.config.js
export ddefault{
    {
        title:'运营管理',
        key:'/home',
        children:[{
            title:'用户管理',
            key:'/order',
            btnList:[]
        },{
            title:'认证管理',
            key:'/use/bike',
            btnList:[]
        },{
            title:'身份审核',
            key:'/ha',
            btnList:[]
        },{
            title:'系统配置',
            key:'/sys_config',
            btnList:[]
        }]    
    },{
        title:'营销管理',
        key:'/platform/market',
        children:[{
            title:'活动管理',
            key:'/acmanager',
            children:[
                {title:'活动管理',key:'/activity',btnList:[]},
                {title:'邀请新用户',key:'/invitation',btnList:[]}
            ]
        },{
            title:'推荐管理',
            key:'/recommoned',
            children:[
                {title:'app首页推荐',key:'hp_recomnend',btnList:[]},
                {title:'活动中心推荐',key:'ac_commoned',btnList:[]}
            ]
        },{
            title:'通知管理',
            key:''
        }]    
    },{
        title:'财务管理',
        key:'',
        btnList:[]    
    },{
        title:'权限管理',
        key:'',
        btnList:[]    
    }
}
```

## react-native

混合开发优势

- HTML/CSS/JS开发成本低
- 天然跨平台
- 无审核热更新
- 可扩展

混合开发劣势 性能不如原生开发

#### 环境搭建

- IOS环境
  - 必须安装Node(运行环境)、Watchman（文件监控服务）、Xcode (ios原生编译器)和 CocoaPods(ios原生库包管理)
- android环境

#### 布局和样式

react native使用flex布局

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\flexbox.jpg)

react native中没有单位，代表的是设备独立像素

```react
//android上100dp ios上100pt
<View style={{width:100,height:100}}>
	<Text style={{fontSize:16,margin:20}}>尺寸</Text>
</View>
```

react native 的flexBox和webcss的flexbox工作方式一样

- flexDirection主轴方向

  rn默认为`flexDirection:'column'` web默认`flexDirection:'row'`

- alignItems在交叉轴上的对齐方式

  rn默认`alignItems:'stretch'` web默认`align-items:'flex-start'`

- flex

  rn只接受一个属性 web可以接受多个属性`flex:2 2 10%;`

**flex在reactnative的属性**

- 容器属性
  - flexDirection: row|column|row-reverse|column-reverse
  - flexWrap:wrap|noWrap
  - justifyContent:flex-start|flex-end|center|space-between|space-around
  - alignItems:flex-start|flex-enf|center|stretch
- 项目属性
  - alighnSelf
  - stretch
  - center
  - flex-start
- flex-end
- flex 定义元素的可伸缩能力 默认为0

reactnative样式

```react
//引入StyleSheet API
<View style={styles.container}></View>
const styles = StyleSheet.create({
    container:{...}
})
//组件内写法
<View style={{backgroundColor:'red'}}></View>    
```

#### 组件

在react native种使用原生组件需要引入react

```react
import React,{Component} from 'react'
import {Button,Platform,StyleSheet,Text,View} from 'react-native'
```

-  原生组件

- 核心组件

  | 组件名         | Android View   | iOS View         | 网页模拟              | 说明                                                         |
  | -------------- | -------------- | ---------------- | --------------------- | ------------------------------------------------------------ |
  | `<View>`       | `<ViewGroup>`  | `<UIView>`       | 非滚动的`<div>`       | 一个支持用flexbox渲染的容器，有样式，触摸处理和辅助功能的控件 |
  | `<Text>`       | `<TextView>`   | `<UITextView>`   | `<p>`                 | 展示带样式的的文字有触摸事件回调                             |
  | `<Image>`      | `<ImageView>`  | `<UIImageView>`  | `<img>`               | 展示不同类型的图片                                           |
  | `<ScrollView>` | `<ScrollView>` | `<UIScrollView>` | `<div>`               | 一个可以滚动的容器 可以包含多个组件和视图                    |
  | `<TextInput>`  | `<EditText>`   | `<UITextField>`  | `<input type="text">` | 允许用户输入文字                                             |

  - Button按钮组件

    ```react
    <Button 
        onPress = {onPressHandler} //点击事件
        title = 'test' //按钮文本
        color = 'red' //文本颜色
        disabled = {false} //按钮是否可用
        accessibilityLabel = 'test' //给残障人士显示的文本
        />
    ```

  - ActivityIndicator 圆形loading

    ```react
    <View style={[styles.container,style.horizontal]}>
    	<ActivityIndicator
            size='large' //指示器的大小 默认为small[enum('samll','large'),number] 只能在android设定具体数值
            animating={true} //是否要显示指示器动画
            hidesWhenStopped={false} //在animating为false时是否隐藏指示器 animating和hidesWhenStopped都为false时显示一个静止的指示器
            color='red' //滚轮前景颜色
            />
    </View>    
    ```

  - Image:用于显示多种不同类型图片的react组件，包括网络图片、静态资源、临时的本地图片、本地磁盘的图片等

    ```react
    <Image source={require('../img/favicon.png')}/>
    //网络和base64图片需要手动指定尺寸
    <Image style={{width:50,height:50}} source={url:'url'}/>
    ```

    ```react
    //android上使用gif和webp图片
    dependencies {
     // 如果你需要⽀持Android4.0(API level 14)之前的版本
     compile 'com.facebook.fresco:animated-base-support:1.10.0'
     // 如果你需要⽀持GIF动图
     compile 'com.facebook.fresco:animated-gif:1.10.0'
     // 如果你需要⽀持WebP格式，包括WebP动图
     compile 'com.facebook.fresco:animated-webp:1.10.0'
     compile 'com.facebook.fresco:webpsupport:1.10.0'
     // 如果只需要⽀持WebP格式⽽不需要动图
     compile 'com.facebook.fresco:webpsupport:1.10.0'
    }
    ```

  - SafeAreaView 在一个安全的可视区内渲染内容 仅支持ios设备

  - Text 显示文本

    ```react
    <Text
        ellipsizeMode={'tail'} //这个属性通常和下⾯的 numberOfLines 属性配合使⽤,⽂本超出numberOfLines设定的⾏数时，截取⽅式：head- 从⽂本内容头部截取显示省略号。例如："...efg"，middle - 在⽂本内容中间截取显示省略号。例如： "ab...yz"，tail - 从⽂本内容尾部截取显示省略号。例如： "abcd..."，clip - 不显示省略号，直接从尾部截断。
        numberOfLines = {1} //配合ellipsizeMode设置行数
        onPress={} //点击事件
        ></Text>
    ```

  - TextInput 文本输入框

    ```react
    <TextInput 
        style={{width:100,height:40,borderWidth:3,borderColor:'blue'}}
        keyboardType={'default'} //决定弹出建平类型 numeric纯数字键盘 default number-pad decimal-pad email-address phone-pad
        maxLength={20} //文本框最多字符
        editable={true} //文本能否编辑
        defaultValue={'xxx'} //文本框的初始值
        careHidden={true} //光标是否隐藏
        autoCapitalize={'none'} //是否自动首字符大写
        onChangeText={text=>{
            //文本内容变化时回调 更改后的文字作为参数传递
            this.setState({text:text})
        }}
        />
    ```

  - View 类似div容器组件

  - WebView 创建一个原生的webView 用于访问网页

    ```react
    class MyWeb extends Component {
     render() {
     	return (
     		<WebView source={{url: 'https://github.com/facebook/react-native'}} style={{marginTop: 20}}/>
    	)
     }
    }
    //新版中使用react-native-webView代替原生的webview
    //yarn add react-native-webview
    //react-native link react-native-webview
    import {WebView} from 'react-native-webview'
    ```

  - ListView 性能差 数据多时对内存占用多 第一次打开或切换tab时会卡顿白屏

  - VirtualizedList ： FlatList 和 SectionList 的底层实现，VirtualizedList通过维护⼀个有限的渲染窗⼝(其中包含可⻅的元素)，并将渲染窗⼝之外的元素全部⽤合适的定⻓空⽩空间代替的⽅式，极⼤的改善了内存使⽤，提⾼了⼤量数据情况下的渲染性能。这个渲染窗⼝能响应滚动⾏为，元素离可视区越远优先级越低，越近优先级越⾼，当⽤户滑动速度过快时，会出现短暂空⽩的情况。

    ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\virtualizedList.png)

  - FlatList 为了优化内存占⽤同时保持滑动的流畅，列表内容会在屏幕外异步绘制。这意味着如果⽤户滑动的速度超过渲染的速度，则会先看到空⽩的内容。不⽀持分组列表。

    ```react
    //少了dataSource
    <FlatList data={[{key: 'a'}, {key: 'b'}]} renderItem={({item}) => <Text>{item.key}</Text>}/>
    ```

  - RefreshControl 下拉刷新功能用在ScrollView或FlatList内部

  - SwipeableFlatList 侧滑列表组件

  - SectionList 分组列表组件

#### API

1. Dimensions获取设备屏幕宽高

   ```react
   let {height,width} = Dimensions.get('window')
   ```

2. Platform 平台api判断

   ```react
   import {Platform,StyleSheet} from 'react-native'
   const styles = StyleSheet.create({height:Platform.OS === 'ios'?200:100})
   //以Platform.OS为 key，从传⼊的对象中返回对应平台的值：
   const Component = Platform.select({
       ios:()=>require('ComponentIOS'),
       android:()=>require('ComponentAndriod')
   })()
   //检测android版本
   if(Platform.Version===25){
       console.log('android')
   }
   //检测ios版本
   const majorVersionIOS = parseInt(Platform.Version,10)
   if(majorVersionIOS<=9){
       console.log('IOS')
   }
   //不同平台代码逻辑复杂时，可以使用平台扩展名
   BigButton.ios.js
   BigButton.android.js
   const BigButton = require('./Bigbutton')
   ```

   

3. 



## vue

#### 基础

##### MVVM

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\vue-mvvm.png)

mvvm框架三要素：数据响应式 模板引擎及其渲染

- 数据响应式：监听数据变化并在视图中更新
  - Object.defineProperty()   vue2.0原理
  - Proxy vue3.0原理
- 模板引擎：提供描述视图的模板语法
  - 插值 {{}}
  - 指令 v-bind v-on v-model v-for v-if
- 渲染：如何将模板转为html
  - 模板 -> vdom -> dom

数据响应式原理

```js
//简单原理
const obj = {}
function defineReactive(obj,key,val){
    Object.defineProperty(obj,key,{
        get(){
            console.log(key)
            return val
        },
        set(newVal){
            if(newVal !== val){
                val = newVal
            }
        }
    })
}
```

增加视图更新

```js
const obj = {}
function defineReactive(obj,key,val){
    observe(val)
    Object.defineProperty(obj,key,{
        get(){
            console.log(key)
            return val
        },
        set(newVal){
            if(newVal !== val){
                val = newVal
                observe()
            }
        }
    })
}
function observe(){
    if(typeof obj !== 'object' || obj == null){
        return
    }
    Object.keys(obj).forEach(key=>{
        defineReactive(obj,key,obj[key])
    })
}
```

**vue数据响应式的原理**

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\vue源码.png)

1. new Vue() 首先执行初始化，对data执行响应化处理，这个过程发生在Observer中 
2. 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中 
3. 同时定义一个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数

4. 由于data的某个key在一个视图中可能出现多次，所以每个key都需要一个管家Dep来管理多个Watcher

5. 将来data中数据一旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数



##### vue实例

```js
//创建vue实例
let vm = new Vue({
    //可传入多个参数options
})
```

vue实例可传入的options包括

- data 

  vue实例的数据对象，vue会递归将data的property转换为getter/setter，让data的property能响应数据变化

  ```js
  let vm = new Vue({
      data:{a:1} //data必须为纯对象 创建实例前就声明所有根级响应式property _或$开头property不会被代理
  })
  //访问实例上的data
  console.log(vm.$data.a)
  console.log(vm.a)
  
  let Component = Vue.extend({
      //extend中data必须为函数 组件用来创建多个实例时data返回纯对象时，所有实例将共享引用一个数据对象
      data:function(){
          return {a:1}
      }
  })
  ```

- props

  props用于接收来自父组件的数据

  ```js
  //props为数组
  Vue.component('props-demo',{
      props:['父组件','数据']
  })
  
  //props为对象
  Vue.component('props-demo',{
      props:{
          //类型检测 检测prop是否为给定类型
          type:String|Number|Boolean|Array|Object|Date|Function|Symbol,
          //指定prop默认值
          default:0,
          //定义prop是否必填
          required:Boolean,
          //自定义验证函数 prop会作为唯一参数传入
          validator:Function
      }
  })
  ```

- propsData

  propsData只用于new创建的实例中，在创建实例时传递props方便测试。

  ```js
  let Component = Vue.extend({
      props:['msg'],
      template:'<div>{{msg}}</div>'
  })
  let vm = new Component({
      propsData:{
          msg:'test'
      }
  })
  ```

- computed

  compyuted为计算属性，会被混入Vue实例，所有getter和setter的this上下文自动绑定为Vue实例。（计算属性为监听函数时this不指向组件的实例）计算属性的结果会被缓存，依赖的响应式property变化才重新计算

  ```js
  let vm = new Vue({
      data:{a:1},
      computed:{
          //仅读取
          aDouble:function(){
              return this.a*2
          },
          //读取和设置
          aPlus:{
              get:function(){
                  returm this.a+1
              },
              set:function(v){
                  this.s = v-1
              }
          }
      }
  })
  ```

- methods

  methods会被混入Vue实例中，可以通过vm实例访问或指令表达式中使用，方法中this为Vue实例，methods不能使用箭头函数定义。

  ```js
  let vm = new Vue({
      data:{a:1},
      methods:{
          plus:function(){
              this.a++
          }
      }
  })
  vm.plus()
  ```

- watch

  watch为对象，键是要监控的表达式，值是对应回调函数或方法名或包含选项的对象。Vue实例会在实例化时调用$watch()，遍历watch对象的每一个property

  ```js
  let vm = new Vue({
      data:{a:1},
      watch:{
          a:function(val,oldVal){
              console.log(val,oldVal)
          },
          //方法名
          b: 'someMethod',
          //回调函数
          c:{
              handler:function(val,oldVal){},
              deep:true
          }
      }
  })
  ```

- el

  el提供一个在页面上已经存在的DOM元素作为Vue实例挂载的目标，实例挂载后可以用vm.$el访问

  ```js
  let vm = new Vue({
      el:'#app',
      data:{a:1}
  })
  ```

- template 设定模板替换挂载的元素

- render

- renderError

vue实例暴露出以$开头的实例属性方法

| 方法名                                   | 类型                                                         | 作用                                                         |
| ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| vm.$data                                 | Object                                                       | 代理对data对象property的访问                                 |
| vm.$props                                | Obejct                                                       | 代理对props对象property的访问                                |
| vm.$el                                   | Element                                                      | vue实例使用的根DOM元素                                       |
| vm.$options                              | Obejct                                                       | 用于vue实例的初始化选项                      new Vue({   customOption: 'foo',   created: function () {     console.log(this.$options.customOption)} }) |
| vm.$parent                               | vue instance                                                 | 父实例                                                       |
| vm.$root                                 | vue instance                                                 | 当前组件数的根vue实例，如果当前实例没有父实例时vue.$root为自己 |
| vm.$children                             | Array\<vue instance\>                                        | 当前实例的直接子组件 $children不保证顺序也不是响应式         |
| vm.$slots                                | {[name:string]:>Array\<vNode\>}                              | 用来访问被插槽分发的内容 每个具名插槽有其相应的property  vm.$slot.foo找到v-slot:foo |
| vm.$scopedSlots                          | { [name: string]: props => Array\<VNode\> \| undefined }     | 访问作用域插槽                                               |
| vm.$refs                                 | Object                                                       | 一个包含注册过ref属性的所有DOM元素和组件实例放对象           |
| vm.$isServer                             | boolean                                                      | 当前vue实例是否运行与服务器                                  |
| vm.$attrs                                | {[key:string]:string}                                        | 父作用域不作为prop被识别的属性绑定                           |
| vm.$listeners                            | { [key: string]: Function \| Array\<Function\> }             | 父作用域的v-on时间监听器                                     |
| vm.$watch(expOrFn,callback,[options])    | options包括deep:true 深层监控immediate:true立即用表达式当前值触发回调 | 监控vue实例上的watch函数定义的porperty                       |
| vm.$set(target,propertyName/index,value) |                                                              | Vue.set的别名                                                |
| vm.$delete(target,propertyName/index)    |                                                              | Vue.delete的别名                                             |
| vm.$on(event,callback)                   |                                                              | 监听当前实例上自定义的时间                                   |
| vm.$once(event,callback)                 |                                                              | 监听一个自定义事件但值触发一次                               |
| vm.$off([event,callback])                |                                                              | 移除自定义事件监听器                                         |
| vm.$emit(eventName,[...args])            |                                                              | 触发当前实例上的事件                                         |
| vm.$mount([elementOrSelector])           |                                                              | 手动挂载实例                                                 |
| vm.$forceUpdate                          |                                                              | 手动重新渲染实例                                             |
| vm.$nextTick([callback])                 |                                                              | 将回调演出到下次dom更新循环之后执行                          |
| vm.$destory                              |                                                              | 销毁实例                                                     |

- `Vue.set(target,propertyName/index,value)`  等同于vm.$set()

  向响应式对象中添加一个属性并确保这个新属性也是响应式且触发视图更新

- `Vue.delete(target,propertyName/index) `等同于vm.$selete()

  删除对象的属性，如果对象是响应式的确保删除能触发更新视图

##### 生命周期

```js
//生命周期应用
beforeCreate(){} //组件实例还未创建，通常用于插件开发中执行以下初始化任务
created(){} //组件初始化完毕数据可以使用，常用于异步数据获取
beforeMounted(){} //未执行渲染更新 dom未创建
mounted(){} //初始化结束dom已经创建用于获取访问数据和dom元素
beforeUpdate(){} //更新前 可用于获取更新前各种状态
updated(){} //更新后所有状态最新
beforeDestory(){} //销毁前可以用于定时器或订阅的取消
destory(){} //组件已经销毁
```

##### 模板语法

插值

- 文本

  ```js
  //数据双向绑定
  <span>{{msg}}</span>
  <span v-once>一次性差值{{msg}}</span>
  ```

- 原生html

  ```js
  <p>通过v-hmtl输出html代码<span v-html='rawHtml'></span></p>
  //span内容会被替换为rawHtml    
  ```

- attribute

  ```js
  //通过v-bind:设置attr
  <div v-bind:id='test'></div>
  ```

- js表达式

  ```js
  //必须为单个表达式 其他语句不生效
  {{ok ? 'yes' : 'no'}}
  <div v-bind:id='list-'+id></div>
  ```

指令

指令是指v-前缀的特殊attribute，表达式值改变时将结果响应式作用于dom

- v-bind、v-on等指令接受一个参数在bind后用冒号表示
- 可以使用动态参数`<a v-bind:[attributeName]='url'></a>` attributeName会被作为一个js表达式动态求助，得到的值作为参数使用，动态参数结果必须为一个字符串，其它非字符串类型触发警告（null值为移除绑定），动态参数表达式不能包含空格引号等特殊字符。
- v-bind缩写 `:href='url'` 动态参数缩写`:[key]='url'`
- v-on缩写`@click='test'`动态参数缩写`@[event]='test'`

修饰符

修饰符用于指出一个值得应该用特殊方式绑定 `<form v-on:submit.prevent='onSubmit'></form>`

##### 条件渲染与列表渲染

条件渲染

- v-if  在指令表达式返回值为truthy时渲染

  ```js
  //通过template切换多个元素 key用来区分元素 key值不同元素不会复用
  <template v-if="loginType === 'username'">
    <label>Username</label>
    <input placeholder="username" key="username-input">
  </template>
  <template v-else>
    <label>Email</label>
    <input placeholder="email" key="email-input">
  </template>
  ```

  `v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别

- v-show 切换元素的css属性display

> v-show与v-if的区别
>
> 1. vi-if在切换过程中会确保条件快内的事件监听器和子组件适当被销毁重建 v-show只是简单的基于css进行切换
> 2. v-if初始渲染时条件为假就不渲染 v-show不管初始值是什么都会被渲染只是切换css

列表渲染

```js
//通过v-for遍历数组创建列表
<ul id="example-1">
    //也可以使用 item of items遍历
  <li v-for="(item,index) in items" :key="item.message">
    {{ item.message }}-{{index}}
  </li>
</ul>
//通过v-for遍历对象 按Object.key()的结果遍历不能保证结果在不同js引擎下一致
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

##### computed&watch

- computed computed基于响应式依赖进行缓存，只有依赖改变时才重新计算
- watch 用来监控响应vue实例上的数据变动，需要在数据变化时执行异步或开销较大的操作时使用watch

##### css&style绑定

- :class=''绑定class

  ```js
  <div :class="[isActive ? activeClass : '', errorClass]"></div>
  <div :class="[{ active: isActive }, errorClass]"></div>
  ```

- :style=''绑定style

  ```js
  //只会渲染数组中最后一个被浏览器支持的值。如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex
  <div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
  ```

##### 过渡与动画

vue在插入更新移除DOM时，提供多种不同的应用过渡效果

- 在css过渡和动画中自动应用class
- 可以配合使用第三方css动画库Animate.css
- 在过渡钩子函数中使用JS直接操作DOM

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\vue-trantion.png)

过渡的使用

```js
<style> 
    /* 定义过度动画 */ 
    .fade-enter-active, .fade-leave-active { transition: opacity .5s; }
	.fade-enter, .fade-leave-to { opacity: 0; } </style>
<script>
    Vue.component('message', { 
        // 使用transition组件应用过渡动画
        template: ` <transition name="fade"> ... </transition> `, })
</script>        
```

过渡的类名

1. v-enter ：定义**进入过渡的开始状态**。在元素被插入之前生效，在元素被插入之后的下一帧移除。

2. v-enter-active ：定义**进入过渡生效时的状态**。在元素被插入之前生效，在过渡/动画完成之后移除。

3. v-enter-to : 定义**进入过渡的结束状态**。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。

4. v-leave : 定义**离开过渡的开始状态**。在离开过渡被触发时立刻生效，下一帧被移除。

5. v-leave-active ：定义**离开过渡生效时的状态**。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

6. v-leave-to : 定义**离开过渡的结束状态**。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。

过渡的参数

- 动画时间 `<transition :duration="{ enter: 500, leave: 800 }">...</transition>`

- 初始渲染的过渡 `<transition appear></transition>`

- 自定义动画js钩子

  ```js
  <transition
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:after-enter="afterEnter"
    v-on:enter-cancelled="enterCancelled"
  
    v-on:before-leave="beforeLeave"
    v-on:leave="leave"
    v-on:after-leave="afterLeave"
    v-on:leave-cancelled="leaveCancelled"
  >
  </transition>
  methods: {
    // 进入中
    beforeEnter: function (el) {},
    // 当与 CSS 结合使用时
    // 回调函数 done 是可选的
    enter: function (el, done) {
      done()
    },
    afterEnter: function (el) {},
    enterCancelled: function (el) {},
    // 离开时
    beforeLeave: function (el) {},
    // 当与 CSS 结合使用时
    // 回调函数 done 是可选的
    leave: function (el, done) {
      done()
    },
    afterLeave: function (el) {},
    // leaveCancelled 只用于 v-show 中
    leaveCancelled: function (el) {}
  }
  //当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。
  ```

多元素的过渡

```js
<transition>
  //当有相同标签名的元素切换时，需要通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。
  <button v-if="isEditing" key="save">Save</button>
  <button v-else key="edit">Edit</button>
</transition>
//可以通过给同一个元素的 key attribute 设置不同的状态来代替 v-if 和 v-else
<transition>
  <button v-bind:key="isEditing">
    {{ isEditing ? 'Save' : 'Edit' }}
  </button>
</transition>
```

`<transition>` 的默认行为 - 进入和离开同时发生，多个元素切换过渡使用过渡模式

```js
<transition name="fade" mode="out-in">
  //in-out：新元素先进行过渡，完成之后当前元素过渡离开。
  //out-in：当前元素先进行过渡，完成之后新元素过渡进入。
</transition>
```

多组件过渡

多组件过渡通过动态组件实现

```js
<transition name="component-fade" mode="out-in">
  <component v-bind:is="view"></component>
</transition>
```

列表过渡

通过\<transition-group\>实现列表过渡

```js
<div id="list-demo" class="demo">
  <button v-on:click="add">Add</button>
  <button v-on:click="remove">Remove</button>
  <transition-group name="list" tag="p">
    //当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，无法平滑过渡
    <span v-for="item in items" v-bind:key="item" class="list-item">
      {{ item }}
    </span>
  </transition-group>
</div>
```

##### 插槽

- 不具名插槽

  ```js
  <button type="submit">
    //submit为后后备内容 父组件使用组件不给插槽传入值时显示后备内容  
    <slot>Submit</slot>
  </button>
  ```

  

- 具名插槽

  ```js
  //定义具名插槽
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      //没有指定name的插槽为默认插槽
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  //向具名插槽传入内容 v-slot缩写：把参数之前的所有内容 (v-slot:) 替换为字符 #
  <base-layout>
    <template v-slot:header>
      <h1>Here might be a page title</h1>
    </template>
  	//没有被包裹在带有 v-slot 的 <template> 中的内容都会被视为默认插槽的内容
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  
    <template v-slot:footer>
      <p>Here's some contact info</p>
    </template>
  </base-layout>
  ```

  

- 作用域插槽

  ```js
  <span>
    <slot v-bind:user="user">
      {{ user.lastName }}
    </slot>
  </span>
  
  <current-user>
    <template v-slot:default="slotProps">
      {{ slotProps.user.firstName }}
    </template>
  </current-user>
  ```

##### 过滤器

过滤器可以用在两个地方：双花括号插值和 `v-bind` 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示，用于常见文本格式化。

```js
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>

//组件中定义本地过滤器
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
//创建 Vue 实例之前全局定义过滤器 当全局过滤器和局部过滤器重名时，会采用局部过滤器
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({})
```



##### 渲染函数

通过createElement生成vnode

```js
createElement(
  // {String | Object | Function}
  // 一个 HTML 标签名、组件选项对象，或者
  // resolve 了上述任何一种的一个 async 函数。必填项。
  'div',

  // {Object}
  // 一个与模板中 attribute 对应的数据对象。可选。
  {
    // (详情见下一节)
  },

  // {String | Array}
  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，
  // 也可以使用字符串来生成“文本虚拟节点”。可选。
  [
    '先写一些文字',
    createElement('h1', '一则头条'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar'
      }
    })
  ]
)
```



函数式组件

functional（函数式组件）无状态 (没有响应式数据)，也没有实例 (没有 this上下文)

```js
Vue.component('my-component', {
  functional: true,
  // Props 是可选的
  props: {
    // ...
  },
  // 为了弥补缺少的实例
  // 提供第二个参数作为上下文
  render: function (createElement, context) {
    // ...
  }
})
```

##### 混入

混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

```js
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // => "hello from mixin!"
```

组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

```js
//全局混入 为自定义的选项 'myOption' 注入一个处理器。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

new Vue({
  myOption: 'hello!'
})
```

##### 插件

插件通常用来为 Vue 添加全局功能，通过全局方法 `Vue.use()` 使用插件。

```js
//多次调用也只会注册一次该插件
Vue.use(MyPlugin, { someOption: true })

new Vue({
  // ...组件选项
})
```

自定义插件

```js
MyPlugin.install = function (Vue, options) {
  // 1. 添加全局方法或 property
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 2. 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
  })

  // 3. 注入组件选项
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
  })

  // 4. 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}
```



##### 组件基础

- 组件注册

  - 全局注册

    ```js
    Vue.component('component-a', { /* options */ })
    ```

    注册之后可以用在任何新创建的 Vue 根实例 (`new Vue`) 的模板中

  - 局部注册

    ```js
    var ComponentA = { /* options */ }
    new Vue({
      el: '#app',
      components: {
        'component-a': ComponentA
      }
    })
    //在模块化系统中局部注册
    import ComponentA from './ComponentA'
    import ComponentC from './ComponentC'
    
    export default {
      components: {
        ComponentA,
        ComponentC
      }
    }
    ```

    局部注册的组件在其子组件中不可用

- prop

  ```js
  //props传递值类型
  props: {
    title: String,
    likes: Number,
    isPublished: Boolean,
    commentIds: Array,
    author: Object,
    callback: Function,
    contactsPromise: Promise // or any other constructor
  }
  ```

  所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态。

  ```js
  //prop 用来传递一个初始值，这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值
  props: ['initialCounter'],
  data: function () {
    return {
      counter: this.initialCounter
    }
  }
  // prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

- 组件通信

  - 父子组件通信

    ```js
    //父组件通过 v-on 监听子组件实例的任意事件 通过￥event访问被子组件抛出的值
    <blog-post v-on:enlarge-text="postFontSize += $event"
    ></blog-post>
    //组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件 $emit的第二个参数用来抛出特定的值
    <button v-on:click="$emit('enlarge-text', 0.1)">
      Enlarge text
    </button>
    ```

    

  - 自定义事件

    ```js
    //父组件
    <text-document :title.sync="doc.title"></text-document>
    //子组件
    this.$emit('update:title', newTitle)
    ```

    

- 动态组件&异步组件

  - 组件切换

    ```js]
    <component v-bind:is="currentTabComponent"></component>
    ```

  - 动态组件

    ```js
    <keep-alive>
      //失活的组件将会被缓存  
      <component v-bind:is="currentTabComponent"></component>
    </keep-alive>
    ```

    

  - 异步组件

    ```js
    const AsyncComponent = () => ({
      // 需要加载的组件 (应该是一个 `Promise` 对象)
      component: import('./MyComponent.vue'),
      // 异步组件加载时使用的组件
      loading: LoadingComponent,
      // 加载失败时使用的组件
      error: ErrorComponent,
      // 展示加载时组件的延时时间。默认值是 200 (毫秒)
      delay: 200,
      // 如果提供了超时时间且组件加载也超时了，
      // 则使用加载失败时使用的组件。默认值是：`Infinity`
      timeout: 3000
    })
    ```

    





#### 高级

##### 组件化

- 定义：组件是可复用的vue实例（VueComponent的实例继承自vue）

- 优点：增加代码的复用性、可维护性、可测试性

- 使用场景（组件分类）

  - 通用组件 实现基本功能具有通用性复用性 eg:按钮组件输入框组件
  - 业务组件 完成具体业务具有一定的复用性 eg:登录框 banner
  - 页面组件 组织应用各部分独立内容，在不同页面组件间切换 eg:列表页 列表详情页

- 如何使用

  - 定义 VueComponent()
  - 分类 有状态组件 functional abstract
  - 通信 props \$emit()/\$on() provide/inject \$parent/\$children
  - 内容分发 \<slot\> \<template\> v-slot
  - 使用及优化 is keep-alive 异步组件

- 组件的本质

  vue组件流程：组件配置->Vuecomponent实例->render()->virtualDOM->DOM，vue组件的本质是产生虚拟dom

##### 组件通信

1. props

   ```js
   //父给子传值
   
   //child
   props:{msg:string}
   //parent
   <test msg='test'></test>
   ```

2. 自定义事件

   ```js
   //子给父传值
   
   //child
   this.$emit('add',good)
   //parent
   <cart @add='cartAdd($event)'></cart>
   ```

3. 事件总线

   ```js
   // Bus：事件派发、监听和回调管理
   class Bus {
       constructor(){
           this.callbacks = {}
       }
       $on(name, fn){
           this.callbacks[name] = this.callbacks[name] || [] this.callbacks[name].push(fn)
       }
       $emit(name, args){
           if(this.callbacks[name]){
              this.callbacks[name].forEach(cb => cb(args))
           }
       }
   }
   // main.js 
   Vue.prototype.$bus = new Bus() 
   // child1 
   this.$bus.$on('foo', handle) 
   // child2 
   this.$bus.$emit('foo')
   ```

4. vuex

5. \$parent/​\$root

   兄弟组件之前通信可以通过共同祖辈(\$parent、\$root)搭桥

   ```js
   // brother1
   this.$parent.$on('foo', handle)
   // brother2
   this.$parent.$emit('foo')
   ```

6. $children

   ```js
   //父组件可以通过$children访问子组件实现父子通信
   // parent
   this.$children[0].xx = 'xxx'
   ```

   > $children不能保证子元素顺序

7. $attr/\$listenners

   当一个组件没有声明任何 prop 时，包含所有父作用域的绑定 ( class 和 style 除外)可以通过 v- bind="$attrs" 传入内部组件

   ```js
   // child：并未在props中声明foo
   <p>{{$attrs.foo}}</p> 
   // parent 
   <HelloWorld foo="foo"/>
   ```

   

8. refs

   ```js
   // parent
   <HelloWorld ref="hw"/>
   //获取到refs的引用    
   mounted() { this.$refs.hw.xx = 'xxx' }
   ```

9. provide/inject

   ```js
   //祖先和后代之间传值
   // ancestor
   provide() { return {foo: 'foo'} }
   // descendant
   inject: ['foo']
   ```

##### 组件化案例- 表单组件

需求分析

- 实现KForm

  指定数据、校验规则

- 实现KformItem

  执行校验

  显示错误信息

- 实现KInput

  维护数据

组件构建





##### v-cli

1. 安装 `npm install -g @vue/cli`

2. 使用 

   - 创建一个项目 `vue create hello-world`

3. 处理资源路径

   当你在 JavaScript、CSS 或 *.vue 文件中使用相对路径 (必须以 . 开头) 引用一个静态资源时，该资源将被webpack处理。

   -  URL 是一个绝对路径 (例如 /images/foo.png )，它将会被保留不变。

     ```js
     <img alt="Vue logo" src="/assets/logo.png"
     ```

   - URL 以 . 开头会作为一个相对模块请求被解释并基于文件系统相对路径。

     ```js
     <img alt="Vue logo" src="./assets/logo.png">
     ```

   - URL 以 ~ 开头会作为一个模块请求被解析。这意味着你甚至可以引用 Node 模块中的资源：

     ```js
     <img src="~some-npm-package/foo.png">
     ```

   -  URL 以 @ 开头会作为一个模块请求被解析。Vue CLI 默认会设置一个指向 src 的别名 @ 。

     ```js
     import Hello from '@/components/Hello.vue'
     ```

4. 何时使用public 文件夹

   通过 webpack 的处理并获得如下好处：

   - 脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。

   - 文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。

   - 最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。

   如下情况考虑使用public文件夹

   - 需要在构建输出中指定一个固定的文件名字。

   - 有上千个图片，需要动态引用它们的路径。

   - 有些库可能和 webpack 不兼容，除了将其用一个独立的 <script> 标签引入没有别的选择。

   使用public文件夹的注意事项

   - 如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 前缀

     ```js
     // vue.config.js
     module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/cart/' : '/' }
     ```

   - 在 public/index.html 等通过 html-webpack-plugin 用作模板的 HTML 文件中，你需要通过<%= BASE_URL %> 设置链接前缀：

     ```js
     <link rel="icon" href="<%= BASE_URL %>favicon.ico">
     ```

   - 在模板中，先向组件传入BASE_URL： 

     ```js
     data () { return { publicPath: process.env.BASE_URL } }
     
     <img :src="`${publicPath}my-image.png`">
     ```

5. 处理css样式

   - 使用预处理器

     如果创建项目时没有选择需要的预处理（Sass/Less/Stylus），则需手动安装相应loader

     ```js
     # Sass
     npm install -D sass-loader sass
     
     # Less
     npm install -D less-loader less
     
     # Stylus
     npm install -D stylus-loader stylus
     
     //使用
     <style lang="scss">
     $color: red;
     </style>
     ```

   - 自动化导入样式

     自动化导入样式文件 (用于颜色、变量、mixin等)，可以使用 style-resources-loader

     ```js
     npm i -D style-resources-loader
     
     //配置
     const path = require('path')
     function addStyleResource(rule) {
         rule.use('style-resource')
             .loader('style-resources-loader')
             .options({ patterns: [ path.resolve(__dirname, './src/styles/imports.scss')]})
     }
     module.exports = {
         chainWebpack: config => { 
             const types = ['vue-modules', 'vue', 'normal-modules', 'normal'] 
             types.forEach(type => addStyleResource(config.module.rule('scss').oneOf(type)))
         }
     }
     ```

   - scoped css

     当 \<style\> 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素

     ```js
     <style scoped> .red { color: red; }</style>
     
     //原理是通过postcss转换
     <template>
         <div class="red" data-v-f3f3eg9>hi</div> </template>
     <style>
       .red[data-v-f3f3eg9] { color: red; }
     </style>
     ```

     深度作用选择器：使用 >>> 操作符可以使 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件。

     ```js
     <style scoped>
         #app >>> a { color: red }
     </style>
     
     //Sass 之类的预处理器无法正确解析 >>> 。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符
     <style scoped lang="scss">
         #app { 
     		/deep/ a { color: rgb(196, 50, 140) }
     		::v-deep a { color: rgb(196, 50, 140) } 	}
     </style>
     ```

   - css module

     CSS Modules 是用于模块化和组合 CSS 的系统

     ```js
     //添加module
     <style module lang="scss">
         .red { color: #f00; }
         .bold { font-weight: bold; }
     </style>
     //模板中通过$style.xx访问
     <a :class="$style.red">awesome-vue</a>
     <a :class="{[$style.red]:isRed}">vue</a>
     <a :class="[$style.red, $style.bold]">vue</a>          
     ```

## vue-router

#### 安装

1. npm安装 `npm install vue-router`

2. router插件使用

   ```js
   import Vue from 'vue'
   import VueRouter from 'vue-router'
   
   Vue.use(VueRouter)
   ```

#### 基础

##### 使用

```html
<div id="app">
  <p>
    <!-- 使用 router-link 组件来导航 通过传入to属性指定链接 -->
    <!-- <router-link> 默认会被渲染成一个 <a> 标签 -->
    <router-link to="/foo">Go to Foo</router-link>
    <router-link to="/bar">Go to Bar</router-link>
  </p>
  <!-- 路由出口 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
```

```js
// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)

// 1. 定义 (路由) 组件 可以从其他文件 import 进来
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }

// 2. 定义路由
// 每个路由应该映射一个组件。 其中"component" 可以是通过 Vue.extend() 创建的组件构造器，或者，只是一个组件配置对象。
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]

// 3. 创建 router 实例，传入routes配置
const router = new VueRouter({
  routes
})

// 4. 创建和挂载根实例 通过 router 配置参数注入路由，从而让整个应用都有路由功能
const app = new Vue({
  router
}).$mount('#app')

//可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由
export default {
  computed: {
    username() {
      return this.$route.params.username
    }
  },
  methods: {
    goBack() {
      window.history.length > 1 ? this.$router.go(-1) : this.$router.push('/')
    }
  }
}
```



##### 动态路由匹配

```js
const User = {
  //参数值会被设置到 this.$route.params  
  template: '<div>User {{ $route.params.id }}</div>'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User },
    // *会匹配所有路径 要放在最后 一般用于404页面 
    { path: '*', component: _404}  
  ]
})

//用一个通配符时，$route.params 内会自动添加一个名为 pathMatch 参数。它包含了 URL 通过通配符被匹配的部分
this.$router.push('/user-admin')
this.$route.params.pathMatch // 'admin'
// 给出一个路由 { path: '*' }
this.$router.push('/non-existing')
this.$route.params.pathMatch // '/non-existing'
```



##### 嵌套路由

```js
const router = new VueRouter({
  routes: [
    //以 / 开头的嵌套路径会被当作根路径  
    { path: '/user/:id', component: User,
      children: [
        {
          // 当 /user/:id/profile 匹配成功，
          // UserProfile 会被渲染在 User 的 <router-view> 中
          path: 'profile',
          component: UserProfile
        },
        {
          // 当 /user/:id/posts 匹配成功
          // UserPosts 会被渲染在 User 的 <router-view> 中
          path: 'posts',
          component: UserPosts
        }
      ]
    }
  ]
})

```



##### 编程导航

`router.push(location, onComplete?, onAbort?)`实现路由跳转

`<router-link>` 创建 a 标签来定义导航链接，点击 `<router-link :to="...">` 等同于调用 `router.push(...)`

```js
const userId = '123'
router.push({ name: 'user', params: { userId }}) // -> /user/123
router.push({ path: `/user/${userId}` }) // -> /user/123
// 这里的 params 不生效
router.push({ path: '/user', params: { userId }}) // -> /user

```

`router.go(n)`是在 history 记录中向前或者后退多少步

```js
// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)

// 后退一步记录，等同于 history.back()
router.go(-1)
```





##### 命名路由&命名视图

```js
const router = new VueRouter({
  routes: [
    {
      path: '/user/:userId',
      //给router命名  
      name: 'user',
      component: User
    }
  ]
})
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
router.push({ name: 'user', params: { userId: 123 }})
```

(同级) 展示多个视图，而不是嵌套展示使用命名视图

```js
//通过name指定视图名 route设置不同组件渲染
<router-view class="view one"></router-view>
<router-view class="view two" name="a"></router-view>
<router-view class="view three" name="b"></router-view>

const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})

//命名视图可以嵌套使用
/settings/emails                                       /settings/profile
+-----------------------------------+                  +------------------------------+
| UserSettings                      |                  | UserSettings                 |
| +-----+-------------------------+ |                  | +-----+--------------------+ |
| | Nav | UserEmailsSubscriptions | |  +------------>  | | Nav | UserProfile        | |
| |     +-------------------------+ |                  | |     +--------------------+ |
| |     |                         | |                  | |     | UserProfilePreview | |
| +-----+-------------------------+ |                  | +-----+--------------------+ |
+-----------------------------------+                  +------------------------------+
<div>
  <h1>User Settings</h1>
  <NavBar/>
  <router-view/>
  <router-view name="helper"/>
</div>

{  path: '/settings',
  // 在顶级路由就配置命名视图
  component: UserSettings,
  children: [{
    path: 'emails',
    component: UserEmailsSubscriptions
  }, {
    path: 'profile',
    components: {
      default: UserProfile,
      helper: UserProfilePreview
    }
  }]
}
```

#### 进阶

##### 路由守卫

参数或查询的改变并不会触发进入/离开的导航守卫

- 全局前置守卫

  ```js
  const router = new VueRouter({ ... })
  
  router.beforeEach((to, from, next) => {
    // to: Route: 即将要进入的目标 路由对象
    // from: Route: 当前导航正要离开的路由
    // next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数 
      next()
  })
  
  ```

- 路由独享守卫

  ```js
  const router = new VueRouter({
    routes: [
      {
        path: '/foo',
        component: Foo,
        beforeEnter: (to, from, next) => {
          // ...
        }
      }
    ]
  })
  ```

- 组件内守卫

  ```js
  const Foo = {
    template: `...`,
    beforeRouteEnter (to, from, next) {
      // 在渲染该组件的对应路由被 confirm 前调用，不能获取组件实例this，因为当守卫执行前，组件实例还没被创建
    },
    beforeRouteUpdate (to, from, next) {
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例this
    },
    beforeRouteLeave (to, from, next) {
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例this
    }
  }
  ```

**导航解析流程**

1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫 (2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。

```js
//通过transiton给路由切换增加过渡动效
<transition>
  <router-view></router-view>
</transition>
```

##### 路由数据获取

- 路由导航前获取数据 导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航

  ```js
  // 组件未渲染，通过给next传递回调访问组件实例 
  beforeRouteEnter (to, from, next) {
      getPost(to.params.id, post => { next(vm => vm.setData(post)) })
  },
  // 组件已渲染，可以访问this直接赋值
  beforeRouteUpdate (to, from, next) {
      this.post = null
      getPost(to.params.id, post => {
          this.setData(post)
          next()
      })
  }
  ```

- 路由导航后获取数据 先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示

  ```js
  created () {
      this.fetchData() },
      watch: { '$route': 'fetchData' }
  }
  ```

- 路由数据缓存

  ```js
  <keep-alive include="about">
      <router-view></router-view>
  </keep-alive>
  ```

##### 路由懒加载

结合 Vue 的[异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件)[ ](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件)和 Webpack 的[代码分割功能](https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/)[ ](https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/)，实现路由组件的懒加载

```js
const Foo = () => import('./Foo.vue')

const router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo }
  ]
})
```

## vuex

#### 安装

```js
npm install vuex --save
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

//v-cli中
vue add vuex
```

#### vuex数据流

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\vuex.png)

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

2. 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化

#### state



#### getters

#### mutations

#### actions

#### modules



## vue-ssr

服务端渲染：将vue实例渲染为HTML字符串直接返回，在前端激活为交互程序

ssr优点

- 更好的SEO，因为搜索引擎爬虫将直接看到完整呈现的页面
- 更快的内容到达时间 (time-to-content)

ssr缺点

- 开发逻辑复杂
- 开发条件限制：比如一些生命周期不能用，一些第三方库会不能用
- 服务器负载大

#### 安装使用

1. 安装 `npm i vue vue-server-renderer -S`

    vue-cli中`vue create ssr` 安装依赖`npm i vue-server-renderer express -D`

2. 使用

   渲染一个vue实例

   ```js
   //1创建vue实例
   const Vue = require('vue')
   const app = new Vue({
       template:'<div>hello</div>'
   })
   //2获取渲染器实例
   const {createRenderer} =  require('vue-server-renderer')
   const renderer = createRenderer()
   //3用渲染器渲染vue实例
   renderer.renderToString(app).then(html=>{
       console.log(html)
   }).catch(err=>{
       console.log(err)
   })
   ```

3. 与服务器集成  express

   - 安装express `npm i express -S `

   - 集成

     ```js
     const express = require('express') 
     // 获取express实例 
     const server = express() 
     const Vue = require('vue')
     //获取渲染器实例
     const createRenderer = require('vue-server-renderer')
     const renderer = createRenderer()
     // 编写路由处理不同url请求 
     server.get('/', (req, res)=>{ 			
         //res.send('<strong>hello world</strong>')
         //创建vue实例
         const app = new Vue({
             template:'<div @click="onClick">{{msg}}</div>',
             data(){
                 return {msg:'vue ssr'}
             },
             methods:{
                 onClick(){
                     console.log('hello')
                 }
             }
         })
         renderer.renderToString(app).then(html=>{
             res.send(html)
         }).catch(err=>{
             res.status(500)
             res.send('server error 500')
     	})
     })
     // 监听端口 
     server.listen(80, () => { console.log('server running!'); })
     ```


#### 路由ssr

1. 配置router.js

   ```js
   import Vue from "vue"; 
   import Router from "vue-router"; 
   import Home from "@/views/Home"; 
   import About from "@/views/About"; 
   Vue.use(Router); 
   //导出工厂函数 
   export function createRouter() { 
       return new Router({ 
           routes: [ { path: "/", component: Home }, { path: "/about", component: About } ]
       });
   }
   ```

2. 构建

   ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\ssr.png)

   对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记

   ```js
   src 
   ├── main.js # 用于创建vue实例 
   ├── entry-client.js # 客户端入口，用于静态内容“激活” 
   └── entry-server.js # 服务端入口，用于首屏内容渲染
   ```

3. 创建vue实例 main.js

   ```js
   import Vue from "vue"; 
   import App from "./App.vue";
   import { createRouter } from "./router";
   // 导出Vue实例工厂函数，为每次请求创建独立实例 
   // 上下文用于给vue实例传递参数 
   export function createApp(context) { 
       const router = createRouter(); 
       const app = new Vue({ 
           router,
           context,
           render: h => h(App) 
       }); 
       return { app, router };
   }
   ```

4. 服务端入口entry-server.js

   ```js
   import { createApp } from "./main"; 
   // 返回一个函数，接收请求上下文，返回创建的vue实例 
   export default context => { 
       // 这里返回一个Promise，确保路由或组件准备就绪
   	return new Promise((resolve, reject) => {
           const { app, router } = createApp(context); 
           // 跳转到首屏的地址 
           router.push(context.url); 
           // 路由就绪，返回结果 
           router.onReady(() => { resolve(app); }, reject); 
       });
   };
   ```

5. 客户端入口   enrty-client.js

   ```js
   //客户端入口只需创建vue实例并执行挂载，这一步称为激活
   import { createApp } from "./main"; 
   // 创建vue、router实例 
   const { app, router } = createApp(); 
   // 路由就绪，执行挂载 
   router.onReady(() => { app.$mount("#app"); });
   ```

6. 配置webpack

   - 安装依赖 `npm i webpack-node-externals lodash.merge -D `

   - 配置vue.config.js

     ```js
     // 两个插件分别负责打包客户端和服务端 
     const VueSSRServerPlugin = require("vue-server-renderer/server-plugin"); 
     const VueSSRClientPlugin = require("vue-server-renderer/client-plugin"); 
     const nodeExternals = require("webpack-node-externals"); 
     const merge = require("lodash.merge"); 
     // 根据传入环境变量决定入口文件和相应配置项 
     const TARGET_NODE = process.env.WEBPACK_TARGET === "node"; 
     const target = TARGET_NODE ? "server" : "client"; 
     module.exports = { 
         css: { extract: false },
         outputDir: './dist/'+target, 
         configureWebpack: () => ({ 
             // 将 entry 指向应用程序的 server / client 文件 
             entry: `./src/entry-${target}.js`,
             // 对 bundle renderer 提供 source map 支持 
             devtool: 'source-map', 
             // target设置为node使webpack以Node适用的方式处理动态导入，并且还会在编译Vue组件时告知`vue-loader`输出面向服务器代码。 
             target: TARGET_NODE ? "node" : "web",
             // 是否模拟node全局变量 
             node: TARGET_NODE ? undefined : false, 
             output: { 
                 // 此处使用Node风格导出模块 
                 libraryTarget: TARGET_NODE ? "commonjs2" : undefined 
             },
             // https://webpack.js.org/configuration/externals/#function 
             // https://github.com/liady/webpack-node-externals 
             // 外置化应用程序依赖模块。可以使服务器构建速度更快，并生成较小的打包文件。 
             externals: TARGET_NODE ? nodeExternals({ 
                 // 不要外置化webpack需要处理的依赖模块。可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件，还应该将修改`global`（例如polyfill）的依赖模块列入白名单 
                 whitelist: [/\.css$/] }) : undefined, 
             	optimization: { splitChunks: undefined },
             // 这是将服务器的整个输出构建为单个 JSON 文件的插件。服务端默认文件名为 `vue-ssr-server-bundle.json` 客户端默认文件名为 `vue-ssr-client-manifest.json`。 
             plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()] }),
         	chainWebpack: config => { 
                 // cli4项目添加 
                 if (TARGET_NODE) { 
                     config.optimization.delete('splitChunks') 
                 }
                 config.module .rule("vue") 
                     		  .use("vue-loader") 
                     		  .tap(options => { merge(options, { optimizeSSR: false }); });
             }
     };
     ```

7. 修改服务器启动文件

   ```js
   // 加载本地文件 
   const fs = require("fs"); 
   // 处理url 
   const path = require("path"); 
   const express = require('express') 
   const server = express() 
   // 获取绝对路径 
   const resolve = dir => { return path.resolve(__dirname, dir) }
   // 第 1 步：开放dist/client目录，关闭默认下载index页的选项，不然到不了后面路由 
   // /index.html 
   server.use(express.static(resolve('../dist/client'), {index: false})) 
   // 第 2 步：获得一个createBundleRenderer
   const { createBundleRenderer } = require("vue-server-renderer"); 
   // 第 3 步：导入服务端打包文件 
   const bundle = require(resolve("../dist/server/vue-ssr-server-bundle.json")); 
   // 第 4 步：创建渲染器 
   const template = fs.readFileSync(resolve("../public/index.html"), "utf-8");
   const clientManifest = require(resolve("../dist/client/vue-ssr-client- manifest.json"));
   const renderer = createBundleRenderer(bundle, { 
       runInNewContext: false, // https://ssr.vuejs.org/zh/api/#runinnewcontext 
       template, // 宿主文件 
       clientManifest // 客户端清单 
   }); 
   // 路由是通配符，表示所有url都接受 
   server.get('*', async (req,res)=>{ 
       console.log(req.url); 
   	// 设置url和title两个重要参数 
   	const context = { 
     	  title:'ssr test',
     	  url:req.url // 首屏地址 
   	}
   	const html = await renderer.renderToString(context);
   	res.send(html) 
   })
   server.listen(3000, function() { 
       // eslint-disable-next-line no-console 
       console.log(`server started at localhost:${port}`);
   });
   ```

#### vuex加入ssr

1. 设置store.js

   ```js
   import Vue from 'vue' 
   import Vuex from 'vuex' 
   Vue.use(Vuex) 
   export function createStore () { 
       return new Vuex.Store({
           state: { count:108 },
           mutations: { add(state){ state.count += 1; } }
       })
   }
   ```

2. 挂载store main.js

   ```js
   import { createStore } from './store' 
   export function createApp (context) { 
       // 创建实例 
       const store = createStore() 
       const app = new Vue({ 
           store, // 挂载 
           render: h => h(App) 
       })
       return { app, router, store }
   }
   ```

3. 数据预取

   服务器端渲染的是应用程序的"快照"，如果应用依赖于一些异步数据，在开始渲染之前，需要先预取和解析好这些数据。

   - 异步数据获取 store/inde.js

     ```js
     export function createStore() { 
         return new Vuex.Store({ 
             mutations: { 
                 // 加一个初始化 
                 init(state, count) { state.count = count; }, 
             },
             actions: { 
                 // 加一个异步请求count的action 
                 getCount({ commit }) { 
                     return new Promise(resolve => { 
                         setTimeout(() => { commit("init", Math.random() * 100); resolve(); }, 1000);
                     });
                 },
             },
         });
     }
     ```

   - 组件中的数据预取逻辑，Index.vue

     ```js
     export default { 
         asyncData({ store, route }) { 
             // 约定预取逻辑编写在预取钩子asyncData中  触发 action 后，返回 Promise 以便确定请求结果 
             return store.dispatch("getCount"); 
         }
     };
     ```

   - 服务端数据预取，entry-server.js

     ```js
     import { createApp } from "./app"; 
     export default context => { 
         return new Promise((resolve, reject) => {
             // 拿出store和router实例 
             const { app, router, store } = createApp(context);
             router.push(context.url);
             router.onReady(() => { 
                 // 获取匹配的路由组件数组 
                 const matchedComponents = router.getMatchedComponents(); 
                 // 若无匹配则抛出异常 
                 if (!matchedComponents.length) { return reject({ code: 404 }); }
                 // 对所有匹配的路由组件调用可能存在的`asyncData()`
                 Promise.all( matchedComponents.map(Component => { 
                     if (Component.asyncData) { 
                         return Component.asyncData({ store, route: router.currentRoute }); 
                     } 
                 }).then(() => { 
                     // 所有预取钩子 resolve 后，store 已经填充入渲染应用所需状态，将状态附加到上下文，且 `template` 选项用于 renderer 时，状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。 
                     context.state = store.state;
                     resolve(app); 
                 }).catch(reject); }, reject);
         });
     };
     ```

   - 客户端在挂载到应用程序之前，store 就应该获取到状态，entry-client.js

     ```js
     // 导出store 
     const { app, router, store } = createApp(); 
     // 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态自动嵌入到最 终的 HTML 在客户端挂载到应用程序之前，store 就应该获取到状态： 
     if (window.__INITIAL_STATE__) { 
         store.replaceState(window.__INITIAL_STATE__);
     }
     ```

   - 客户端数据预取处理，main.js

     ```js
     Vue.mixin({ 
         beforeMount() { 
             const { asyncData } = this.$options; 
             if (asyncData) { 
                 // 将获取数据操作分配给 promise 以便在组件中，我们可以在数据准备就绪后 通过运行 `this.dataPromise.then(...)` 来执行其他任务 
                 this.dataPromise = asyncData({ store: this.$store, route: this.$route, });
             }
         },
     });
     ```

## nuxt.js

Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。

#### nuxt渲染流程

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\nuxt-schema.svg)

#### 安装使用

1. 安装 `$ npx create-nuxt-app <项目名>`

2. nuxt目录结构

   ```js
   nuxt
   ├── assets # 资源目录 未编译的静态资源less sass等
   ├── component # 组价目录
   ├── layout #布局目录
   ├── middleware #中间件目录
   ├── pages #应用的路由及视图 读取该目录下所有的 .vue 文件并自动生成对应的路由配置
   ├── plugins #根vue.js应用实例化之前需要运行的JS插件
   ├── static #静态文件目录
   ├── store #vuex状态树
   ├── package.json 
   └── nuxt.config.js #
   ```

#### 路由添加

pages目录下的.vue文件自动生成路由配置

```js
<nav>
    //等同于router-link
    <nuxt-link to="/">首页</nuxt-link> 
	//别名：n-link，NLink，NuxtLink
    <NLink to="/admin">管理</NLink>
	<n-link to="/cart">购物车</n-link> 
</nav>
//禁用预加载行为： <n-link no-prefetch>page not pre-fetched</n-link>
<template>
        <div>
        	<h2>detail</h2> 
			//等同于router-view
			<nuxt-child></nuxt-child> 
		</div> 
</template>
```

**以下划线作为前缀**的 .vue文件 或 目录会被定义为动态路由

```js
pages/
--| users/
-----| _id.vue
{ 
    path: "/detail/:id?", 
    component: _9c9d895e, 
    name: "detail-id"
}
```

创建内嵌子路由，你需要添加一个 .vue 文件，同时添加一个**与该文件同名**的目录用来存放子视图组件

```js
pages/ 
    --| detail/ 
    ----| _id.vue 
    --| detail.vue
{ 
    path: '/detail', 
    component: 'pages/detail.vue', 
    children: [ {path: ':id?', name: "detail-id"} ]
}
```

通过 router.extendRoutes 选项配置添加自定义路由

```js
// nuxt.config.js 
export default { 
    router: { 
        extendRoutes (routes, resolve) { 
            routes.push({ 
                name: "foo", 
                path: "/foo", 
                component: resolve(__dirname, "pages/custom.vue") });
        } 
    }
}
```

#### 视图

![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\nuxt-views-schema.svg)

```js
//默认布局
<template> <nuxt/> </template>

//自定义布局
//1.layout文件夹创建自定义文件 blog.vue
<template>
  <div>
    <div>我的博客导航栏在这里</div>
    <nuxt/>
  </div>
</template>
//2.page/使用自定义布局
<template>
<!-- Your template -->
</template>
<script>
export default {
  layout: 'blog'
  // page component definitions
}
</script>
```





#### 异步数据获取

asyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的[上下文对象](https://www.nuxtjs.cn/api#上下文对象)，利用 asyncData方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。

1. 安装@nuxt/axios模块： `npm install @nuxtjs/axios -S`

2. 配置nuxt.confifig.js

   ```js
   modules: ['@nuxtjs/axios'],
   axios: { proxy: true },
   proxy: { "/api": "http://localhost:8080" },
   ```

3. 获取数据

   ```js
   export default { 
       async asyncData({ $axios, error }) { 
           const {ok, goods} = await $axios.$get("/api/goods");
           if (ok) { return { goods }; }
           // 错误处理 
           error({ statusCode: 400, message: "数据查询失败" });
       },
   }
   
   <template> 
       <div> 
       	<pre v-if="goodInfo">{{goodInfo}}</pre> 
   	</div> 
   </template> 
   <script> 
   	export default { 
   		async asyncData({ $axios, params, error }) { 
               if (params.id) { 
                   // asyncData中不能使用this获取组件实例但是可以通过上下文获取相关数据 
                   const { data: goodInfo } = await $axios.$get("/api/detail", { params }); 
                   if (goodInfo) { return { goodInfo }; }
                   error({ statusCode: 400, message: "商品详情查询失败" }); 
               } else { 
                   return { goodInfo: null }; } 
           }
   };
   </script>
   ```

#### 中间件

中间件会在一个页面或一组页面渲染之前运行我们定义的函数，常用于权限控制、校验等任务。

中间件使用

1. 创建中间件 middleware/auth.js

   ```js
   export default function({ route, redirect, store }) {
       // 上下文中通过store访问vuex中的全局状态 通过vuex中令牌存在与否判断是否登录 
       if (!store.state.user.token) { redirect("/login?redirect="+route.path); } 
   }
   ```

2. 注入中间件

   ```js
   //admin.vue 局部注册
   <script> export default { middleware: ['auth'] } </script>
   //nuxt.config.js 全局注册
   router: { middleware: ['auth'] }
   ```

#### 状态管理vuex

应用根目录下如果存在 store 目录，Nuxt.js将启用vuex状态树。定义各状态树时具名导出state,mutations, getters, actions即可。

```js
// store/uer.js
export const state = () => ({ 
    token: '' 
}); 
export const mutations = { 
    init(state, token) { state.token = token; }
};
export const getters = {
    isLogin(state) { return !!state.token; }
};
export const actions = { 
    login({ commit, getters }, u) { 
        return this.$axios.$post("/api/login", u).
        				  then(({ token }) => {
            					if (token) { commit("init", token);
						  }
            return getters.isLogin; 
        });
    }
};
```



## typescript

#### 安装使用

1. npm安装

   -  下载`npm install -g typescript`
   - 配置 `tsc --init`
   - 编译 `npm init`

2. 安装Visual Studio的TypeScript插件

3. 工程化

   - 安装相关工具 webpack webpack-cli webpack-dev-server

     `npm i webpack webpack-cli webpack-dev-server ts-loader typescript html-webpack-plugin`

   - 配置webpack.config.js

     ```js
     const htmlWebpackPlugin = require('html-webpack-plugin')
     module.exports = {
         entry:'./src/index.ts',
         output:{
             filename:'app.js'
         },
         resolve:{
             //模块导入扩展名处理
             extensions : ['.js','.ts','.tsx']
         },
         devtool:'cheap-module-eval-source-map',
         module:{
             rules:[
                 {
                     test:/\.tsx?$/i,
                     user:[{
                         loader:'ts-loader'
                     }],
                     exclude:/node_modules/
                 }
             ]
         },
         plugins:[
             new htmlWebpackPlugin({
                 template:'./public/index.html'
             })
         ]
     }
     ```

#### 基础语法

1. 基础类型

   - 布尔  `let isDone:boolean = false`

   - 数字  ts支持十进制十六进制二进制八进制`let decLiteral:number = 6`

   - 字符串 支持模板字符串`${expr} `使用引号表示

     ```js
     let name:string = 'test'
     let sentence:string = `hello my name is ${name}`
     ```

   - 数组

     ```js
     let list:number = [1,2,3]
     let list:Array<number> = [1,2,3]
     ```

   - 元祖tuple 允许表示一个已知元素数量和类型的数组，各元素的类型不必相同

     ```js
     let x:[string,number] = ['hello',11]
     ```

   - 枚举enum 

     ```js
     enum Color{Red,Green,Blue}
     let c:Color = Color.Green
     ```

   - 任意值any

     ```js
     //在编程阶段还不清楚类型的变量时指定的类型
     let notSure: any = 4;
     ```

   - 空值void 表示没有任何类型只能赋值为null或undefined

     ```js
     function warnUser(): void {
         //表示函数没有返回值
         alert("This is my warning message");
     }
     ```

   - null undefined

2. 变量声明 

   let和const声明变量

   变量解构{}和展开...

3. 接口 

   接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。`interface 接口名{}`

   ```typescript
   //接口使用
   interface IPerson { 
       firstName:string, 
       lastName:string, 
       sayHi: ()=>string 
   } 
    
   var customer:IPerson = { 
       firstName:"Tom",
       lastName:"Hanks", 
       sayHi: ():string =>{return "Hi there"} 
   } 
    
   console.log("Customer 对象 ") 
   console.log(customer.firstName) 
   console.log(customer.lastName) 
   console.log(customer.sayHi()) 
   
   //接口为联合类型
   interface RunOptions { 
       //?表示可选属性
       width?: number;
       //只读属性
       readonly x: number;
       program:string; 
       commandline:string[]|string|(()=>string); 
   } 
   //接口和数组
   interface namelist { 
      [index:number]:string 
   } 
    
   var list2:namelist = ["John",1,"Bran"] // 错误元素 1 不是 string 类型
   //接口继承 使用extends
   Child_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name
   ```

4. 类

   ```js
   class Greeter {
       //字段 类里声明的变量 
       greeting: string;
   	//构造函数
       constructor(message: string) {
           this.greeting = message;
       }
   	//方法
       greet() {
           return "Hello, " + this.greeting;
       }
   }
   //创建一个对象
   let greeter = new Greeter("world");
   ```

   类的继承

   子类只能继承一个父类，但可以多重继承

   ```js
   class Animal {
       name: string;
       constructor(theName: string) { this.name = theName; }
       move(distanceInMeters: number = 0) {
           console.log(`${this.name} moved ${distanceInMeters}m.`);
       }
   }
   
   //super()会执行基类的构造函数 构造函数里访问 this的属性之前一定要调用 super()
   class Snake extends Animal {
       constructor(name: string) { super(name); }
       move(distanceInMeters = 5) {
           console.log("Slithering...");
           super.move(distanceInMeters);
       }
   }
   ```

   TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。

   - **public（默认）** : 公有，可以在任何地方被访问。
   - **protected** : 受保护，可以被其自身以及其子类和父类访问。
   - **private** : 私有，只能被其定义所在的类访问。

   通过g存取器etters/setters来截取对对象成员的访问，能有效的控制对对象成员的访问

   ```js
   let passcode = "secret passcode";
   
   class Employee {
       private _fullName: string;
   
       get fullName(): string {
           return this._fullName;
       }
   
       set fullName(newName: string) {
           if (passcode && passcode == "secret passcode") {
               this._fullName = newName;
           }
           else {
               console.log("Error: Unauthorized update of employee!");
           }
       }
   }
   
   let employee = new Employee();
   employee.fullName = "Bob Smith";
   if (employee.fullName) {
       alert(employee.fullName);
   }
   ```

5. 函数 

   ```js
   function greeting(person: string, msg?: string): string { 
       //person为必传参 msg为可选参数
       return "Hello, " + person;
   }
   ```

   函数重载 ：用参数数量或类型来区分多个同名函数

   ```js
   // 重载1 
   function watch(cb1: () => void): void; 
   // 重载2 
   function watch(cb1: () => void, cb2: (v1: any, v2: any) => void): void; 
   // 实现 
   function watch(cb1: () => void, cb2?: (v1: any, v2: any) => void) { 
       if (cb1 && cb2) { 
           console.log('执行watch重载2'); 
        } else {
           console.log('执行watch重载1');
        }
   }
   ```

6. 泛型 指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。以此增加代码通用性

   ```typescript
   //类型变量T捕获用户传入的类型（比如：number），之后就可以使用这个类型
   function identity<T>(arg: T): T {
       return arg;
   }
   //泛型使用
   let output = identity<string>("myString")
   let output = identity("myString")
   ```

7. 装饰器



#### 类型

- 类型注解 指定一个类型 `const a: number = 123;`

- 类型推断 根据值推断变量的类型 `let count = 122434`

- 联合类型 变量类型是多种之一 `let union: string | number; 

- 交叉类型 多种类型合并成的类型

  ```typescript
  type First = {first: number}; 
  type Second = {second: number}; 
  type FirstAndSecond = First & Second; 
  function fn3(param: FirstAndSecond):FirstAndSecond { 
      return {first:1, second:2}
  }
  ```

  



## es6



#### 作用域变量

作用域是一个变量的作用范围。es5中只有全局作用域和函数作用域

var缺点

- 没有块级作用域，定义后在当前闭包中都可以访问

  ```js
  if(true){
      var a = 'a'
  }
  console.log(a) //a
  ```

- var在for循环标记变量共享

  ``` js
  for(var i = 0; i < 3; i++){
      setTimeout(function(){
          alert(i) //alert 3,3,3
      },0)
  }
  ```

- 可以重复声明，变量名重复时会覆盖前面定义放变量也可能被其他人更改

- 不能定义常量

块级作用域

- 实现块级作用域

- 不会污染全局对象

- 重复定义会报错

- 不存在变量的预解释

- 闭包的新写法

  ```js
  (function(){
      //es5闭包
  })()
  {
      //es6闭包
      let a = 10
  }
  
  for(var i = 0; i < 3; i++){
      （function(i){
          setTimeout(function(){
         	 alert(i)
      	},0)
      })(i)
  }
  for(let i = 0; i < 3; i++){
      setTimeout(function(){
          alert(i)
      },0)
  }
  ```

#### 常量

使用const声明一个常量 常量一旦被定义就不能被修改

- 常量不能重新赋值

  ```js
  const MY_NAME = 'test'
  MY_NAME = 'change' //Assignment to constant variable
  ```

- 变量值可改变但不能重新赋值

  ```js
  const names = ['testArr1']
  names.push('testArr2')
  console.log(names)
  ```

- 不同块级作用域可以多次定义

  ```js
  cosnt A = '0'
  {
      const A = 'A'
      console.log(A)
  }
  ```

  

####解构

解构实等号两边结构类似，右边是一个真实的值

- 解析数组 `let [name,age] = ['test','8']`

- 嵌套赋值 

  ```js
  let [x,[y],z] = [1,[2.1,2.2]] //1,2.1,undefined
  let [x,[y,z]] = [1,[2.1,2.2]] //1,2.1,2.2
  let [json,arr,num] = [{name:'test'},[1,2],3] //{name:'test'},[1,2],3
  ```

- 省略赋值 `let [,,x] = [1,2,3]`

- 解构对象 `let {name,age} = {name:'test',age:'9'}`

- 默认值 在赋值和传参的时候可以使用默认值

  ```js
  let [a = 'a', b = 'b', c = new Error('c必须指定')] = [1,,3]
  function ajax(opt){
      var method = opt.method || 'get'
      var data = opt.data || {}
      //...
  }
  ```

#### 字符串

- 模板字符串

  模板字符串用反引号包含，变量用${}括起来

  ```js
  //模板字符串原理
  function repalce(desc){
      desc.replace(/\$\{([^}]+)\}/g,fucntion(matched,key){
                   return eval(key)
                   })
  }
  ```

- 带标签的模板字符串

  ```js
  let str = desc`${name}今年${age}岁了`
  带标签的模板字符串类似函数调用 参数1是文本的数组2
  function desc(strings,name,age){
      //strings = ['','今年'，'岁了','']
  }
  ```

- 字符串新方法

  - includes() 返回布尔值表示是否找到字符串

  - startwith()返回布尔值表示字符串是否在源字符串的头部

  - endsWith()返回布尔值表示字符串是否在源字符串的尾部

    第二个参数表示开始搜索时的位置 endsWitth针对前n个字符，其他两个方法针对从第n个位置到字符串结束

- repeat

  repeat()返回一个新字符串表示将原字符串重复n次

#### 函数

1. 默认参数

   ```js
   function ajax(url = new Error('url不能为空'),method = 'get',dataType = 'json'){
       
   }
   ```

   - 必填项不填报错
   - 有些参数没有传参时可以有默认值

2. 展开操作符号

   把`...`放数组前可以把一个数组展开，可以把一个数组直接传入函数而不需使用apply

   ```js
   //传入参数
   let print = function(a,b,c){
       console.log(a,b,c)
   }
   print([1,2,3])
   print(...[1,2,3])
   //替代apply
   var m1 = Math.max.apply(null,[8,9,4,1])
   var m2 = Math.max(...[8,9,4,1])
   //替代concat
   var arr1 = [1,3]
   var arr2 = [3,4]
   var arr3 = arr1.concat(arr3)
   var arr4 = [...arr1,...arr2]
   //类数组转数组
   function max(a,b,c){
       console.log(Math.max(...arguments))
   }
   max(1,2,3)
   //代替assgn复制对象
   Object.assign(obj3,obj1,obj2)
   obj3 = {...obj1, ...obj2}
   ```

3. 剩余操作符

   剩余操作符可以把其余的参数的值都放到一个数组里

   ```js
   let rest = function(1,...rest){
       console.log(a.rest)
   }
   rest(1,2,3)
   ```

   > 对象深拷贝
   >
   > ```js
   > function clone(origin){
   >     let newObj = {}
   >     for( let key in origin){
   >         if(typeof origin[key] == 'object'){
   >             newObj[key] = clone(origin[key])
   >         }else{
   >             newObj[key] = origin[key]
   >         }
   >     }
   >     return newObj
   > }
   > ```
   >
   > 

4. 解构参数

   ```js
   let destruct = fuction({name,age}){
       console.log(name,age)
   }
   destrust({name:'test',age:'8'})
   ```

5. 函数的名字

   ```js
   //es6给函数添加一个name属性
   var desc = function descname(){
       cobsole.log desc.name
   }
   ```

6. 箭头函数

   - 声明函数的简单实现

   - 如果只有一个参数可以省略() 只有返回值时可以省略{}
   - 箭头函数没有自己的this 内部this会指向外层this

7. 数组新方法

   - from 把类数组转数组

   -  Array.of

   - copyWithin

   - find

     ```js
     Array.prototype.find = function(fn){
         for(let i = 0; i < this.length; i++){
             fn(this[i]) && return this[i]
         }
     }
     ```

   - some

   - findIndex

   - every

   - fill 用指定元素填充数组

   - filter 返回true保留元素 返回false删除元素

     ```js
     //filter原理
     Array.prototype.filter = function (fn){
         let newArr = []
         for(let i = 0; i < this.length; i++){
             let flag = fn(this[i])
             flag &&  newArr.push(this[i])
         }
         return newArr
     }
     ```

   - map

   - forEach

   - reduce 把一个数组中的一堆值计算出一个值

     reduce(function(val,item,index,origin){},初始值)

     - 可以传一个参数也可以传两个参数 第二个参数为初始值
     - 上一次的执行结果会成为下一次的初始值
     - 如果没有初始值时 第一次执行函数时val=第一个元素 item=第二个元素
     - reduce从左往右算

     ```js
     Array.prototype.reduce = function(reducer,initialval){
         for(let i = 0; i < this.length; i++){
             initialVal = reducer(intialVal,this[i])
             return initialVal
         }
     }
     ```

#### 对象

1. 对象字面量

   对象属性名和变量名一样时可以省略

   ```js
   let name = 'test', age = 8;
   let person = {name,age}
   ```

2. Object.is

   比较两对象是否相等 `console.log(Object.is(NaN,NaN))`

3. Object.assign

   把多个对象的属性复制到一个对象中，第一个参数是复制的对象，从第二个参数开始后都是复制的源对象

4. Object.setPrototypeOf 设置对象的指定原型

   ```js
   Object.setPrototypeOf(obj3,obj1)
   //等同于
   obj3.__proto__ = obj1
   ```

5. proto

6. super

   通过super可以调用父类的方法

   ```js
   let obj1 = { age;1, getFood(){
       return '面包'
   }}
   let obj2 = {
       __proto__:obj1,
       getFoof(){
           return '牛奶'+super.getFood()
       }
   }
   ```

#### 类

1. class

   定义一个class 

   类中可以定义构造函数 当创造一个类的实例时就会调用构造函数

   ```js
   class Parent{
       constructor(name){
           //实例的私有属性
           this.name = name
       }
       getName(){
           //实例的公有属性=原型上的属性
       }
   }
   ```

2. get与set

   get获取属性 set设置属性

   ```js
   class Person {
       constructor(){
           this.hobies = []
       }
       set hobby(hobby){
           this.hobies.push(hobby)
       }
       get hobby(){
           return this.hobiesccc
       }
   }
   ```

3. static

4. extends

   ```js
   class Child extends Parent{
       constuctor(name,age){
           //super为父类的构造函数
           super(name)
           this.age = age
       }
   }
   ```

   

####生成器Generator与迭代器Iterator

Generator是一个特殊的函数，执行它会返回一个Iterator对象。通过便利迭代器，Generator函数运行后返回一个遍历器对象而不少普通函数的返回值。

koa的基础

1. Iterators模拟

   迭代器有一个next方法，每次执行的时候都会返回一个对象，对象里有两个属性value表示返回值，布尔值done表示是否迭代完成。

   ```js
   function buy(books){
       let i = 0;
       return {
           next(){
               let done = i == books.length //done=length时迭代完毕
               let value = !done ? books[i++] : undefined
               return{
                   value:value
                   done:done
               }
           }
       }
   }
   let iterators = buy['js','html']
   var curr
   do{
       curr = iterator.next()
       console.log(curr)
   }while(!curr.done)
   ```

2. Generator

   生成器用于创建迭代器

   ```js
   function *buy(books){
       for(var i = 0; i < books.length; i++){
           yield books[i]
       }
   }
   let buying = buy(['js','html'])
   var curr
   do{
       curr = buying.next()
       console.log(curr)
   }while(!curr.done)
   ```

#### 集合

1. set

   set是一堆东西的集合 类似数组但是set中不能有重复的东西

   ```js
   var books = new Set()
   books.add('js')
   books.add('js') //添加重复元素集合的元素个数不会改变
   books.add('html')
   books.foreach(function(book){
       console.log(book)
   })
   console.log(books.size) //集合元素的个数
   console.log(books.has('js')) //判断集合中是否有该元素
   books.delete('js') //从集合中删除元素
   books.clear() //清空集合
   ```

2. map

   可以使用Map来组织名值对的数据

   ```js
   var books = new Map()
   books.set('js',{name:'js'}) //向map中添加元素
   console.log(books.size) //查看集合中的元素
   console.log(books.get('js')) //通过key获取值
   books.delete('js') //用key删除元素
   console.log(books.has('js')) //判断map中有没有key
   books.foreach((value,key) => { //foreach可以迭代map
       console.log(key + '=' + value)
   })
   books.clear() //清空map
   ```

####模块

可以根据应用的需求把代码分成不同的模块，每个模块里可以导出它需要让其他模块使用的东西，在其他模块里面可以导入这些模块导出的对象。

1. 模块
2. 重命名
3. 默认导出

#### Promise

######异步回调问题

- 回调地狱 执行多个操作时会导致多个回调函数嵌套
- 并行结果 没有前后顺序等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间

######promise简单实现

```js
function Promise(task){
    let that = this
    //默认状态为pending
    that.status = 'pending'
    //存放promise的结果
    that.value = undefined
    //存放所有成功的回调函数
    that.onresolvedCallbacks = []
    //存放所有失败回调
    that.onRejectedCallbacks = []
    //调用后可把promise转为成功态
    function resolve(value){
        if( that.status == 'pending'){
            that.status = 'fulfilled'
            that.value = value
            that.onresolvedCallbacks.forEach((item => item(value)))
        }
    }
    //调用后可把promise转为失败态
    function reject(reason){
        if( that.status == 'pending'){
            that.status = 'rejected'
            that.value = reason
            that.onRejectedCallbacks.forEach(item => item(reason))
        }
    }
    //实例化时立即执行
    try{
        task(resolve,reject)
    }catch(e){
        reject(e)
    }
}
//onFulfilled成功的回调 onRejevt失败的回调
promise.prototype.then = function(onFulfilled,onReject){
    let that = this
    if(that.status == 'fulfilled'){
        onFulfilled(that.value)
    }
    if(that.status == 'rejected'){
        onReject(that.value)
    }
    if(that.status == 'pending'){
        that.onResolvedCallbacks.push(onFulfilled)
    	that.onRejectedCallbacks.push(onReject)
    }
}
Promise.prototype.catch = function(onRejected){
    return this.then(null,onRejected)
}
Promise.all = function(promises){
    return new Promise(function(resolve,reject){
        let result = []
        let count = 0
        for(let i = 0;i<promises.length; i++){
            promises[i].then(function(data){
                result[i] = data
                if(++count == promises.length){
                    resolve(result)
                }
            },reject)
        }
    })
}
promise.race = function(promises){
    return new Promise(function(resolve,reject){
        for(let i =0; i<promises.length,i++){
            promises[i].then(resolve,reject)
        }
    })
}
Promise.deffered = Promise.defer = function (){
    var defer = {}
    defer.promise = new Promise(function(resolve,reject){
        defer.resolve = resolve
        defer.reject = reject
    })
    return defer
}

/**
测试用例
npm i -g promise-aplus-tests
promises-aplus-tests Promise.js
*/
module.exports = Promise
```

######promise解析

成功的回调里返回了一个promise 那promise2要以promise的resolve结果来resolve自己

**promise解析过程 **以一个promise和一个值作为参数的抽象过程

`[[Resolve]](promise,x)`

```js
function Promise(task){
    let that = this
    //默认状态为pending
    that.status = 'pending'
    //存放promise的结果
    that.value = undefined
    //存放所有成功的回调函数
    that.onresolvedCallbacks = []
    //存放所有失败回调
    that.onRejectedCallbacks = []
    //调用后可把promise转为成功态
    function resolve(value){
        if( that.status == 'pending'){
            that.status = 'fulfilled'
            that.value = value
            that.onresolvedCallbacks.forEach((item => item(value)))
        }
    }
    //调用后可把promise转为失败态
    function reject(reason){
        if( that.status == 'pending'){
            that.status = 'rejected'
            that.value = reason
            that.onRejectedCallbacks.forEach(item => item(reason))
        }
    }
    //实例化时立即执行
    try{
        task(resolve,reject)
    }catch(e){
        reject(e)
    }
}
function resolvePromise(promise2,x,resolve,reject){
    //如果x就是promise2 死循环报错
    let then
    if(promise2 === x){
        return reject(new TypwError('循环引用'))
    }
    if(x instanceof Promise){
        if( x.status == 'pending'){
            x.then(function(y){
                resolvePromise(promise2,y,resolve,reject)
            },reject)
        }else if(x.status == 'fulfilled'){
            resolve(x.value)
        }else if(x.status == 'rejected'){
            reject(x.value)
        }
    }else if(x != null && (typeof x == 'object' || typeof x == 'function') ){
        try{
           then = x.then
            if(typeof then == 'function'){
                then.call(x,function(y){
                    resolvePromise(promise2,y,resolve,reject)
                },reject)
            }
        }catch(e){
            reject(e)
        }
    }else{
        resolve(x)
    }
}
//onFulfilled成功的回调 onRejevt失败的回调
promise.prototype.then = function(onFulfilled,onReject){
    onFulfilled = typeof onFulfilled == 'function'?onFullfilled : function(value){return value}
    onReject = typeof onReject == 'function'? onReject : function(reason){throw reason}
    let that = this
    let promise2
    if(that.status == 'fulfilled'){
        promise2 = new Promise(function(resolve,reject){
            let x =  onFulfilled(that.value)
            resolvePromise(promise2,x,resolve,reject)
        })
    }
    if(that.status == 'rejected'){
        promise2 = new promise(function(resolve,reject){
            let x = onReject(that.value) 
            resolvePromise(promise2,x,resolve,reject)
        })
    }
    if(that.status == 'pending'){
          promise2 = new promise(function(resolve,reject){
           that.onResolvedCallbacks.push(function(){
               let x = onFulfilled(that.value)
            resolvePromise(promise2,x,resolve,reject)
               })
    		that.onRejectedCallbacks.push(function(){
                let x = onReject(that.value)
            resolvePromise(promise2,x,resolve,reject)
                })
        })
    }
}
module.exports = Promise
```

######	q	

Q是在js中实现promise的模块

```
//基本用法
var Q = require('q')
var fs = require('fs')
fuction read(filename){
	var deferred = Q.defer()
	fs.readFile(filename,'utf8',function(err,data){
		if(err){
			deferred.reject(err)
		}else{
			deferred.resolve(data)
		}
	})
	return deferred.promise
}
read('1.txt').then(function(data){
	console.log(data)
},function(error){
	console.error(error)
})
```

```js
//q的简单实现
let Q = {
    defer(){
        let success,error;
        return{
            resolve(data){
                success(data)
            },
            reject(err){
                error(err)
            },
            promise:{
            	then(onFulfilled,onRejected){
                    success = onFulfilled
                    error = onRejected
                }
        	}
        }
    }
}
```

###### bluebrid

实现promise标准的库 功能最全速度最快

```js
//使用
var Promise = require('/bluebird')
var readFile = Promise.promisify(require('fs').readFile)
readFile('1.txt','utf8').then(function(contents){
    console.log(contents)
})
var fs = Promise.promisifyAll(require('fs'))
fs.readFileAsync('1.txt','uft8').then(function(contents){
    console.log(contents)
})
//简单实现
function promisifyAll(obj){
    //遍历对象上所有方法给每个方法添加一个新的方法Async
    for(let key in obj){
        if(obj.hasOwnProperty(key) && typeof obj[key] == 'function'){
            obj[key+'Async'] = Promise.promisify(obj[key])
        }
    }
}
```

## 异步

#### 异步

异步就是一个任务分成两段，先执行第一段然后转而执行其他任务，等做好了准备在回来执行第一段，这种不连续的执行就叫做异步。连续的执行叫做同步。

#### 高阶函数

函数作为一等公民可以作为参数和返回值

- 可以用于批量生成函数（函数作为返回值）

  ```js
  let toString = Object.prototype.toSting
  let isString = function(obj){
      return toSting.call(obj) == '[object String]'
  }
  let isFunction = function(obj){
      return toString.call(obj) == '[object Function]'
  }
  let isType = function(type){
      return function(obj){
          return toString.call(obj) == `[object ${type}]`
      }
  }
  ```

- 可以用于需要多次调用才执行的函数（函数作为参数）

  ```js
  //lodash中after方法 指定一个函数被调用多少次才会真正执行
  let after = function(times,task){
      return function(){
          if(times-- ==1){//或者count = 0 ++count ==times
              return task.apply(this.argument)
          }
      }
  }
  let fn = after(3,function(){
      console.log(3)
  })
  fn()
  ```

#### 异步的语法目标

异步的语法目标是**让他更像同步编程**

- 回调函数实现
- 事件监听
- 发布订阅
- Promise/A+和生成器函数
- Async/await

#### 回调实现异步

回调函数就是把任务的第二段单独写在一个函数里面等到重新执行这个任务的时候就直接调用这个函数。

```js
fs.readfile('某个文件'，function(err,data){
    if(err) throw err
    console.log(data)
})
//回调的特点是error first 第一个参数永远是错误对象
```

#### 回调的问题

- 异常处理

  ```js
  try{xxx}catch(e){xxx}
  ```

  异步代码时trycatch不再生效

  ```js
  let async = function (callback){
      try{
          setTimeout(function(){
              callback()
          },1000)
      }catch(e){
          console.log('捕获错误'，e)
      }
  }
  async(function(){
      console.log(t)
  })
  ```

  这个回调函数被存放起来知道下一个事件环的时候才会取出，try只能捕获当前循环内的异常，对callback无能为力

  Node在处理异常时有个约定**将异常作为回调的第一个实参传回如果为空表示没有出错**

  ```js
  async(function(err,callback){
      if(err){
          console.log(err)
      }
  })
  ```

  异步方法也要遵循两个原则

  - 必须在异步之后调用传入的回调函数
  - 出错了要向回调函数传入异常供调用者判断

- 回调地狱

  - 难以阅读
  - 难以维护
  - 效率比较低 串行执行

  ```js
  //访问服务器时 eg:请求HTML页面 服务器一方面读取模板文件另一方面要读取数据 两种操作都很慢所以异步
  fs.readFile('./template.txt','utf8',function(err,template){
    fs.readFile('./data.txt','utf8',function(err,data){
          console.log(template + ' ' + data)
      })
  })
  ```

#### 异步流程解决方案

1. 事件订阅发布模型

   ```js
   //订阅事件实现了一个事件与多个函数的关联
   let fs = require('fs')
   let EventEmitter = require('event')
   let eve = new EventEmitter()
   let html = {} //存放最终数据
   eve.on('ready',function(key,value){//监听数据 获取·成功事件 当事件发生之后调用回调函数
       html[key] = value
       if(Object.keys(html).length == 2){
           //Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性
           console.log(html)
       }
   })
   function render(){
     fs.readFile('template.txt','utf8',function(err,template){
           //发射事件 1.事件名2.传递给回掉函数的参数
           eve.emit('ready','template',template)
       })
     fs.readFile('data.txt','utf8',function(err,template){
           eve.emit('ready','data',data)
       })
   }
   render()
   ```

2. 哨兵函数

   ```js
   let fs = require('fs')
   let after = function(times,callback){
       let result = {}
       return function(key,value){
           result[key] = value
           if(Object.key(result).length == times){
               callback(result)
           }
       }
   }
   let done = after(2,function(result){
       console.log(result)
   })
   function render(){
     fs.readFile('template.txt','utf8',function(err,template){
           done('template',template)
       })
   }
   render()
   ```

3. Promise/Deferred模式

   ```js
   const PENDING = 'pending' //初始态
   const FULFILLED = 'fulfilled' //成功态
   const REJECTED = 'rejected' //失败态
   function promise(executor){
       let self = this //缓存当前promise实例
       self.status = PENDING //设置状态
       //定义存放成功回调数组
       self.onResolvedCallbacks = []
       //定义存放失败回调数组
       self.onRejectedCallbacks = []
       function resolve(value){//调用时promise状态为pending将状态转为成功态 其他状态不改变
           if(value instanceof Promise){
               return value.then(resolve,reject)
           }
           if(self.status == PENDING){
               self.status = FULFILLED
               self.value = value //成功后会得到一个值这个值不能改
               //调用成功以后的回调
               self.onResolvedCallbacks.forEach(cb => cb(self.value))
           }
       }
       function reject(reason){//调用时promise状态为pending将状态转为失败态 其他状态不改变
           if(self.status == PENDING){
               self.status = REJECTED
               self.value = reason //失败后会得到一个值这个值不能改
               //调用失败以后的回调
               self.onRejectedCallbacks.forEach(cb => cb(self.value))
           }
       }
       try{
           //此函数执行是可以会异常需要捕获，出错了需要reject
           executor(resolve,reject)
       }catch(e){
           reject(e)
       }
   }
   function resolvePromise(promise2,x,resolve,reject){
       if(promise2 === x){
           return reject(new TypeError('循环引用'))
       }
       let called = false //promise2是否resolve或reject
       /*if(x instanceof Promise){
           if(x.status == 'pending'){
               x.then(function(y){
                   resolvePromise(promise2,y,resolve,reject)
               },reject)
           }else{
               x.then(resolve,reject)
           }
       }else */if(x!=null && ((typeof x == 'object')||(typeof x == 'function') )){ //x是thenable对象，只要有then方法的对象
           try{
               let then = x.then
               if(typeof then == 'function'){
                   //promise与别人的promise交互考虑兼容性
                   then.call(x,function(y){
                      if (called)return
                       called = true
                    //如果promise2成功或失败则不会处理
                       resolvePromise(promise2,y,resolve,reject)
                   },function(err){
                       if (called)return
                       called = true
                       reject(err)
                   })
               }else{
                   //x不是thenable对象之间把它当成值resolve
                   resolve(x)
               }
           }catch(e){
               reject(e)
           }
       }else{//x值为普通值 用x的值resolve promise2
           resolve(x)
       }
   }
   //用来接收promise成功的值或者失败的原因
   Promise.prototype.then = function (onFulfilled,onRejected){
       //成功失败回调没有传 则表示这个then没有逻辑直接返回值
       onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : value => value
       onRejected = typeof onRejected == 'function' ?onRejected : reason => {throw reason}
       let self = this
       let promise2
       if(self.status == FULFILLED){
           return promise2 = new Promise(function(resolve,reject){
               setTimeout(function(){
                    try{
                 		let x = onFulfilled(self.value)
              		//如果获得了返回值x会走解析promise的过程
                 		resolvePromise(promise2,x,resolve,reject)
             		 }catch(e){
                   	reject(e)
            		 }
               })
           })
           
       }
       if(self.status == REJECTED){
           return promise2 = new Promise(function(resolve,reject){
               setTimeout(function(){
                  try{
                      let x = onRejected(self.value)
            	 	//如果获得了返回值x会走解析promise的过程
             			resolvePromise(promise2,x,resolve,reject)
                  }catch(e){
                       reject(e)
                  }
               })
           })
       }
        if(self.status == PENDING){
            return promise2 = new Promise(function(resolve,reject){
                self.onResolvedCallbacks.push(function(){
                setTimeout(function(){
                    try{
                        let x = onFulfilled(self.value)
               		 resolvePromise(promise2,x,resolve,reject)
                    }catch(e){
                        reject(e)
                    }
                	})
          		 })
           	self.onRejectedCallbacks.push(function(){
             	  setTimeout(function(){
               	    try{
               	        let x = onRejected(self.value)
              				resolvePromise(promise2,x,resolve,reject)
                	   }catch(e){
                	       reject(e)
                	   }
              	 })
          	 })   
          })
       }
   }
   ```

4. 生成器Generators/yield

   - 执行一个函数时可以在某个点暂停函数执行并做其他工作，然后返回这个函数继续执行甚至携带新的值继续执行
   - 当我们调用一个生成器函数时并不会立即执行而是需要我们手动去执行迭代操作。调用生成器函数会返回一个迭代器，迭代器会遍历每个终端点

   生成器的使用

   ```js
   function *foo(){
       var index = 0
       while(index<2){
           yield index++ //暂停函数执行并执行yield后的操作
       }
   }
   var bar = foo()
   bar.next()
   ```

   co

   co是一个node和浏览器打造的基于生成器的流程控制工具，借助于promise，编写非阻塞代码
   
   ```js
   let fs = require('fs')
   function readFile(filename){
       return new Promise(function(resolve,reject){
           fs.readFile(filename,function(err,data){
               if(err){
                   reject(err)
               }else{
                   resolve(data)
               }
           })
       })
   }
   function *read(){
       let template = yield readFile('./template.txt')
       let data = yield readFile('./data.txt')
       return template + '+' +data
   }
   co(read).then(function(data){
       console.log(data)
   },function(err){
       console.log(err)
   })
   
   function co(gen){
       let it = gen()
       return new Promise(function(resolve,reject){
           !function next(lastVal){
               let {value,done} = it.next(lastVal)
               if(done){
                   resolve(value)
               }else{
                   value.then(next,reason => reject(reason))
               }
           }()
       })
   }
   ```

#### Async/await

- async的优点

  - 内置执行器
  - 更好地语义
  - 更广的适用性

  ```js
  let fs = require('fs')
  function readFile(filename){
      return new Promise(fucntion(resolve,reject){
                         fs.readFile(filename,'utf8',function(err,data){
          if(err){
              reject(err)
          }else{
              resolve(data)
          }
      })
  }
  async function read(){
      let template = await readFile('./template.txt')
      let data = await readFile('./data.txt')
      return template + '+' + data
  }
  let result = read()
  result.then(data => console.log(data))
  ```

- async函数的实现

  async函数的实现就是将Generator函数和自动执行器包装在一个函数里

  ```js
  async function read(){
      let template = await readFile('./template.txt')
      let data = await readFile('./data.txt')
      return template + '+' + data
  }
  ```


## 前端工程化

#### 前端监控







#### 自动化测试

vue test utils是vue官方的单元测试工具

```js
test('字符串和数字相加',()=>{
    expect(add(1,'2')).toBe(3)
})
```



## js算法

#### 复杂度计算

- 时间复杂度 用O表示 eg:O(1)、O(n)、O(logN)

  ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\时间复杂度.png)

  - 定性描述算法运行时间
  - 加法计算为O(1)、for循环为O(n) 、双循环为O(n*n)

- 空间复杂度 用O表示 eg:O(1)、O(n)、O(n^2)

  - 算法在运行过程中临时占用存储空间大小的量度

#### 栈

1. 介绍

   - 一个后进先出的数据结构

   - 栈包含push入栈 pop出栈

     ```js
     const stack = []
     //入栈
     stack.push(1)
     stack.push(2)
     //出栈
     const item1 = stack.pop()
     const item2 = stack.pop()
     ```

   - js没有栈但是可以用Array实现栈的功能

2. 使用场景

   需要后进先出的场景

   - 十进制转二进制

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\十进制.png)

     把余数依次入栈然后出栈来实现余数倒叙输出

   - 判断字符串的括号是否有效

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\括号.png)

     越靠后的左括号对应的有括号越靠前

     左括号入栈又括号出栈，栈空了即合法

     [leetcode20：判断有效括号](https://leetcode-cn.com/problems/valid-parentheses/)

     解题思路：

     - 对于未闭合的坐括号而言，越靠后的左括号对应的右括号越靠前
     - 满足后进先出，考虑用栈

     解题步骤：

     - 新建栈
     - 扫描字符串，遇到左括号入栈，遇到和栈顶括号(数组最后一位，最后一个入栈的括号)类型匹配的右括号出栈，类型不匹配为不合法
     - 最后栈空了合法否则不合法

     ```js
     //判断有效括号 时间复杂度O(n) 空间复杂度O(n)
     let isValid = function(s){
         if(s.length % 2 === 1) return false
         const stack = []
         for(let i = 0; i < s.length; i++){
             const c = s[i]
             if(c === '{' || c === '(' || c === '['){
                 stack.push(c)
             }else{
                 const t = stack[stack.length - 1]
                 if((t === '(' && c === ')') || (t === '{' && t === '}') || (t === '[' && c === ']')){
                     stack.pop()
                 }else{
                     return false
                 }
             }
         }
         return stack.length === 0
     }
     ```

   - 函数调用堆栈

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\函数.png)

     最后调用的函数最先执行完

     js解释器用栈来控制函数的调用顺序

#### 队列

1. 介绍

   - 一个先进先出的数据结构

   - 队列的操作包括enqueue入队 dequeue出队

     ```js
     const queue = []
     //入队
     queue.push(1)
     queue.push(2)
     //出队
     const item1 = queue.shift()
     const item2 = queue.shifr()
     ```

   - js没有队列但可以使用Array实现队列的所有功能

2. 使用场景

   需要先进先出的场景

   - 食堂排队打饭

   - js异步的任务队列

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\事件队列.png)

   - 计算最近请求次数

     [leetcood933:最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

     解题思路：

     - 越早发出的请求越早不在最近的3000ms内的请求里
     - 满足先进先出，使用队列

     解题步骤：

     - 有新请求就入队，3000ms发出的请求出队
     - 队列的长度就是最近请求次数

     ```js
     //事件复杂度O(n) 空间复杂度O(n)
     let RencentCounter = function(){
         this.q = []
     }
     RencentCounter.prototype.ping = function(t){
         this.q.push(t)
         while(this.q(0) < t - 3000){
             this.q.shift()
         }
         return this.q.length
     }
     ```

#### 链表

1. 介绍

   - 多个元素组成的列表，元素存储不连续，用next指针连接
   - js中没有链表，可以使用object模拟链表

   >数组与链表的区别
   >
   >- 数组：增删非首尾元素时需要移动元素
   >- 链表：增删非首尾元素，不需要移动元素，只需要更改next指向

   ```js
   const a = {val:'a'}
   const b = {val:'b'}
   const c = {val:'c'}
   const d = {val:'d'}
   a.next = b
   b.next = c
   c.next = d
   //遍历链表
   let p = a
   while(p){
       console.log(p.val)
       p = p.next
   }
   //插入链表
   let e = {val:'e'}
   c.next = e
   e.next = d
   //删除
   c.next = d
   ```

2. 使用场景

   - [leetcood237：删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

     解题思路：

     - 无法直接获取被删除节点的上个节点
     - 将被删除节点转移到下个节点

     解题步骤：

     - 将被删节点的值改为下个节点
     - 删除下个节点

     ```js
     //时间复杂度O(1)空间复杂度O(1)
     let deleteNode = function(node){
         node.val = node.next.val
         node.next = node.next.next
     }
     ```

   - [leetcode206：反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

     解题思路：

     - 反转两个节点，将n+1的next指向n
     - 反转多个节点，双指针遍历链表重复

     解题步骤：

     - 双指针一前一后遍历链表
     - 反转双指针

     ```js
     //时间复杂度 O(n) 空间复杂度O(1)
     let reverseList = function(head){
         let p1 = head
         let p2 = null
         while(p1){
             const tmp = p1.next
             p1.next = p2
             p2 = p1
             p1 = tmp
         }
         return p2
     }
     ```

   - [leetcode2：两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

     解题思路：

     - 模拟相加操作
     - 需要遍历链表

     解题步骤：

     - 新建空链表
     - 遍历被相加的两个链表，模拟相加操作，将个位数追加到新链表上，将十位数留到下一位相加

     ```js
     //时间复杂度O(n) 空间复杂度 O(n)
     let addTwoNumbers = function(l1,l2){
         const l3 = new ListNode(0)
         let p1 = l1
         let p2 = l2
         let p3 = l3
         let carry = 0
         while(p1 || p2){
             const v1 = p1 ? p1.val : 0
             const v2 = p2 ? p2.val : 0
             const val = v1 + v2 + carry 
             carry = Math.floor(val / 10)
             if(p1) p1 = p1.next
             if(p2) p2 = p2.next
             p3.next = new ListNode(val % 10)
             p3 = p3.next
         }
         if(carry) p3.next = new ListNode(carry)
         return l3.next
     }
     ```
   ```
     
   ```
- [leetcood83:删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
  
  解题思路：
  
     - 有序链表重复元素相邻
  - 遍历链表，当前元素和下个元素相同就删除下个元素
  
  解题步骤：
  
     - 遍历链表，当前元素和下个元素相同就删除下个元素
  - 返回链表头
  
     ```js
     //时间复杂度O(n) 空间复杂度O(1)
     var deleteDuplicates = function(head){
         let p = head
         while(p && p.next){
             if(p1.val === p1.next.val){
                 p.next = p.next.next
             }else{
                 p = p.next
             }
         }
         return head
     }
     ```
```
   
- [leetcode141:环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
   
  解题思路：
   
     - 在圆形操场起点同时起跑，速度快的人一定会超过速度慢的人一圈
  - 用一快一慢两个指针遍历链表如果指针能相逢，那链表就有圈
   
  解题步骤：
   
     - 用一快一慢两个指针遍历链表，如果指针能相逢，就返回true
  - 遍历结束后没有相逢返回false
   
     ```js
     //时间复杂度o(n) 空间复杂度o(1)
     var hasCycle = function(head){
         let p1 = head
         let p2 = head
         while(p1 && p2 && p2.next){
             p1 = p1.next
             p2 = p2.next.next
             if(p1 == p2){
                 return true
             }
         }
         return  false
     }
```

- 原型链
  
     - a沿着原型链能找到b.prototype那`a instanceof b == true`
  - 在a对象上没有找到x属性，会沿着原型链找到x属性
  
     ```js
     //instanceof 原理
     let instanceof = (a,b) => {
         let p = a
         while(p){
             if(p == b.prototype){
                 return true
             }
             p = p._proto_
         }
         return false
     }
     ```
  ```
  
  ```
  
- 使用链表指针获取json数据节点值
  
     ```js
     //test
     const json = {
         a:{b:{c:1}},
         d:{e:2}
     }
     const path = ['a','b','c']
     let p = json
     path.forEach(k=>{
         p = p[k]
     })
     ```

#### 集合

1. 介绍

   - 一种无序且唯一的数据结构
   - ES6有集合Set

   ```js
   const arr = [1,1,2,2]
   //去重
   const arr2 = [...new Set(arr)]
   //判断元素是否在集合中
   const set = new Set(arr)
   const has = set.has(3)
   //求交集
   const set2 = new Set([2,3])
   const set3 = new Set([...set].filter(item=>set2.has(item)))
   
   ```

2. 使用场景

   - [leetcode349:两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

     解题思路：

     - 求交集且无序唯一
     - 使用集合

     解题步骤：

     - 使用集合对num1去重
     - 遍历num1筛选出num2也包含的值

     ```js
     //时间复杂度o(m*n) 空间复杂度o(m)
     let intersection = function(nums1,nums2){
         return [...new Set(nums1).filter(item=>nums2.includes(item))]
     }
     ```

#### 字典

1. 介绍

   - 存储唯一值的数据结构，以键值对形式 存储，与集合类似
   - es6中字典为Map

   ```js
   const m = new Map()
   //增
   m.set('a','aa')
   m.set('b','bb')
   //删
   m.delete('b')
   m.clear()
   //改
   m.set('a','aaa')
   //查
   m.get('a')
   ```

2. 使用场景

   - [leetcode349:两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

     解题思路：

     - 求nums1和nums2都有的值
     - 用字典建立一个映射关系，记录nums1里有的值
     - 遍历nums2，找出nums1里也有的值

     解题步骤：

     - 新建字典，遍历nums1填充字典
     - 遍历nums2遇到字典里的值就选出并从字典中删除

     ```js
     //时间复杂度O(m+n) 空间复杂度o(m)
     let intersection = function(nums1,nums2){
         const map = new Map()
         nums1.forEach(n=>{
             map.set(n,true)
         })
         const res = []
         nums2.forEach(n=>{
             if(map.get(n)){
                 res.push(n)
                 map.delete(n)
             }
         })
         return res
     }
     ```

   - [leetcode20:有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

     ```js
     //时间复杂度O(n)空间复杂度O(n)
     let isValid = function(s){
         if(s.length%2 === 1) return false
         const stack = []
         const map = new Map()
         map.set('(',')')
         map.set('{','}')
         map.set('[',']')
         for(let i =0; i<s.length; i++){
             let c = s[i]
             if(map.has(c)){
                 stack.push(c)
             }else{
                 let t = stack[stack.length-1]
                 if(map.get(t) === c){
                     stack.pop()
                 }else{
                     return false
                 }
             }
         }
         return stack.length === 0
     }
     ```

   - [leetcode1:两数之和](https://leetcode-cn.com/problems/two-sum/)

     解题思路：

     - nums为相亲者 target为匹配条件
     - 用字典建立一个婚姻介绍所存储相亲者的数字和下标

     解题步骤：

     - 新建字典作为婚姻介绍所
     - nums里的值逐个介绍匹配，没有合适的就先记录，合适就成功

     ```js
     //时间复杂度o(n) 空间复杂度o(n)
     let twoSum = function(nums,target){
         const map = new Map()
         for(let i = 0; i < nums.length; i++){
             const n = nums[i]
             const n2 = target - n
             if(map.has(n2)){
                 return [map.get(n2),i]
             }else{
                 map.set(n,i)
             }
         }
     }
     ```

   - [leetcode3:无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

     解题思路：

     - 找出所有不包含重复字符的子串
     - 找出长度最大的子串返回其长度

     解题步骤：

     - 使用双指针维护一个滑动窗口用来剪切子串
     - 不断移动右指针，遇到重复字符就把左指针移动到重复字符的下一位
     - 记录所有窗口的长度 并返回最大值

     ```js
     //时间复杂度O(n)空间复杂度O(m)
     let lengthOfLongestSubstring = function(s){
         let l = 0
         let res = 0
         const map = new Map()
         for(let r = 0; r < s.length; r++){
             if(map.has(s[r]) && map.get(s[r]) >= l){
                 l = map.get(s[r])+1
             }
             res = Math.max(res,r-l+1)
             map.set(s[r],r)
             
         }
         return res
     }
     ```

   - [leetcode76：最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

     解题思路：

     - 找出所有包含T都子串
     - 找出长度最小子串返回
     
     解题步骤：
     
     - 用双指针维护一个滑动窗口
     - 移动右指针找到包含T的子串，移动左指针减少包含T的子串长度
     
     ```js
     //时间复杂度o(m+n) 空间复杂度度O(m)
     let minWindow = function(s,t){
         let l = 0, r = 0;
         const need = new Map()
         for(let c of t){
             need.set(c,need.has(c)?need.get(c)+1:1)
         }
         let needType = need.size
         let res = ''
         while(r<s.length){
             const c = s[r]
             if(need.has(c)){
                 need.set(c,need.get(c)-1)
                 if(need.get(c)===0) needType -= 1
             }
             while(needType === 0){
                 const newRes = s.substring(l,r+1)
                 if(!res || newRes.length < res.length) res = newRes
                 const c2 = s[l]
                 if(need.has(c2)){
                     need.set(c2,need.get(c2)+1)
                     if(need.get(c2)===1) needType +=1
                 }
                 l += 1
             }
             r+=1  
         }
         return res
     }
     ```

#### 树

1. 介绍

   - 一种分层数据的抽象模型
   - 前端中树包括DOM树、级联选择、树形控件
   - js中没有树，但是可以使用Object和Array构建树

   **树的遍历**

   - 深度优先 尽可能深的探索树的分支

     <img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\深度优先.png" style="zoom:50%;" />

     - 访问根节点
     - 对根节点的children挨个深度优先遍历

     ```js
     const stree = {
         val:'a',
         children:[
             {
                 val:'b',
                 children:[
                     {
                         val:'d',
                         children:''
                     },
                     {
                         val:'e',
                         children:''
                     }
                 ]
             },
             {
                 val:'c',
                 children:[
                     {
                         val:'f',
                         children:''
                     },
                     {
                         val:'g',
                         children:''
                     }
                 ]
             }
         ]
     }
     const dfs = (root) =>{
         //1.访问根节点
         console.log(root.val)
         //2.对children深度优先遍历
         //root.children.forEach((child)=>{dfs(child)})
         root.children.forEach(dfs)
     }
     ```

   - 广度优先 先访问离根节点最近的节点

     <img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\广度优先.png" style="zoom:50%;" />

     - 新建一个队列，把根节点入队
     - 把队头出队并访问
     - 把队头的children挨个入队
     - 重复23步直到队列为空

     ```js
     const stree = {
         val:'a',
         children:[
             {
                 val:'b',
                 children:[
                     {
                         val:'d',
                         children:''
                     },
                     {
                         val:'e',
                         children:''
                     }
                 ]
             },
             {
                 val:'c',
                 children:[
                     {
                         val:'f',
                         children:''
                     },
                     {
                         val:'g',
                         children:''
                     }
                 ]
             }
         ]
     }
     const bfs = (root) =>{
         //1.根节点入队
         const q = [root]
         while(q.length>0){
             //队头出队
             const n = q.shift()
             //访问队头
             console.log(n.val)
             //children入队
             n.children.forEach(child=>{
                 q.push(child)
             })
         }
         
     }
     ```

2. 使用场景

   - 二叉树

     - 定义 

       - 每个节点最多只有两个子节点
       - js中使用Object模拟二叉树

     - 遍历

       - 先序遍历

         <img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\先序遍历.png" style="zoom:50%;" />

         - 访问根节点
         - 对根节点的左子树进行先序遍历
         - 对根节点的右子树进行先序遍历

         ```js
         //二叉树
         const bt = {
             val:1,
             left:{
                 val:2,
                 left:{
                     val:4,
                     left:null,
                     right:null
                 },
                 right:{
                     val:5,
                     left:null,
                     right:null
                 }
             },
             right:{
                 val:3,
                 left:{
                     val:6,
                     left:null,
                     right:null
                 },
                 right:{
                     val:7,
                     left:null,
                     right:null
                 }
             }
         }
         //递归
         const preorder = (root) =>{
             if(!root) return
             //访问根节点
             console.log(root.val)
             //左子树
             preorder(root.left)
             //右子树
             preorder(root.right)
         }
         //非递归
         const preorder = (root) =>{
             if(!root) return
             const stack = [root]
             while(stack.length){
                 const  n = stack.pop()
             	console.log(n.val)
             	if(n.right) stack.push(n.right)
             	if(n.left) stack.push(n.left)
             } 
         }
         preorder(bt)
         ```
    ```
       
    ```
  - 中序遍历
    
    <img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\中序遍历.png" style="zoom:50%;" />
    
         - 对根节点的左子树进行中序遍历
         - 访问根节点
    - 对根节点的右子树进行中序遍历
      
         ```js
         //递归
         consr inorder = (root) =>{
             if(!root) return
             inorder(root.left)
             console.log(root.val)
             inorder(root.right)
         }
    //非递归
         const inorder = (root) =>{
        if(!root) return
             const stack = []
        let p = root
             while(stack.length || p){
                 while(p){
                 	stack.push(p)
            	p = p.left
             	}
             	const n = stack.pop()
             	console.log(n.val)
             	p = n.right
             } 
         }
         inorder(bt)
        ```
    
  - 后序遍历
    
      <img src="C:\Users\ASUS\Desktop\笔记\架构笔记\img\后序遍历.png" style="zoom:50%;" />
      
         - 对根节点的左子树进行后序遍历
         - 对根节点的右子树进行后续遍历
         - 访问根节点
      
         ```js
         //递归
         const postorder = (root) =>{
             if(!root) return
             postorder(root.left)
             postorder(root.right)
             console.log(root.val)
         }
         //非递归
       const postorder = (root) =>{
             if(!root) return
             const stack = [root]
             const outputStack = []
             while(stack.length){
                 const n = stack.pop()
                 outputStack.push(n)
                 if(n.left) stack.push(n.left)
                 if(n.right) stack.push(n.right)
             }
             while(outputStack.length){
                 const n = outputStack.pop()
                 console.log(n.val)
             }
         }
         postorder(bt)
         ```
      
   - [leetcode104:二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
   
     解题思路：
   
     - 求最大深度考虑使用深度优先遍历
     - 在深度优先遍历过程中，记录每个节点所在的层级，找出最大层级
     
     

   解题步骤：
     
     - 新建变量记录最大深度
     - 深度优先遍历整棵树，并记录每个节点的层级，同时不断刷新最大深度变量
   - 遍历结束时返回最大深度变量·
     
     ```js
     //时间复杂度o(n) 空间复杂度o(log(n)到n)
     let maxDepth = function(root){
         let res = 0
         consr dfs = (n,l) =>{
             if(!n) return
             if(!n.left && !n.right){
               res = Math.max(res,l)
             }
             dfs(n.left,l+1)
             dfs(n.right,l+1)
         }
         dfs(root,1)
         return res
     }
     ```
   ```
   
   - [leetcode111:二叉树最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
   
     解题思路：
   
     - 求最小深度，使用广度优先遍历
     - 遍历时遇到叶子节点停止遍历返回节点层级
     
     
   解题步骤：
     
     - 广度遍历整个树并记录节点层级
   - 遇到叶子节点返回节点层级停止遍历
       
     ```js\
     //时间复杂度o(n)空间复杂度o(n)
     let minDepth = function(root){
     	if(!root) return 0
     	const q = [[root,1]
     	while(q.length){
     		const [n,l] = q.shift()
     		if(!n.left && !n.right) return l
     		if(n.left) q.push([n.left,l+1])
     		if(n.right) q.push([n.right,l+1])
     	}
     	
     }
   ```

   - [leetcode102:二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
   
     解题思路：
   
     - 层序遍历顺序就是广度优先遍历
     - 遍历时要记录当前节点所处的层级，方便将其添加到不同的数组中
     
     

   解题步骤：
     
     - 广度优先遍历二叉树
   - 遍历过程中记录每个节点的层级并将其添加到不同数组
     
     ```js
     //时间复杂度o(n)
     let levelOrder = function(root){
         if(!root) return []
         const q = [[root,0]]
         const res = []
         while(q.length){
             const [n,l] = q.shift()
             if(!res[level]){
                 res.push([n.val])
             }else{
                 res[level].push(n.val)
             }
             if(n.left) q.push([n.left,l+1])
             if(n.right) q.push([n.right,l+1])
         }
         return res
     }
     //优化
     let levelOrder = function(root){
         if(!root) return []
         const q = [root]
         const res = []
         while(q.length){
             let len = q.length
             res.push([])
             while(len--){
                 const n = q.shift()
                 res[res.length-1].push(n.val)
             	if(n.left) q.push(n.left)
             	if(n.right) q.push(n.right)
             }
         }
         return res
     }
     ```
   ```
   
   - [leetcofde94:二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
   
     ```js
     //递归
     let inorderTraversal = function(root){
         const res = []
         const rec = (n) =>{
             if(!n) return
             rec(n.left)
             res.push(n.val)
             rec(n.right)
         }
         rec(root)
         return res
     }
     //迭代
     let inorderTraversal = function(root){
         const res = []
         const stack = []
         let p = root
         while(stack.length || p){
             while(p){
             	stack.push(p)
             	p = p.left
        		}
         	const n = stack.pop()
         	res.push(n.val)
             p = n.right
         }
         return res
     }
   ```

   - [leetcode112:路径总和](https://leetcode-cn.com/problems/path-sum/)
   
     解题思路：
   
     - 在深度优先遍历时记录当前路径的节点值的和
     - 在叶子节点处，判断当前路径节点值的和是否等于目标值
     
     

   解题步骤：
     
     - 深度遍历二叉树，在叶子节点处判断当前路径节点值的和是否等于目标值，是就返回true
   - 遍历结束，没有匹配返回false
     
     ```js
     //时间复杂度o(n) 空间复杂度o(n)
     let hasPathSum = function(root, targetSum) {
         if(!root) return false
         let res = false
         const dfs = (n,s)=>{
             if(!n.left && !n.right && s ===sum){
                 res = true
             }
             if(n.left) dfs(n.left,s+n.left.val)
             if(n.right) dfs(n.right,s+n.right.val)
         }
         dfs(root,root.val)
         return res
     };
     ```
   ```
   
   - 遍历json所有节点
   
     ```js
     const json = {
         a:{b:{c:{1}}},
         d:[1,2]
     }
     const dfs = (n,path) =>{
         Object.key(n).forEach(k=>{
             dfs(n[k],path.concat(k))
         })
     }
     dfs(json,[])
   ```

#### 图

1. 介绍

   - 图是网络结构的抽象模型，是一组由边连接的节点

   - 图可以表示任何二元关系eg:道路、航班

   - js没有图但可以用Object和Array构建图

   - 图的表示法：

     邻接矩阵

     ![邻接矩阵](C:\Users\ASUS\Desktop\笔记\架构笔记\img\邻接矩阵.png)

     邻接表

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\邻接表.png)

     关联矩阵

   - 图的操作

     - 深度优先遍历 尽可能深的搜索图的分支

       - 访问根节点

       - 对根节点的没有访问过的相邻节点挨个进行深度优先遍历

         ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\图深度优先.png)

         ```js
         const graph = {
             0:[1,2],
             1:[2],
             2:[0,3],
             3:[3]
         }
         const visited = new Set()
         const dfs = (n)=>{
             cosole.log(n)
             visited.add(n)
             graph[n].forEach(c=>{
                 if(!visited.has(c)){
                     dfs(c)
                 }
             })
         }
         dfs(2)
         ```

     - 广度优先遍历 先访问离根节点最近的节点

       - 新建一个队列把根节点入队
       - 把队头出队并访问
       - 把队头的没访问过的相邻节点入队
       - 重复23步直到队列为空

       ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\图广度优先遍历.png)

       ```js
       const visited = new Set()
       visited.add(2)
       const q = [2]
       while(q.length){
           const n = q.shift()
           console.log(n)
           visited.add(n)
           graph[n].forEach(c=>{
               if(!visited.has(c)){
                   q.push(c)
                   visited.add(c)
               }
           })
       }
       ```

2. 使用场景

   - [leetcode65：有效数字](https://leetcode-cn.com/problems/valid-number/)

     解题思路：

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\有效数字.png)

     解题步骤：

     - 构建一个表示状态的图
     - 遍历字符串并沿图走，如果到了某个节点无路可走就返回false
     - 遍历结束后如果走到356就返回true否则返回false

     ```js
     //时间复杂度o(n) 空间复杂度o(1)
     let isNumber = function(s){
         const graph = {
         	0:{'blank':0,'sign':1,'.':2,'digit':6},
        		1:{'digit':6,'.':2},
         	2:{'digit':3},
         	3:{'digit':3,'e':4},
         	4:{'digit':5,'sign':7},
         	5:{'digit':5},
         	6:{'digit':6,'.':3,'e':4},
         	7:{'digit':5}   
     	}
     	let state = 0
     	for(c of s.trim()){
             if(c >= '0' && c <= '9'){
                 c = 'digit'
             }else if(c === ' '){
                 c = 'blank'
             }else if(c === '+' || c === '-'){
                 c = 'sign'
             }
             state = graph[state][c]
             if(state === undefined) return false
             if(state == 3 || state == 5 || state ==6) return true
             return false
     	}
     }
     
     ```

     

   - [leetcode417:太平洋大西洋水流](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)
   
     解题思路：
   
     - 矩阵想象成图
     - 从海岸线逆流而上遍历图，所到之处就是可以留到某个大洋的坐标
   
     解题步骤：
   
     - 新建两个矩阵记录流到两个大洋的坐标
     - 从海岸线多管齐下，同时深度优先遍历图，过程中填充上述矩阵
     - 遍历两个矩阵找出能流到两个大洋的坐标
   
     ```js
     //时间复杂度o(m*n) 空间复杂度o(m*n)
     let pacificAtlantic = function(matrix){
         if(!matrix || !matrix[0]) return []
         //矩阵行数
         const m = matrix.length
         //矩阵列数
         const n = matrix[0].length
         const flow1 = Array.from({length:m},() => new Array(n).fill(false))
         const flow2 = Array.from({length:m},() => new Array(n).fill(false))
         const dfs = (r,c,flow) => {
             flow[r][c] = true
             [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].forEach(([nr,nc]) => {
                 if(
                 //在矩阵中
                 nr >= 0 && nr < m &&
                 nc >= 0 && nc < n &&
                 //防止死循环
                 !flow[nr][nc] &&
                 //保证逆流而上
                 matrix[nr][nc] >= matrix[r][c]   
                 ){
                     dfs(nr,nc,flow)
                 }
             })
         }
         //沿海岸线逆流而上
         for(let r = 0; r < m; r += 1){
             dfs(r,0,flow1)
             dfs(r,n-1,flow2)
         }
         for(let c = 0; c < n; c +=1){
             dfs(0,c,flow1)
             dfs(m-1,c,flow2)
         }
         const res = []
         for(let r = 0; r < m ; r += 1){
             for(let c = 0; c < n; c += 1){
                 if(flow1[r][c] && flow2[r][c]){
                     res.push([r,c])
                 }
             }
         }
         return res
     }
     ```
   
   - [leetcode133:克隆图](https://leetcode-cn.com/problems/clone-graph/)
   
     ```js
     //时间复杂度o(n)空间复杂度o(n)
     //深度优先遍历
     let cloneGraph = function(node){
         if(!node) return
         const visited = new Map()
         const dfs = (n) =>{
             const nCopy = new Node(n.val)
             visited.set(n,nCopy)
             (n.neighbors||[]).forEach((ne)=>{
                 if(!visited.has(ne)){
                     dfs(ne)
                 }
                 nCopy.neighbors.push(visited.get(ne))
             })
         }
         dfs(node)
         return visited.get(node)
     }
     //广度优先遍历
     let cloneGraph = function(node){
         if(!node) return
         const visited = new Map()
         visited.set(node,new Node(node.val))
         const q = [node]
         while(q.length){
             const n = q.shift()
             (n.neighbors || []).forEach(ne=>{
                 if(!visited.has(ne)){
                     q.push(ne)
                     visited.set(ne,new Node(ne.val))
                 }
                 visited.get(n).neighbors.push(visited.get(ne))
             })
         }
         return visited.get(node)
     }
     ```

#### 堆

1. 介绍

   - 堆是一种特殊的完全二叉树

   - 所有节点都大于等于（最大堆）或小于等于（最小堆）他的子节点

   - js中的堆

     ![](C:\Users\ASUS\Desktop\笔记\架构笔记\img\最小堆.png)

     - js通常用数组表示堆
     - 左侧子节点的位置是2*index+1
     - 右侧子节点的位置是2*index+2
     - 父节点位置是(index-1)/2
     - 堆能高效快速的找出最大值和最小值，时间复杂度o(1)

2. 使用场景

   - 最小堆类

     - 在类里声明一个数组用来装元素
     - 主要方法：
       - 插入 将值插入堆底（数组的尾部）然后上移将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值，大小为k的堆中插入元素的时间复杂度为o(logk)
       - 删除堆顶 用数组尾部元素替换堆顶（直接删除堆顶会破坏堆结构）然后下移将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶，大小为k的堆中删除堆顶的时间复杂度为o(logk)
       - 获取堆顶 返回数组的头部
       - 获取堆大小 返回数组的长度

     ```js
     class MinHeap{
         constructor(){
             this.heap = []
         }
         getParentIndex(i){
             //获取父节点 i除以2的商
             return (i-1) >> 1
         }
         getLeftIndex(i){
             return i*2+1
         }
         getRightIndex(i){
             return i*2+2
         }
         swap(i1,i2){
             //交换位置
             const tmp = this.heap[i1]
             this.heap[i1] = this.heap[i2]
             this.heap[i2] = tmp
         }
         shiftUp(index){
             if(index === 0) return
             const parentIndex = this.getParentIndex(index)
             if(this.heap[parentIndex]>this.heap[index]){
                 this.swap(parentIndex,index)
                 this.shiftUp(parentIndex)
             }
         }
         insert(value){
             this.heap.push(value)
             this.shiftUp(this.heap.length-1)
         }
         shiftDown(index){
             const leftIndex = this.getLeftIndex(index)
             const rightIndex = this.getRightIndex(index)
             if(this.heap[leftIndex]<this.heap[index]){
                 this.swap(leftIndex,index)
                 this.shiftDown(leftIndex)
             }
             if(this.heap[rightIndex]<this.heap[index]){
                 this.swap(rightIndex,index)
                 this.shiftDown(rightIndex)
             }
         }
         pop(){
             this.heap[0] = this.heap.pop()
             this.shiftDown(0)
         }
         peek(){
             return this.heap[0]
         }
         size(){
             return this.heap.length
         }
     }
     ```

   - [leetcode215:数组中的第k个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

     解题思路：

     - 看到'第k个最大元素'
     - 考虑使用最小堆

     解题步骤：

     - 构建一个最小堆并以此把数组的值插入堆中
     - 当堆的容量超过k就删除堆顶
     - 插入结束后堆顶就是第k个最大元素

     ```js
     let findKthLargest = function(nums,k){
         const h = new MinHeap()
         nums.forEach(n=>{
             h.insert(n)
             if(h.size()>k){
                 h.pop()
             }
         })
         return h.peek()
     }
     ```

   - [leetcode347：前k个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

     ```js
     let topKFrequent = function(nums,k){
         const map = new MinHeap()
         nums.forEach((value,key)=>{
             h.insert({value,key})
             if(h.size()>k){
                 h.pop()
             }
         })
         return h.heap.map(a=>a.key)
     }
     ```

   - [leetcode23:合并k个升序列表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

     解题思路：

     - 新链表的下一个节点一定是k个链表头中最小节点
     - 考虑使用最小堆

     解题步骤：

     - 构建一个最小堆并依次把链表头插入堆中
     - 弹出堆顶接到输出链表，并将堆顶所在链表的新链表头插入堆中
     - 等堆元素全部弹出合并工作就完成了

     ```js
     let mergeKLists = function(lists){
         const res = new ListNode(0)
         let p = res
         const h = new MinHeap()
         lists.forEach(l=>{
             if(l) h.insert(1)
         })
         while(h.size()){
             const n = h.pop()
             p.next = n
             p = p.next
             if(p.next) h.insert(n.next)
         }
         return res.next
     }
     ```

#### 排序和搜索

1. 介绍

   - 排序：把某个乱序的数组变成圣墟或者降序的数组

     - js中的排序 数组的sort()

     - 排序算法包括

       - 冒泡排序

         比较所有相邻元素，如果第一个比第二个大就交换，保证一轮下来最后一个数最大，执行n-1轮完成排序

         ```js
         //时间复杂度o(n^2)
         Array.prototype.bubbleSort = function(){
             for(let i = 0; i < this.length-1, i++){
                 for(let j = 0; j < this.length - i; j++){
                     if(this[j]>this[j+1]){
                         const tmp = this[j]
                         this[j] = this[j+1]
                         this[j+1] = tmp
                     }
                 }
             }
         }
         ```

       - 选择排序

         找到数组中的最小值，选中它并将其放置到第一位，找到第二小的值放到第二位，以此类推执行n-1轮

         ```js
         //时间复杂度o(n^2)
         Array.prototype.selectionSort = function(){
             let indexMin = 0
             for(let i = 0; i < this.length-1; i++){
             	for(let j = i; j < this.length; j++){
                 	if(this[j]<this[indexMin]){
                     	indexMin = j
                 	}
             	}
                 if(indexMin !== i){
             		const tmp = this[i]
             		this[i] = this[indexMin]
             		this[indexMin] = tmp
                 }
             }        
         }
         ```

       - 插入排序

         从第二个数开始往前比，比它大往后排，以此类推进行到最后一个数

         ```js
         //时间复杂度o(n^2)
         Array.prototype.insertionSort = function(){
             for(let i = 0; i < this.length; i++){
             	const tmp = this[i]
             	let j = i
             	while(j>0){
                 	if(this[j-1]>tmp){
                     	this[j] = this[j-1]
                 	}else{
                     	break
                 	}
                 	j--
             	}
             	this[j] = tmp
             }
         }
         ```
       
       - 归并排序
       
         把数组分称两半，递归子数组进行分操作 直到分成一个个单独的数，把两个数合并为有序数组，再对有序数组进行合并直到全部子数组合并为一个完整数组
       
         >合并两个有序数组
         >
         >- 新建一个空数组res用于存放最终排序后的数组
         >
         >- 比较两个有序数组的头部，较小者出队并推入res中
         >- 如果两个数组还有值就重复第二步
       
         ```js
         //时间复杂度o(n*logN)
         Array.prototype.mergeSort = function(){
             //分
             const rec = (arr)=>{
                 if(arr.length == 1) return arr
                 const mid = Math.floor(arr.length/2)
                 const left = arr.slice(0,mid)
                 const right = arr.slice(mid,arr.length)
                 const orderLeft = rec(left)
                 const orderRight = rec(right)
                 const res = []
                 while(orderLeft.length || orderRight.length){
                     if(orderLeft.length&&orderRight.length){
                         res.push(orderLeft[0]<orderRight[0]?orderLeft[0].shift():orderRight[0].shift())
                     }else if(orderLeft.length){
                         res.push(orderLeft.shift())
                     }else if(orderRight.length){
                         res.push(orderRight.shift())
                     }
                 }
                 return res
             }
             const res = rec(this)
             res.forEach((n,i)=>{this[i] = n})
         }
         ```
       
       - 快速排序
       
         在数组中任意选择一个基准，所有比基准小的元素放在基准前，比基准大的元素放基准后，递归地对基准前后的子数组进行分区
       
         ```js
         //时间复杂度o(n*logN)
         Array.prototype.quickSort = fuction(){
             const rec = (arr)=>{
                 if(arr.length === 1) return arr
                 const left = [],right = []
                 const mid = arr[0]
                 for(let i = 1; i < arr.length; i++){
                     if(arr[i]<mid){
                         left.push(arr[i])
                     }else{
                         right.push(arr[i])
                     }
                 }
                return [...rec(left),mid,...rec(right)]
             }
             const res = rec(this)
             res.forEach((n,i)=>(this[i] = n))
         }
         ```

   - 搜索：找出数组中某个元素的下标

     - js中的搜索 数组的indexOf()
     - 搜索算法包括
       - 顺序搜索
       
         遍历数组，找到跟目标值相等的元素返回下标，遍历结束后如果没有找到目标值返回-1
       
         ```js
         //时间复杂度o(n)
         Array.prototype.sequentialSearch = function(item){
             for(let i = 0; i < this.length; i++){
                 if(this[i] === item) return i
             }
             return -1
         }
         ```
       
       - 二分搜索  
       
         从数组中间元素开始，如果中间元素正好是目标值则搜索结束，如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半中搜索
       
         ```js
         //时间复杂度o(logN)
         Array.prototype.binaraSearch = function(item){
             let low = 0
             let high = this.length - 1
             while(low <= high){
                 const mid = Math.floor((low+high)/2)
                 const element = this[mid]
                 if(element<item){
                     low = mid +1
                 }else if(element > item){
                     high = mid -1
                 }else{
                     return mid
                 }
             }
             return -1
         }
         ```

2. 使用场景

   - [leetcode21:合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

     解题思路：

     - 与归并排序中的合并两个有序数类似
     - 将数组替换成链表就能解决此题

     解题步骤：

     - 新建新链表作为返回结果
     - 用指针1遍历两个有序链表，并比较·两个链表的当前节点，较小者先接入新链表并将指针后移一步
     - 链表遍历结束后返回新链表

     ```js
     //时间复杂度o(m+n)空间复杂度o(1)
     let mergeTwoLists = fucntion(l1,l2){
         const res = new ListNode(0)
         let  p = res, p1 = l1, p2 = l2
         while(p1&&p2){
             if(p1.val < p2.val){
                 p.next = p1
                 p1 = p1.next
             }else{
                 p.next = p2
                 p2 = p2.next
             }
             p = p.next
         }
         if(p1){
             p.next = p1
         }
         if(p2){
             p.next = p2
         }
         return res.next
     }
     ```

   - [leetcode374:猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

     解题思路：

     - 二分搜索
     - 调用guess函数判断中间元素是否是目标值

     解题步骤：

     - 从数组中间元素开始，如果中间元素正好是目标值则搜索过程结束
     - 目标值小于或者大于中间元素则在数组大于或小于中间元素的那一般中查找

     ```js
     let guessNumber = function(n){
         let low = 1,high = n
         while(low <= high){
             const mid = Math.flow((low+high)/2)
             const res = guess(mid)
             if(res === 0){
                 return mid
             }else if(res === 1){
                 low = mid+1
             }else{
                 high = mid -1
             }
         }
     }
     ```

#### 分而治之

1. 介绍

   - 算法设计中的一种方法
   - 将一个问题分成多个和原问题想似的小问题，递归解决小问题，再将结果合并以解决原来的问题
   - 使用
     - 归并排序
       - 分：把数组一分为二
       - 解：递归的对两个子数组进行归并排序
       - 合：合并有序子数组
     - 快速排序
       - 分：选基准，按基准把数组分成两个子数组
       - 解：递归地对两个子数组进行快速排序
       - 合：对两个子数组进行合并

2. 使用场景

   - [leetcode374:猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

     ```js
     let guessNuber = function(n){
         const rec = (low,high) => {
             if(low>high) return
             const mid = Math.floor((low+high)/2)
             const res = guess(mid)
             if(res === 0){
                 return mid
             }else if(res===1){
                 return rec(mid+1,high)
             }else{
                 return rec(1,mid-1)
             }
         }
         return rec(1,n)
     }
     ```

   - [leetcode226:翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

     解题思路：

     - 先翻转左右子树，再将子树换个位置
     - 符合'分解合'特性

     解题步骤：

     - 获取左右子树
     - 递归的翻转左右子树
     - 将翻转后的左右子树换个位置放到根节点上

     ```js
     //时间复杂度o(n)空间复杂度o(n)
     let invertTree = function(root){
         if(!root) return null
         return {
             val:root.val,
             left:invertTree(root.right)
             right:invertTree(root.left)
         }
     }
     ```

   - [leetcode100:相同的树](https://leetcode-cn.com/problems/same-tree/)

     解题思路：

     - 两个树相同：根节点的值相同，左子树相同右子树相同
     - 符合"分、解、合"

     解题步骤：

     - 分:获取两个子树的左子树和右子树
     - 解:递归地判断两个树的左子树是否相同右子树是否相同
     - 合：将上述结果合并，如果根节点的值也相同树就相同

     ```js
     let isSameTree = function(p, q) {
         if(!p && !q) return true
         if(p && q && p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)) return true
         return false
     };
     ```

   - [leetcode101:对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

     解题思路：

     - 转为左右子树是否镜像
     - 树1的左子树和树2的右子树是否是镜像，树1的右子树和树2的右子树是否是镜像

     解题步骤：

     - 分：获取两个数的左子树和右子树
     - 解：递归的判断树1的左子树和树2的右子树是否镜像，树1的右子树和树2的右子树是否是镜像
     - 合：如果上述成立且根节点值也相同，两个树就镜像

     ```js
     let isSymmetric = function(root) {
         if(!root) return true
         const isMirror = (l,r) => {
             if(!l && !r) return true
             if(l && r && l.val == r.val && isMirror(l.left,r.right && isMirror(l.right,r.left))){
                 return true
             }
             return false
         }
         return isMirror(root.left,root.right)
     };
     ```


#### 动态规划

1. 介绍

   - 动态规划是算法设计的一种方法
   - 将问题分解为互相重叠的子问题，通过反复求解子问题解决原来的问题
   - 与分而治之的区别在于子问题是否重叠

2. 使用场景

   - [leetcode70:爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

     解题思路：

     - 爬到第n阶可以在第n-1阶怕1个台阶或在第n-2阶怕2个台阶
     - F(N) = F(N-1) +F(N-2)

     解题步骤：

     - 定义子问题 F(N) = F(N-1) +F(N-2)
     - 反复执行从2循环到n执行上述公式

     ```js
     //时间复杂度o(n) 空间复杂度o(1)
     let climbStairs = function(n) {
         if(n<2) return 1
         let dp0 = 1, dp1 = 1
         for(let i = 2; i <= n; i++){
             const tmp = dp0
             dp[0] = dp1
             dp1 = dp1 +tmp
         }
         return dp1
     };
     ```

   - [leetcode198:打家劫舍](https://leetcode-cn.com/problems/house-robber/)

     解题思路：

     - f(k) = 从前k个房中能偷到的最大数
     - Ak = 第k个房的钱
     - f(k) = max(f(k-2) + Ak, f(k-1))

     解题步骤：

     - 定义子问题：f(k) = max(f(k-2) + Ak, f(k-1))
     - 循环子问题

     ```js
     //时间复杂度o(n) 空间复杂度o(n)
     let rob = function(nums) {
         if(nums.length === 0) return 0
         const dp = [0,nums[0]]
         for(let i = 2; i <= nums.length; i++){
             dp[i] = Math.max(dp[i-2] + nums[i-1],dp[i-1])
         }
         return dp[nums.length]
     };
     //优化空间复杂度为o(1)
     let rob = function(nums) {
         if(nums.length === 0) return 0
         const dp0 = 0, dp1 = nums[0]
         for(let i = 2; i <= nums.length; i++){
             const dp2= Math.max(dp0 + nums[i-1],dp1)
             dp0 = dp1
             dp1 = dp2
         }
         return dp1
     };
     ```

#### 贪心算法

1.介绍

- 贪心算法是算法设计中的一种方法
- 通过每个阶段的局部最优选择达到全局的最优
- 结果不一定是最优

2.使用场景

- [leetcode455:分饼干](https://leetcode-cn.com/problems/assign-cookies/)

  解题思路：

  - 局部最优：既能满足孩子还消耗最少
  - 先将较小的饼干分给胃口最小的孩子

  解题步骤：

  - 对饼干数组和胃口数组升序排序
  - 遍历饼干数组找到能满足第一个孩子的饼干
  - 继续遍历饼干数组，找到满足第二三...n个孩子的饼干

  ```js
  //时间复杂度o(n*logN)空间复杂度o(1)
  let findContentChildren = function(g, s) {
      const sortFuc = function(a,b){
          return  a-b
      }
      g.sort(sortFuc)
      s.sort(sortFuc)
      let i = 0
      s.forEach(n=>{
          if(n >= g[i]){
              i += 1
          }
      })
      return i
  };
  ```

- [leetcode122:买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

  解题思路：

  - 前提是知道未来价格
  - 局部最优：见好就收见差不动

  解题步骤:

  - 新建变量统计总利润
  - 遍历价格数组，如果当天价格比昨天高，就在昨天买今天卖，否则就不交易
  - 遍历结束后返回所有利润和

  ```js
  //时间复杂度o(n)空间复杂度o(1)
  let maxProfit = function(prices) {
      let profit = o
      for(let i = 1; i < prices.length;i++){
          if(prices[i] > prices[i-1]){
              profit += prices[i]-prices[i-1]
          }
      }
      return profit
  };
  ```

#### 回溯算法

1. 介绍：

   - 回溯算法是算法设计中的一种方法
   - 一种渐进式寻找并构建问题解决方式的策略
   - 先从一个可能的动作开始解决问题，如果不行就回溯并选择另一个动作直到问题解决

2. 使用场景：

   - [leetcode46:全排列](https://leetcode-cn.com/problems/permutations/)

     解题思路：

     - 要求：所有排列情况，没有重复元素
     - 有出路有死路
     - 考虑使用回溯算法

     解题步骤：

     - 用递归模拟所有情况
     - 遇到包含重复元素的情况就回溯
     - 收集所有到达递归终点的情况并返回

     ```js
     //时间复杂度o(n!) 空间复杂度o(n)
     let permute = function(nums) {
         const res = []
         const backtrack = (path) =>{
             if(path.length === nums.length){
                 res.push(path)
                 return
             }
             nums.forEach(n=>{
                 if(path.inclueds(n)) return
                 backtrack(path.concat(n))
             })
         }
         backtrack([])
         return res
     };
     ```

   - [leetcode78:子集](https://leetcode-cn.com/problems/subsets/)

     解题思路：

     - 要求：所有子集，没有重复元素
     - 有出路有死路

     解题步骤：

     - 用递归模拟出所有情况
     - 保证接的数字都是后面的数字
     - 收集所有到达递归终点的情况并返回

     ```js
     //时间复杂度o(2^n) 空间复杂度o(n)
     let ubsets = function(nums) {
         const res = []
         const backtrack = (path,l,start) =>{
             if(path.length === l){
                 res.push(path)
                 return
             }
             for(let i = start; i <= nums.length; i++){
                 backtrack(path.concat(nums[i]),l,i+1)
             }
         }
         for(let i = 0; i <= nums.length; i += 1){
             backtrack([],i,0)
         }
         return res
     };
     ```

     